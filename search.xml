<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用JavaScript删除全部的微博]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2F%E4%BD%BF%E7%94%A8JavaScript%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E7%9A%84%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[生活中常常会遇到一些繁琐重复而又没有意义的东西, 所以常有人说, 作为一个程序员, 应该避免做重复没意义的事, 我们学习编程最终的目的之一无非也是偷懒….. 能让自动的就坚决不手动. 当然, 除了在学习中自己造一些有意义的轮子除外. 今天就利用一些自己所学的知识去解决生活上的一些麻烦. 比如..自动删光微博黑历史~ 开始打开chrome浏览器(其他非IE现代浏览器都可以), 进入我的主页, 然后按下F12进入控制台. 原理分析首先这次只是单纯的想通过JavaScript批量删除全部微博代替手动而已, 那么就简单了. 我们只需要模仿点击删除的动作. 找到删除微博的key, 选中DOM元素, 这里我们可以看到菜单a标签中有一个属性action-type=&quot;fl_menu, 在控制台进使用document.querySelectorAll进行测试输出, 可以看到是一个NodeList的类数组, 分别对应着页面每一个fl_menu. 点击menu弹出下拉菜单, 继续用同样的方法分析节点, 找出一个表示用于删除的属性. 一般来说, 一个合格的程序员都懂得编写语义化的代码, 这里先推测action-type=&quot;feed_list_delete这个属性是专属删除微博的属性, 使用document.querySelector将代码在控制台上测试输出. 获取到页面中第一个delete DOM, 模拟点击后弹出一个确定框, 再次使用相同的方法确定即可. 代码实现一般网站都会限制用户频繁操作, 这里我们使用setTimeout, 测试一个weibo能够容忍的一个操作频率(可能还跟网速有关).12345678910111213141516171819202122232425window.onload = (function() &#123; // 经测试, 750ms是一个较快较稳定的频率, 效率过快会弹警告. var timer = setTimeout(Delete, 750); var item = 0; function Delete() &#123; /* 这里需要停止定时器等待加载, 请求XHR进行加载剩余微博. * 这里是微博的一个限制, 当页面中不存在相应的DOM, 就进行页面刷新. */ if (item &gt; 15) &#123; item = 0; clearTimeout(timer); return timer = setTimeout(Delete, 15000); &#125; // 模拟点击 document.querySelector('a[action-type="fl_menu"]').click(); document.querySelector('a[action-type="feed_list_delete"]').click(); document.querySelector('a[action-type="ok"]').click(); ++item; console.log(`已成功删除了$&#123;item&#125;项`); timer = setTimeout(Delete, 750); &#125;&#125;)(); 总结这样我们想要的效果就实现了.省去了一条一条删的人力, 又能运用到自己所学的知识. 其实代码代码也很简单, 无非是用到了setTimeout重复去递归调用而已. 要注意的是querySelector, 和querySelector都是IE9+的API, 在这里没有去考虑对IE的兼容, 并且也没有必要.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>实战</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript深入理解-裁剪图片效果]]></title>
    <url>%2Fblog%2F2017%2F11%2F17%2FJavascript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在生活中我们时常能看到这种图片裁剪的效果, 那么他实际上底层的原理是怎么实现的呢? 让我们深入的解剖一下. 原理分析 首先我们先将视图一分为三, 理解为三个层级叠加在一起的仰视图. 最上面是可拖动的选择窗口 中间待剪辑的可视窗口 底层是一张opacity: .5的背景图片 基础结构我们这里主要讲JavaScript, HTML与css就简要的过一下. 首先HTML基本结构是两张相同的结构, 两张图片分别是调整过透明度的底图和一张被裁剪过了的中间层.mainBox包裹着选择的小方块square,相对定位于image在最上面一层.123456789101112131415161718&lt;!-- index.html --&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image1"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image2"&gt; &lt;div id="mainBox" class="main"&gt; &lt;div class="square left-up"&gt;&lt;/div&gt; &lt;div class="square up"&gt;&lt;/div&gt; &lt;div class="square right-up"&gt;&lt;/div&gt; &lt;div class="square right"&gt;&lt;/div&gt; &lt;div class="square right-down"&gt;&lt;/div&gt; &lt;div class="square down"&gt;&lt;/div&gt; &lt;div class="square left-down"&gt;&lt;/div&gt; &lt;div class="square left"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324/* main.css */body &#123;background: #333;&#125;#box &#123;position: absolute;top: 100px; left: 200px; width: 460px; height: 360px;&#125;#box img &#123;width: 460px;&#125;#box #image1 &#123;opacity: .5;position: absolute; top: 0;left: 0;&#125;#box #image2 &#123;position: absolute; top: 0;left: 0; clip: rect(0, 200px, 200px, 0) &#125;#box .main &#123;position: absolute;border: 1px solid #fff; width: 200px; height: 200px;box-sizing: border-box;&#125;#box .main .square &#123;position: absolute; width: 8px;height: 8px; background: #fff&#125;#box .main .left-up&#123;left: -4px;top: -4px;cursor: nw-resize;&#125;#box .main .up&#123;left: 50%;top: -4px;margin-left: -4px;cursor: n-resize&#125;#box .main .right-up&#123;right: -4px;top: -4px;cursor: ne-resize&#125;#box .main .right&#123;right: -4px;top: 50%;margin-top: -4px;cursor: e-resize&#125;#box .main .right-down&#123;right: -4px;bottom: -4px;cursor: se-resize&#125;#box .main .down&#123;left: 50%;bottom: -4px;margin-left: -4px;cursor: s-resize&#125;#box .main .left-down&#123;left: -4px;bottom: -4px;cursor: sw-resize&#125;#box .main .left&#123;top: 50%;left: -4px;margin-top: -4px;cursor: w-resize&#125;#box &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; JavaScript实现ESMAScript并没有提供可拖动的API, 那我们先来思考一下, 该如何实现拖动的功能~ 最上层有9个小方块(Square), 分别代表着不同方向的边界, 拖动这个边界, 无非需要实现这几个底层步骤… 鼠标落下(MouseDown) =&gt; 鼠标拖动 =&gt; 松开鼠标(MouseUp). 这样思路就清晰了. 先创建一个clipImage函数作为入口函数, 主要获取目标元素和生成DOM节点(后面讲), 绑定事件. 按照思路我们先应该给控制元素绑定一个事件(mousedown), 鼠标落下后会触发一个事件(MouseEvent), 事件监听器将事件作为形参, 通过调用函数onMousedown传入实参e来获取数据. 1234567891011121314151617181920212223242526;(function() &#123; // Util工具函数 var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; // "全局变量", 记录状态 var _MainBox, _MainCtrl, _MainType; var startX = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var right = util.$('#box .main .right'); // Add mouse down event up.addEventListener('mousedown', function(e) &#123; onMousedown(e, box, up, 'up'); &#125;); function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; &#125;&#125;)(); 将e输出到控制台看看输出的是什么先~ MDN - MouseEvent 接口指用户与指针设备( 如鼠标 )交互时发生的事件 MDN - MouseEvent.pageX&emsp;返回鼠标指针相对于整个文档的X坐标. MDN - HTMLElement.offsetLeft&emsp;返回当前元素左上角相对于父元素左边界的偏差值 onMousedown函数中, 接受四个参数e事件, box目标元素, ctrl小方块的方向, type属性, 主要是用来记录鼠标落下(MouseDown)相对于容器的起始坐标(start)并赋值给全局变量进行通讯. 1234567891011function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 鼠标点击时的起始坐标 startX = e.pageX - ctrl.offsetLeft; // 将接受到的信息暴露出去. _MainBox = box; _MainCtrl = ctrl; _MainType = type; &#125; 接着来计算鼠标移动的距离, 我们在onMouseDown函数上再去触发一个移动函数onMove, 以鼠标落下为起点控制元素的偏移. 初始化全局变量pageX, 添加事件监听记录鼠标在页面中的坐标, 进而计算偏移量. 再添加一个标识符, 来确定是否在拖动的状态.123456789101112131415161718192021222324252627282930313233343536373839var pageX = 0;var moving = 0;function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 鼠标点击时的坐标 startX = e.pageX - ctrl.offsetLeft; _MainBox = box; _MainCtrl = ctrl; _MainType = type; // 移动计算偏移量并设置到box上 onMove();&#125;function onMove() &#123; var minleft = _MainBox.offsetLeft; // 计算原先的坐标偏移了多少, 并设置上限 var offsetX = pageX - startX; offsetX = Math.max(offsetX, minleft); // 设置小方块偏移量和, box宽度, 再循坏调用定时器实现拖动的效果 switch(_MainType) &#123; case "right": _MainCtrl.style.left = offsetX + 'px'; _MainBox.style.width = offsetX + 6 + 'px'; break; &#125; setTimeout(onMove, 10);&#125;// 监听鼠标相对于页面的坐标document.onmousemove = function(e) &#123; var e = window.event || e; pageX = e.pageX; &#125;; 紧接着我们会发现, 哪怕松开鼠标边框还是会随着鼠标跑, 这是因为还没有清除定时器. 随即我们去监听鼠标松开事件(MouseUp). &lt;– 努力填坑中~ –&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之三 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F11%2F06%2FBasic%20Algorithm%20Scripting%20-%203%2F</url>
    <content type="text"><![CDATA[今天让继续来学习数组方法的用法~ Sum All Numbers in a Range 题目描述 &emsp;&emsp;传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。最小的数字并非总在最前面。比如传递[1, 4]会返回10, 即1 + 2 + 3 + 4. 非数组方法1234567891011121314 function sumAll(arr) &#123; var max = Math.max.apply(null, arr); var min = Math.min.apply(null,arr); var num = max - min; var total = min; while(num) &#123; num--; total += ++min; &#125; return total;&#125;sumAll([1, 1]); &lt;– 未待续~ 有空再深挖 –&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过sourcetree实现远程仓库与本地仓库关联]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2F%E9%80%9A%E8%BF%87sourcetree%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率. &emsp;&emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联. 步骤&emsp;首先把本地仓库初始化. &emsp;再添加到sourcetree上 &emsp;进入github.com -&gt; your profile -&gt; repositories(仓库) -&gt; New &emsp;填写仓库信息, 复制仓库链接 &emsp;设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定 &emsp;然后就可以提交到github了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>sourcetree</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之二 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F19%2FBasic%20Algorithm%20Scripting%20-%202%2F</url>
    <content type="text"><![CDATA[数组方法的深入学习 Chunky Monkey(分割数组)猴子吃香蕉, 分割数组,把一个数组arr按照指定的数组大小size分割成若干个数组块。例如: &#8195;&#8195;hunk([1,2,3,4],2) =&gt; [[1,2],[3,4]]; &#8195;&#8195;chunk([1,2,3,4,5],2) =&gt; [[1,2],[3,4],[5]]; 思路 &#8195;这道题重点主要是每size个值分割一个数组,这里我们可以使用以下几种方法来解题. while + splice for + slice while + slice 第一种12345678910111213141516// while + splicefunction chunk(arr, size) &#123; // 定义一个新数组和用来临时存放分割的空数组. var a = [], t = [], i = 0, len = arr.length; while (i &lt; len)&#123; t = arr.splice(0, size); a.push(t); i += size; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); &#8195;在这里值得注意的是,len保存arr.length的快照是必须的..因为splice会修改原来原来的数组. 第二种12345678910111213141516171819// for + splicefunction chunk(arr, size) &#123; var a = [], t = [], len = arr.length; // 数组中的个数小于size或者size是小于等于0的也就没有必要分割了 if (len &lt;= size || size &lt;= 0) &#123; return arr; &#125; else &#123; // 它的重点主要是数组中的值的数量 for (var i = 0;i &lt; len; i += size) &#123; // 查询指定数 t = arr.slice(i, i + size); a.push(t); &#125; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); 第三种1234567891011121314// while + slicefunction chunk(arr, size) &#123; var a = [], t = [], i = 0, len = arr.length; while (i &lt; len) &#123; // 查询的值 t = arr.slice(i, i += size); a.push(t); &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); Falsy Bouncer(过滤数组假值)删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。 思路 &#8195;这道题比较有意思..一开始我走进了一个误区,想着单纯return x !== false &amp;&amp; ...这样简单的返回就可以了,后来发现在处理NaN时会很麻烦..isNaN()还会把英文字符串也给过滤掉,再加上多个&amp;&amp;使得代码会变得繁乱,可读性不高.&#8195;然后查阅了一番资料后,才注意到平时被忽略Boolean()的一些特性对于处理这种类型的问题简直不能太合适. 12345678910function bouncer(arr) &#123; // 请把你的代码写在这里 var a = arr.filter(function(x) &#123; return Boolean(x); &#125;); return a;&#125;bouncer([7, "ate", "", false, 9]); &#8195;摘至MDN.Boolean 的描述: 如果Boolean构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的Boolean对象的值为false. 其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为true的Boolean对象. Seek and Destroy (摧毁指定数组)实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 实现原理 &#8195;filter() 为数组中的每个元素调用一次 callback函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组.&#8195;filter()从头至尾遍历数组,若回调函数返回的是true(通过测试),就存入新数组中.若返回的是false,则过滤掉. 12345678910111213141516function destroyer(arr) &#123; // 先将第一个参数隔开,定义一个储存着待移除的空数组 var args = arguments[0], removeArgs = []; // 要被删除的参数装进'removeArgs'里 for (var i = 1; i &lt; arguments.length; i++) &#123; removeArgs.push(arguments[i]); &#125; // 遍历'args',若'removeArgs'中不存在'value',应该返回-1.反之返回false被过滤掉. return args.filter(function(value) &#123; return removeArgs.indexOf(value) === -1; &#125;);&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); Where do I belong (数组排序并找出元素索引)先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 &#8195;举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。 &#8195; 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。 思路 &#8195;这个没啥好说的了..将第二个参数push进数组中,再进行排序.排序后通过indexOf()来实现功能.不过需要注意的是sort默认是按照’Unicode’编码进行排序的. Caesars Cipher (凯撒密码)风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 思路 &#8195;本次练习用到String.charCodeAt()和String.fromCharCode(),首先来查询字符串的Unicode字符.&#8195;根据Unicode表我们得知: 小于65和大于90对应的就是数字和小写字符a-z 大于等于65和小于等于77对应的就是大写字符A-M (13位) 大于等于78和小于等于90对应的就是大写字符N-Z&#8195;ROT13的功能就是移位,如果序号小于78(A-M字母)，使用String.fromCharCode()转换成该序号加13的字符,反之减13. 1234567891011121314151617181920212223function rot13(str) &#123; // LBH QVQ VG! var newStr = []; for (var i = 0;i &lt; str.length;i ++) &#123; // 查询每个字符串的Unicode编号 var temp = str.charCodeAt(i); // 非大写字母,空格,数字等都不转换 if (temp &lt; 65 || temp &gt; 91) &#123; newStr.push(str.charAt(i)); continue; // 大于77(N-Z),就转换成该序号 - 13的字符串. &#125; else if (temp &gt; 77) &#123; newStr.push(String.fromCharCode(temp - 13)); // 小于78(A-M),就转换成该序号 + 13的字符串 &#125; else &#123; newStr.push(String.fromCharCode(temp + 13)); &#125; &#125; return newStr.join('');&#125;rot13("SERR PBQR PNZC"); // 你可以修改这一行来测试你的代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之一 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2FBasic%20Algorithm%20Scripting%20-%201%2F</url>
    <content type="text"><![CDATA[一些基础的算法练习 Palindromes(回文处理)Palindromes称之为回文。在中文文当中是指倒着念和顺着念都是相同的，前后对称. 正则表达式 replace() 1234567function palindrome(str) &#123; var string = str.replace(/[\W_]/g,'').toLowerCase(); var replaceStr = string.split('').reverse().join(''); return replaceStr === string;&#125;palindrome("eye"); // true 思路 &#8195;首先对字符串进行处理..去掉字符串多余的标点符号和空格，然后把字符串转化成小写.&#8195;split把字符串拆分为一个字符串组成的数组.reverse反转数组顺序,join拼接字符串. Title Case a Sentence(首个单词字母大写)句中单词首字母大写,确保字符串的每个单词首字母都大写，其余部分小写。 1234567function titleCase(str) &#123; return str.toLowerCase().replace(/( |^)[a-z]/g, function(L) &#123; return L.toUpperCase(); &#125;);&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot 思路 &#8195;首先把字符串转换为小写,再用正则匹配带空格或者就字母开头的首个字母replace替换成大写字母. Return Largest Numbers in Arrays(返回数组最大的数字)找出多个数组中的最大数,并返回一个新数组 12345678910111213function largestOfFour(arr) &#123; // 请把你的代码写在这里 var count = []; for (var i = 0; i &lt; arr.length; i ++) &#123; var a = arr[i].sort(function (a,b) &#123; return b-a; &#125;); count.push(a[0]); &#125; return count;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); // [5,27,39,1001] 思路 &#8195;新定义一个数组,遍历传进来的数组进行从大到小排序,将排序后最大的数push进新的数组count最后再返回. Confirm the Ending(检查字符串结尾)检查字符串结尾,判断一个字符串(str)是否以指定的字符串(target)结尾。如果是，返回true;如果不是，返回false。 123456789101112function confirmEnding(str, target) &#123; var l = str.length - target.length; if (str.substr(l) === target) &#123; return true; &#125; else &#123; return false; &#125;&#125;confirmEnding("Connor", "n"); // falseconfirmEnding("Bastian", "n"); // trueconfirmEnding("He has to give me a new name", "me"); // true 思路 &#8195;乍一看好像挺麻烦的样子,容我们深入一看却发现好像并没有想象中的麻烦..&#8195;这里用上了String.prototype.substr()而参数start是一个字符的索引,把字符串str.length - target.length就可以对比结尾字符串是否一样了. Repeat a string repeat a string(重复输出字符串)重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。 &#8195;对于这种题目可以使用两种方法解决: 递归 while循环 12345678910111213// 第一种使用递归function repeat(str, num) &#123; // 请把你的代码写在这里 if (num &lt; 0)&#123; return ""; &#125; else if (num === 1) &#123; return str; &#125; else &#123; return str + repeat(str, num - 1); &#125;&#125;repeat("abc", 3); // "abcabcabc" 1234567891011// 第二种使用whilefunction repeat(str, num) &#123; var s = ''; while(num &gt; 0)&#123; s += str; num --; &#125; return s;&#125;repeat("abc", 3); 思路 &#8195;递归一般放进if()判断语句中,是一种通过重复地调用函数本身,逐次减少num的值来实现效果.第二种使用了while语句,每调用一次就递减1,直至num &gt; 0. Truncate a string(截断字符串)截断字符串,如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。插入到字符串尾部的三个点号也会计入字符串的长度。如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213function truncate(str, num) &#123; // 首先判断num的值是不是大于字符串的长度,若是,那就没有必要省略了. if(num &gt;= str.length) &#123; return str; &#125; else if (num &lt;= 3) &#123; return str.slice(0,num) + "..."; &#125; else &#123; return str.slice(0,num-3) + "..."; &#125;&#125;truncate("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length); 思路 &#8195;slice截取字符串.substr(),indexOf()和lastIndexOf()办法同理.https://www.w3cplus.com/javascript/confirm-the-ending.html 大漠老师有一篇文章对此使用有着更详细的说明.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
