<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈Normalize与reset]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2F%E6%B5%85%E8%B0%88Normalize%E4%B8%8Ereset%2F</url>
    <content type="text"><![CDATA[前言: 在一次开发的时候, 发现团队中的小伙伴对normalize与reset都持有不同分歧. 趁着这事来谈谈, normalize与reset都有什么区别, 该如何取舍. resetreset, 顾名思义就是重置的意思. 最早的一份CSS reset来自Tantek的undohtml.css, Tantek根据自己的需要，对浏览器的默认样式进行了一些重置。 早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题, reset 的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”. 此后国内出现* {margin: 0, padding: 0}这种暴力清除全部样式的reset出现. normalizeNormalize, 从字面上也理解也就是使其正常化. 这是css reset的一个代替方案.Normalize相对「平和」, 注重通用的方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。 创造normalize.css的目的主要是: 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 两者相比较那么相对来说, 两者之间又有什么区别呢? 这里引用一下知乎用户的回答. CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧 Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理，简单粗暴地一视同仁是不好的。body 那一圈确实挤压了页面的生存空间，那就改掉。士农工商，谁有谁的作用，给他们制定个规范，确保他们在任何浏览器里都干好自己的活儿。 总结用张鑫旭老师的话来说就是. 早期人们盲目跟风, 不假思索直接把reset代码直接复制过来就用, 脱离了reset初衷. normalize相对来说就像是打补丁, 个人的建议就是, 在normalize消除浏览器差异基础上, 再根据项目需求将一些常用的样式重置即可. 如:1234567891011121314151617181920212223242526 body, dl, dd, h1, h2, h3, h4, h5, h6, p, form, ol, ul &#123; margin: 0;&#125;ol, ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none;&#125;body &#123; font: 14px/1.6 Monda,PingFang SC,Microsoft YaHei,sans-serif;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: block;&#125;.clearfix:after &#123; clear: both;&#125; 参考资料: Normalize.css 与传统的 CSS Reset 有哪些区别？normalize、reset与base关于CSS Reset 那些事（一）之 历史演变与Normalize.css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈npm包里的 install --save 和 install --save-dev之间的区别]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2F%E8%B0%88%E8%B0%88npm%E5%8C%85%E9%87%8C%E7%9A%84%20install%20--save%20%E5%92%8C%20install%20--save-dev%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当我们使用npm进行开发时经常能遇到需要安装依赖包, 那么npm install --save和npm install --save-dev之间到底有什么区别呢? 现在来探究一番. –save-dev实际上--save-dev是开发时候所依赖的东西，如我们想添加自动添加前缀, 那么就安装autoprefixer到开发依赖去. 也就是编译打包后autoprefixer已经帮我们添加了相应的浏览器前缀, 那么我们之后就不需要依赖他了. 所以1npm install babel --save-dev 在这里我们可以看到已经放进package.json中的devDependencies(生产依赖)中去了. –save--save就是你发布之后还依赖的东西。 如果编译打包后还需要依赖的库, 如vue, 所以就放进了dependencies中. 两者需要安装的依赖其实都可以在package.json中手动输入相应的库和版本号, 然后使用npm install就能进行安装package.json中的所有依赖了~]]></content>
      <tags>
        <tag>npm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在浏览器地址输入URL回车后，中间发生了什么？]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2F%E5%9C%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近在面试的时候遇到了一道比较经典的面试题, 在Chrome浏览器地址栏输入url, 回车之后会发生什么事?题目很经典, 自己也懂些大概. 不过抱着探究原理的精神. 也查询了相关的知识, 今天就来探讨一下, 浏览器的处理过程是怎么样的~ Start当我们在地址栏输入网址时, 其实就是要向服务器请求我们想要的资源. 1. 解析Url首先开始解析Url, 分析输入的Url还是搜索关键字 2. DNS查询2.1. 浏览器缓存 然后浏览器开始检测域名是否还存在缓存中, 如果缓存没有就gethostbyname库函数进行查询. 2.2 Hosts文件 gethostbyname函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里. 2.3 本地DNS服务器 hosts 中也没有找到的话, 将会向DNS 服务器发送一条DNS查询请求. 2.4 路由缓存 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用JavaScript删除全部的微博]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2F%E4%BD%BF%E7%94%A8JavaScript%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E7%9A%84%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[生活中常常会遇到一些繁琐重复而又没有意义的东西, 所以常有人说, 作为一个程序员, 应该避免做重复没意义的事, 我们学习编程最终的目的之一无非也是偷懒….. 能让自动的就坚决不手动. 当然, 除了在学习中自己造一些有意义的轮子除外. 今天就利用一些自己所学的知识去解决生活上的一些麻烦. 比如..自动删光微博黑历史~ 开始打开chrome浏览器(其他非IE现代浏览器都可以), 进入我的主页, 然后按下F12进入控制台. 原理分析首先这次只是单纯的想通过JavaScript批量删除全部微博代替手动而已, 那么就简单了. 我们只需要模仿点击删除的动作. 找到删除微博的key, 选中DOM元素, 这里我们可以看到菜单a标签中有一个属性action-type=&quot;fl_menu, 在控制台进使用document.querySelectorAll进行测试输出, 可以看到是一个NodeList的类数组, 分别对应着页面每一个fl_menu. 点击menu弹出下拉菜单, 继续用同样的方法分析节点, 找出一个表示用于删除的属性. 一般来说, 一个合格的程序员都懂得编写语义化的代码, 这里先推测action-type=&quot;feed_list_delete这个属性是专属删除微博的属性, 使用document.querySelector将代码在控制台上测试输出. 获取到页面中第一个delete DOM, 模拟点击后弹出一个确定框, 再次使用相同的方法确定即可. 代码实现一般网站都会限制用户频繁操作, 这里我们使用setTimeout, 测试一个weibo能够容忍的一个操作频率(可能还跟网速有关).12345678910111213141516171819202122232425window.onload = (function() &#123; // 经测试, 750ms是一个较快较稳定的频率, 效率过快会弹警告. var timer = setTimeout(Delete, 750); var item = 0; function Delete() &#123; /* 这里需要停止定时器等待加载, 请求XHR进行加载剩余微博. * 这里是微博的一个限制, 当页面中不存在相应的DOM, 就进行页面刷新. */ if (item &gt; 15) &#123; item = 0; clearTimeout(timer); return timer = setTimeout(Delete, 15000); &#125; // 模拟点击 document.querySelector('a[action-type="fl_menu"]').click(); document.querySelector('a[action-type="feed_list_delete"]').click(); document.querySelector('a[action-type="ok"]').click(); ++item; console.log(`已成功删除了$&#123;item&#125;项`); timer = setTimeout(Delete, 750); &#125;&#125;)(); 总结这样我们想要的效果就实现了.省去了一条一条删的人力, 又能运用到自己所学的知识. 其实代码代码也很简单, 无非是用到了setTimeout重复去递归调用而已. 要注意的是querySelector, 和querySelector都是IE9+的API, 在这里没有去考虑对IE的兼容, 并且也没有必要.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript深入理解-裁剪图片效果(选取框)]]></title>
    <url>%2Fblog%2F2017%2F11%2F17%2FJavascript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在生活中我们时常能看到这种图片裁剪的效果, 那么他实际上底层的原理是怎么实现的呢? 让我们深入的解剖一下. 原理分析 首先我们先将视图一分为三, 理解为三个层级叠加在一起的仰视图. 最上面是可拖动的选择窗口 中间待剪辑的可视窗口 底层是一张opacity: .5的背景图片 基础结构我们这里主要讲JavaScript, HTML与css就简要的过一下. 首先HTML基本结构是两张相同的结构, 两张图片分别是调整过透明度的底图和一张被裁剪过了的中间层.mainBox包裹着选择的小方块square,相对定位于image在最上面一层.123456789101112131415161718&lt;!-- index.html --&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image1"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image2"&gt; &lt;div id="mainBox" class="main"&gt; &lt;div class="square left-up"&gt;&lt;/div&gt; &lt;div class="square up"&gt;&lt;/div&gt; &lt;div class="square right-up"&gt;&lt;/div&gt; &lt;div class="square right"&gt;&lt;/div&gt; &lt;div class="square right-down"&gt;&lt;/div&gt; &lt;div class="square down"&gt;&lt;/div&gt; &lt;div class="square left-down"&gt;&lt;/div&gt; &lt;div class="square left"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324/* main.css */body &#123;background: #333;&#125;#box &#123;position: absolute;top: 100px; left: 200px; width: 460px; height: 360px;&#125;#box img &#123;width: 460px;&#125;#box #image1 &#123;opacity: .5;position: absolute; top: 0;left: 0;&#125;#box #image2 &#123;position: absolute; top: 0;left: 0; clip: rect(0, 200px, 200px, 0) &#125;#box .main &#123;position: absolute;border: 1px solid #fff; width: 200px; height: 200px;box-sizing: border-box;&#125;#box .main .square &#123;position: absolute; width: 8px;height: 8px; background: #fff&#125;#box .main .left-up&#123;left: -4px;top: -4px;cursor: nw-resize;&#125;#box .main .up&#123;left: 50%;top: -4px;margin-left: -4px;cursor: n-resize&#125;#box .main .right-up&#123;right: -4px;top: -4px;cursor: ne-resize&#125;#box .main .right&#123;right: -4px;top: 50%;margin-top: -4px;cursor: e-resize&#125;#box .main .right-down&#123;right: -4px;bottom: -4px;cursor: se-resize&#125;#box .main .down&#123;left: 50%;bottom: -4px;margin-left: -4px;cursor: s-resize&#125;#box .main .left-down&#123;left: -4px;bottom: -4px;cursor: sw-resize&#125;#box .main .left&#123;top: 50%;left: -4px;margin-top: -4px;cursor: w-resize&#125;#box &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; JavaScript实现ESMAScript并没有提供可拖动的API, 那我们先来思考一下, 该如何实现拖动的功能~ 最上层有9个小方块(Square), 分别代表着不同方向的边界, 拖动这个边界, 无非需要实现这下面的底层步骤. 鼠标落下(MouseDown) =&gt; 鼠标拖动 =&gt; 松开鼠标(MouseUp). 先创建一个clipImage函数作为入口函数, 主要获取目标元素和生成DOM节点(后面讲), 绑定事件.先给小方块绑定一个鼠标落下事件(mousedown), 当触发事件(MouseEvent)时, 监听器调用onMousedown函数.onMousedown函数中, 接受四个参数e事件, box目标元素, ctrl小方块的方向, type属性, 主要是用来记录数据并暴露给全局变量进行通讯. 12345678910111213141516171819202122232425262728293031;(function() &#123; // Util工具函数 var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; // "全局变量", 记录状态 var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var right = util.$('#box .main .right'); // Add mouse down event up.addEventListener('mousedown', function(e) &#123; onMousedown(e, box, up, 'up'); &#125;); function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 将接受到的信息暴露出去. _MainBox = box; _MainCtrl = ctrl; _MainType = type; &#125;&#125;)(); 紧接着来计算拖动的距离, 在onMouseDown函数上将moving拖动标记设为1(true也行). 判断拖动的标记是否启动, 创建getPosition函数获取元素相对于页面左/上边的偏移量用于计算拖动的偏移量. 如下图. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//初始化var moving = 0;function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; _MainBox = box; _MainCtrl = ctrl; _MainType = type; // 移动计算偏移量并设置到box上 moving = 1;&#125;// 获取元素相对于文档的距离function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;;&#125;// 监听鼠标相对于页面的坐标document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var addWidth, addHeight; var width = _MainBox.offsetWidth; // 相对于屏幕左/上的距离 var boxX = getPosition(_MainBox).left; switch(_MainType) &#123; case "right": addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; break; &#125; &#125;&#125;; 紧接着我们会发现虽然实现了拖动的效果, 但是松开鼠标box宽度还是会随着鼠标变化. 这是因为还没有重置标记. 随即监听鼠标松开事件(MouseUp). 单边拖动就完成啦~12345// 鼠标松开document.onmouseup = function() &#123; // reset moving = 0;&#125;; 整理归纳我们将switch里的代码整理出来. 装进函数里去调用. 相续的将各个方向也加上, 原理也是同理. 值得注意的是将右面和下面要加上box的宽高才能计算出来. 剩下四个边角, 如左上什么的其实就是同时调用正方位的两个函数实现的实现起来. 然后拖动功能就大功告成啦~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215;(function() &#123; var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var up = util.$('#box .main .up'); var down = util.$('#box .main .down'); var right = util.$('#box .main .right'); var rightUp = util.$('#box .main .right-up'); var rightDown = util.$('#box .main .right-down'); var left = util.$('#box .main .left'); var leftUp = util.$('#box .main .left-up'); var leftDown = util.$('#box .main .left-down'); // Add mouse down event right.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, right, 'right'); &#125;); up.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, up, 'up'); &#125;); down.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, down, 'down'); &#125;); left.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, left, 'left'); &#125;); leftUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftUp, 'leftUp'); &#125;); leftDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftDown, 'leftDown'); &#125;); rightUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightUp, 'rightUp'); &#125;); rightDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightDown, 'rightDown'); &#125;); &#125; /** * [onMousedown description] Mouse down event * @param &#123;[type]&#125; e [Event] * @param &#123;[type]&#125; box [target vessel] * @param &#123;[type]&#125; ctrl [Square DOM node] * @param &#123;[type]&#125; type [Square direction] */ function onMousedown(e, box, ctrl, type) &#123; _MainBox = box; _MainCtrl = ctrl; _MainType = type; moving = 1; &#125; // 获取元素相对于左边的距离 function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;; &#125; // 鼠标移动 document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var height = _MainBox.offsetHeight; // 相对于屏幕左/上的距离 var boxY = getPosition(_MainBox).top; switch(_MainType) &#123; case "right": right(e); break; case "up": up(e); break; case "down": down(e); break; case "left": left(e); break; case "leftUp": leftUp(e); break; case "leftDown": leftDown(e); break; case "rightUp": rightUp(e); break; case "rightDown": rightDown(e); break; &#125; &#125; &#125;; // 鼠标松开 document.onmouseup = function() &#123; moving = 0; &#125;; function right(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; &#125; function up(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; &#125; function down(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; &#125; function left(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = boxX - e.clientX; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = boxY - e.clientY; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function rightUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125; function rightDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125;&#125;)(); &lt;– 努力填坑中~ –&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之三 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F11%2F06%2FBasic%20Algorithm%20Scripting%20-%203%2F</url>
    <content type="text"><![CDATA[今天让继续来学习数组方法的用法~ Sum All Numbers in a Range 题目描述 &emsp;&emsp;传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。最小的数字并非总在最前面。比如传递[1, 4]会返回10, 即1 + 2 + 3 + 4. 非数组方法1234567891011121314 function sumAll(arr) &#123; var max = Math.max.apply(null, arr); var min = Math.min.apply(null,arr); var num = max - min; var total = min; while(num) &#123; num--; total += ++min; &#125; return total;&#125;sumAll([1, 1]); &lt;– 未待续~ 有空再深挖 –&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过sourcetree实现远程仓库与本地仓库关联]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2F%E9%80%9A%E8%BF%87sourcetree%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率. &emsp;&emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联. 步骤&emsp;首先把本地仓库初始化. &emsp;再添加到sourcetree上 &emsp;进入github.com -&gt; your profile -&gt; repositories(仓库) -&gt; New &emsp;填写仓库信息, 复制仓库链接 &emsp;设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定 &emsp;然后就可以提交到github了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>sourcetree</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之二 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F19%2FBasic%20Algorithm%20Scripting%20-%202%2F</url>
    <content type="text"><![CDATA[数组方法的深入学习 Chunky Monkey(分割数组)猴子吃香蕉, 分割数组,把一个数组arr按照指定的数组大小size分割成若干个数组块。例如: &#8195;&#8195;hunk([1,2,3,4],2) =&gt; [[1,2],[3,4]]; &#8195;&#8195;chunk([1,2,3,4,5],2) =&gt; [[1,2],[3,4],[5]]; 思路 &#8195;这道题重点主要是每size个值分割一个数组,这里我们可以使用以下几种方法来解题. while + splice for + slice while + slice 第一种12345678910111213141516// while + splicefunction chunk(arr, size) &#123; // 定义一个新数组和用来临时存放分割的空数组. var a = [], t = [], i = 0, len = arr.length; while (i &lt; len)&#123; t = arr.splice(0, size); a.push(t); i += size; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); &#8195;在这里值得注意的是,len保存arr.length的快照是必须的..因为splice会修改原来原来的数组. 第二种12345678910111213141516171819// for + splicefunction chunk(arr, size) &#123; var a = [], t = [], len = arr.length; // 数组中的个数小于size或者size是小于等于0的也就没有必要分割了 if (len &lt;= size || size &lt;= 0) &#123; return arr; &#125; else &#123; // 它的重点主要是数组中的值的数量 for (var i = 0;i &lt; len; i += size) &#123; // 查询指定数 t = arr.slice(i, i + size); a.push(t); &#125; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); 第三种1234567891011121314// while + slicefunction chunk(arr, size) &#123; var a = [], t = [], i = 0, len = arr.length; while (i &lt; len) &#123; // 查询的值 t = arr.slice(i, i += size); a.push(t); &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); Falsy Bouncer(过滤数组假值)删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。 思路 &#8195;这道题比较有意思..一开始我走进了一个误区,想着单纯return x !== false &amp;&amp; ...这样简单的返回就可以了,后来发现在处理NaN时会很麻烦..isNaN()还会把英文字符串也给过滤掉,再加上多个&amp;&amp;使得代码会变得繁乱,可读性不高.&#8195;然后查阅了一番资料后,才注意到平时被忽略Boolean()的一些特性对于处理这种类型的问题简直不能太合适. 12345678910function bouncer(arr) &#123; // 请把你的代码写在这里 var a = arr.filter(function(x) &#123; return Boolean(x); &#125;); return a;&#125;bouncer([7, "ate", "", false, 9]); &#8195;摘至MDN.Boolean 的描述: 如果Boolean构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的Boolean对象的值为false. 其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为true的Boolean对象. Seek and Destroy (摧毁指定数组)实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 实现原理 &#8195;filter() 为数组中的每个元素调用一次 callback函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组.&#8195;filter()从头至尾遍历数组,若回调函数返回的是true(通过测试),就存入新数组中.若返回的是false,则过滤掉. 12345678910111213141516function destroyer(arr) &#123; // 先将第一个参数隔开,定义一个储存着待移除的空数组 var args = arguments[0], removeArgs = []; // 要被删除的参数装进'removeArgs'里 for (var i = 1; i &lt; arguments.length; i++) &#123; removeArgs.push(arguments[i]); &#125; // 遍历'args',若'removeArgs'中不存在'value',应该返回-1.反之返回false被过滤掉. return args.filter(function(value) &#123; return removeArgs.indexOf(value) === -1; &#125;);&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); Where do I belong (数组排序并找出元素索引)先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 &#8195;举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。 &#8195; 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。 思路 &#8195;这个没啥好说的了..将第二个参数push进数组中,再进行排序.排序后通过indexOf()来实现功能.不过需要注意的是sort默认是按照’Unicode’编码进行排序的. Caesars Cipher (凯撒密码)风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 思路 &#8195;本次练习用到String.charCodeAt()和String.fromCharCode(),首先来查询字符串的Unicode字符.&#8195;根据Unicode表我们得知: 小于65和大于90对应的就是数字和小写字符a-z 大于等于65和小于等于77对应的就是大写字符A-M (13位) 大于等于78和小于等于90对应的就是大写字符N-Z&#8195;ROT13的功能就是移位,如果序号小于78(A-M字母)，使用String.fromCharCode()转换成该序号加13的字符,反之减13. 1234567891011121314151617181920212223function rot13(str) &#123; // LBH QVQ VG! var newStr = []; for (var i = 0;i &lt; str.length;i ++) &#123; // 查询每个字符串的Unicode编号 var temp = str.charCodeAt(i); // 非大写字母,空格,数字等都不转换 if (temp &lt; 65 || temp &gt; 91) &#123; newStr.push(str.charAt(i)); continue; // 大于77(N-Z),就转换成该序号 - 13的字符串. &#125; else if (temp &gt; 77) &#123; newStr.push(String.fromCharCode(temp - 13)); // 小于78(A-M),就转换成该序号 + 13的字符串 &#125; else &#123; newStr.push(String.fromCharCode(temp + 13)); &#125; &#125; return newStr.join('');&#125;rot13("SERR PBQR PNZC"); // 你可以修改这一行来测试你的代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之一 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2FBasic%20Algorithm%20Scripting%20-%201%2F</url>
    <content type="text"><![CDATA[一些基础的算法练习 Palindromes(回文处理)Palindromes称之为回文。在中文文当中是指倒着念和顺着念都是相同的，前后对称. 正则表达式 replace() 1234567function palindrome(str) &#123; var string = str.replace(/[\W_]/g,'').toLowerCase(); var replaceStr = string.split('').reverse().join(''); return replaceStr === string;&#125;palindrome("eye"); // true 思路 &#8195;首先对字符串进行处理..去掉字符串多余的标点符号和空格，然后把字符串转化成小写.&#8195;split把字符串拆分为一个字符串组成的数组.reverse反转数组顺序,join拼接字符串. Title Case a Sentence(首个单词字母大写)句中单词首字母大写,确保字符串的每个单词首字母都大写，其余部分小写。 1234567function titleCase(str) &#123; return str.toLowerCase().replace(/( |^)[a-z]/g, function(L) &#123; return L.toUpperCase(); &#125;);&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot 思路 &#8195;首先把字符串转换为小写,再用正则匹配带空格或者就字母开头的首个字母replace替换成大写字母. Return Largest Numbers in Arrays(返回数组最大的数字)找出多个数组中的最大数,并返回一个新数组 12345678910111213function largestOfFour(arr) &#123; // 请把你的代码写在这里 var count = []; for (var i = 0; i &lt; arr.length; i ++) &#123; var a = arr[i].sort(function (a,b) &#123; return b-a; &#125;); count.push(a[0]); &#125; return count;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); // [5,27,39,1001] 思路 &#8195;新定义一个数组,遍历传进来的数组进行从大到小排序,将排序后最大的数push进新的数组count最后再返回. Confirm the Ending(检查字符串结尾)检查字符串结尾,判断一个字符串(str)是否以指定的字符串(target)结尾。如果是，返回true;如果不是，返回false。 123456789101112function confirmEnding(str, target) &#123; var l = str.length - target.length; if (str.substr(l) === target) &#123; return true; &#125; else &#123; return false; &#125;&#125;confirmEnding("Connor", "n"); // falseconfirmEnding("Bastian", "n"); // trueconfirmEnding("He has to give me a new name", "me"); // true 思路 &#8195;乍一看好像挺麻烦的样子,容我们深入一看却发现好像并没有想象中的麻烦..&#8195;这里用上了String.prototype.substr()而参数start是一个字符的索引,把字符串str.length - target.length就可以对比结尾字符串是否一样了. Repeat a string repeat a string(重复输出字符串)重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。 &#8195;对于这种题目可以使用两种方法解决: 递归 while循环 12345678910111213// 第一种使用递归function repeat(str, num) &#123; // 请把你的代码写在这里 if (num &lt; 0)&#123; return ""; &#125; else if (num === 1) &#123; return str; &#125; else &#123; return str + repeat(str, num - 1); &#125;&#125;repeat("abc", 3); // "abcabcabc" 1234567891011// 第二种使用whilefunction repeat(str, num) &#123; var s = ''; while(num &gt; 0)&#123; s += str; num --; &#125; return s;&#125;repeat("abc", 3); 思路 &#8195;递归一般放进if()判断语句中,是一种通过重复地调用函数本身,逐次减少num的值来实现效果.第二种使用了while语句,每调用一次就递减1,直至num &gt; 0. Truncate a string(截断字符串)截断字符串,如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。插入到字符串尾部的三个点号也会计入字符串的长度。如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213function truncate(str, num) &#123; // 首先判断num的值是不是大于字符串的长度,若是,那就没有必要省略了. if(num &gt;= str.length) &#123; return str; &#125; else if (num &lt;= 3) &#123; return str.slice(0,num) + "..."; &#125; else &#123; return str.slice(0,num-3) + "..."; &#125;&#125;truncate("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length); 思路 &#8195;slice截取字符串.substr(),indexOf()和lastIndexOf()办法同理.https://www.w3cplus.com/javascript/confirm-the-ending.html 大漠老师有一篇文章对此使用有着更详细的说明.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
