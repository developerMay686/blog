<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序开发笔记 - 小程序项目的结构设计]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Fminiprogrmas-build-frame%2F</url>
    <content type="text"><![CDATA[在工作中也做了好几个小程序项目了，正好抽空将小程序开发的一些知识重新整理一下~简要认识小程序开发其中小程序的构成是由.wxml、.wxss、.js、.json四种类型构成(下文将简称为四类文件)。其开发方式跟传统网页开发是十分类似的。.wxml模板文件对应为传统网页开发的.html文件，是一个页面(组件)的骨架。只不过它里面采用的语法跟传统的HTML语法有些差异, 比如标签的名称是微信自己在底层封装的组件。.wxss样式文件则对应CSS样式文件，具有大部分CSS的特性(比如css3的某些伪类特性就没有，但常见的css3属性倒是可以用)，除此之外还在此基础上做了新的扩展。js一直都是作为跟页面交互角色，在小程序开发中也不例外。在js中，可以使用微信提供的API。如常见的Page(构造器)和Component，还有微信给出的一些特定权限的API.json则是配置文件，一般是页面或者组件内那一级的配置文件。(这里有个小细节可以区分wxml和wxss区别，这两者都是以wx(微信)为开头，后面的小尾巴是区别是样式文件还是模板文件)。具体的更多细节可以去看官网文档。项目结构设计思路每个小程序项目的根目录会有一个project.config.json的项目配置文件，可以设置miniprogramRoot属性指定小程序源码的目录, 默认为根目录(/)。意思是说把源代码放在/src/下的目录也没有问题，笔者采用的是源码在根目录方式。首先，小程序规定：一个小程序主体部分由三个文件组成，同时必须放在项目的根目录。app.js 需要在里面调用App()函数，注册一个小程序。app.json 小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。app.wxss 全局样式，作用于每一个页面。但注意的是app.wxss写的全局样式不会影响组件内的样式。1234├── app.js├── app.json├── app.wxss└── project.config.json页面小程序是由许多页面组成的，因此我们需要一个目录来存放页面, 我们通常把这个文件夹命名为/pages/。app.json的pages是一个数组，数组的每一项是用来指定页面的路径，框架会根据路径自动去寻找相对位置的四类文件(小程序的代码构成)。数组第一项为小程序入口页面。每个页面为单独的一个目录, 页面的四类文件使用统一的名称。这里我们跟官方同步，四类文件跟随目录的名称走:1234567891011├── pages│ │── home│ │ ├── home.wxml│ │ ├── home.js│ │ ├── home.json│ │ └── home.wxss│ └── user│ ├── user.wxml│ └── user.js├── ...└── project.config.json除此之外，在开发小程序时，页面是会分主要页面和次要页面(子页)，子页通常是一些列表页详情页的东西。理论上只会有一个入口能跳的过去那种二级页面。如果这样的子页一多，然后全都放在了/pages/目录下，就会导致目录列表变得庞大，会比较难找…这时可以考虑换一种方式储存，在页面文件夹里再加一个文件夹, 名为subpage。把子页放在这个文件夹内，这样层级关系就清晰了，缺点就是不适合套太深。或者说一个产品也不应该把页面藏得太深让用户找不到…12345678910├── pages│ └── home│ ├── subpage│ │ └── detail│ │ ├── index.wxml│ │ └── ...│ ├── home.wxml│ └── ...├── ...└── project.config.json至于项目简单一些的话前者会好一点(子页命名参照master-description的格式)，页面太过复杂的话可能会比较推荐使用后者的方式。图片既然有了页面，那么页面必不可免会需要引用到图片。图片大致可以分为业务类和公共类。一些可以复用的图片我们可以放在同一个地方统一管理。而业务类则放在对应的页面目录下, 命名格式推荐为dir@description:12345678910111213141516├── iamges (公共图片)│ │── icon│ │ ├── icon@download.png│ │ └── icon@cancel.png| └── ...├── pages│ └── index│ ├── images│ | └── index@bg.png│ | └── index@video.png│ ├── index.wxml│ ├── index.js│ ├── index.json│ └── index.wxss├── ...└── project.config.json但值得注意的是，在js中使用import引入图片时不能通过根目录进行查找，而wxml则没有这种限制。12345&lt;!-- 绝对路径 --&gt;&lt;images src="/images/icon@download.png" /&gt;&lt;!-- 相对路径 --&gt;&lt;images src="./images/index@video.png" /&gt;1234// 会报错import iconDownload from '/images/icon@download.png'// 只能使用相对路径import iconDownload from '/../../icon@download.png'样式写完页面后自然需要给页面润色, 我们可以通过在页面的.wxss来写局部样式，这没问题。但在我们完成一个又一个页面后，这时你可能会发现有些页面的样式重复性太高了。因为一个成熟的设计师，在设计每一个产品时，大多会有一套设计风格或者称之为主题的东西。这些元素大量重复在各个页面中，我们重复写这些样式实际上代码是有点冗余的。这时有经验的开发者很自然就会想到将重复性的代码抽出来，所幸微信提供了@import语句可以导入外联样式表。而这些通用的样式可以放在/style/目录下12345├── style│ ├── button.wxss│ └── ...├── ...└── project.config.json直接在.wxss的顶层引入即可复用。123@improt '/style/button.wxss';/* other code */至于是为何不在app.json中设定全局样式而单独抽出来的原因也是前文所提及的问题————组件中默认情况下不受全局样式影响的，理论上组件也不该受到外部样式的”无意“的影响。但app.json中的样式只需要加载一次就全局可用，外部样式就不一定了(因为没有实际的调研过)，而且还需要额外的去做引入的那一步。具体用哪一种方式还是要看具体情况来自己斟酌啦~还有一些方法，比如使用scss、less之类的预处理之类的方案，也是可以，只不过超出了本文的讨论范围，不展开讲。组件组件对于熟悉模块化开发的同学自然不陌生，小程序基础库版本 1.6.3 就开始支持自定义组件了，至今为止也不用担心兼容性的问题了。从笔者角度来看看法，小程序的组件可以分为全局组件和局部组件。全局性是指那种封装了登录、弹框、动画组件等等之类的组件，局部的大多是减轻一个页面内的复杂度，通过模块”搭积木”的方式来组成一个页面。即使某个功能砍了也能对页面减少牵连。我们习惯于将全局性的东西放在源码的根目录上，因此会在根目录上创建/components文件夹，里面存放全局性的组件。其中全局性的组件有不少会有同等类型的组件，因为可以再进一步的分类，如动画类组件存放为一个文件夹内。再利用编辑器的文件名排序的特性，可以加上@提前组件集合。组件下的四类文件按照componment/index的方式命名与page区分。1234567891011121314151617181920├── componments (公共组件)│ │── anima│ │ ├── coin│ | | ├── index.js│ | | └── ...│ │ └── liquid│ | └── ...| └── ...├── pages│ └── home│ ├── componments│ | └── goods│ | ├── index.wxml│ | └── ...│ ├── home.wxml│ ├── home.js│ ├── home.json│ └── home.wxss├── ...└── project.config.jsonutils在原生小程序开发中，一般在源码的根目录下，都会有一个utils文件夹，专门来干杂七杂八的脏话累活。其中包含工具类函数、API的管理、配置信息等。12345678├── utils (工具集)│ │── api│ │ └── ...| ├── ... (其他工具类)| ├── config.js| └── local.config.js (本地配置，git忽略)├── ...└── project.config.json分包当小程序的资源大小超过了2M时，进行预览调试时就会报文件过大的错误，这时你可能就需要进行分包，将资源分开加载。小程序文档给出的目录结构是:123456789101112131415├── app.js├── app.json├── app.wxss├── packageA│ └── pages│ ├── cat│ └── dog├── packageB│ └── pages│ ├── apple│ └── banana├── pages│ ├── index│ └── user└── utils但经过我们在项目中尝试，我们发现通过编辑器的字符串排序后，会破坏目录结构的清晰度，所以推荐将分包放置到一个文件夹内。1234567├── subpackages (分包)│ │── news│ │ └── ...| └── store│ └── ...├── ...└── project.config.json结束最后的一个小程序项目主体结构大致是：123456789101112131415161718192021222324252627├── components (公共组件目录)│ ├── @anima (动画组件)│ └── ...├── images（公共图片）│ └── icon│ ├── icon@download.png│ └── icon@cancel.png├── pages（主包目录）│ └── home (app.json 设置的入口页)│ ├── home.wxml│ ├── home.js│ ├── home.json│ └── home.wxss├── style（公用样式目录）├── subpackages（分包目录）│ │── news| └── store├── utils（公共模块，工具类）│ ├── config.js（项目配置）│ └── local.config.js (本地配置，git忽略)├── .editorconfig├── .gitignore├── app.js├── app.json├── app.wxss├── project.config.json└── README.md以上是从原生小程序开发的角度来对项目结构的设计进行一个思路总结，没有过多的讲更深入的东西。下一期想整理一下关于API封装和管理，欢迎指导~]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>小程序开发</tag>
        <tag>小程序开发笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts 的食用方式]]></title>
    <url>%2Fblog%2F2018%2F06%2F28%2Fhow-to-use-echart%2F</url>
    <content type="text"><![CDATA[ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上。可以这么说，在国内，是个前端都知道这个玩意是干嘛用的，毕竟它还是出自于国人之手。虽说如此，但是Echarts涵盖的类型实在是太广了，它给我们提供了很多配置项，但呼之而来的问题是会有点让刚接触的人有点茫然… 哪些参数是必要的？哪个参数又跟什么地方的key值相对应，缺失后就无法正常的显示…因此就来专门讲一讲这配置项的坑以及如何通过组件的方式正确的”食用“。其实Echarts也有自己的使用教程，但本文的重心并不是从零开始讲解Echarts，至于更多使用细节可以看官方的文档。这里姑且先用折线图作示例。首先需要先引入ECharts, 我们选择好自己所需的版本后(tips: 如何选择版本，可以去看看这里)，然后在&lt;/body&gt;前插入脚本：&lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt; 。随后通过echarts提供的 API 初始化目标容器节点：12// 初始化 echartsvar myChart = echarts.init(document.getElementById('main'));接着我们需要填写配置项：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121var config = &#123; // 全局 tooltip , tooltip: &#123; show: true, // 坐标轴触发 trigger: 'axis' &#125;, // 图例组件，也就是提供显示或隐藏某一条数据信息开关 legend: &#123; // 组件在底部显示 bottom: '0px', // 图例每项之间的间隔 itemGap: 46, // 图例的数据数组, 省略则自动从 series.name 中获取 // 但我们需要定制样式，因此我们添上去上去 data: [ &#123; name: '曝光量', icon: 'circle' &#125;, &#123; name: '点击量', icon: 'circle' &#125; ], // 文字样式 textStyle: &#123; color: '#276dcc', fontSize: 14 &#125; &#125;, // 重设全局调色盘的颜色，比如当前涉嫌图示例中有两条数据 // 那这两条数据就会取得我们当前设置颜色作为展示 color: ['#42a66a', '#276dcc'], // 网格布局 grid: &#123; // 下面三个是离容器的位置 left: '3%', right: '4%', bottom: '40px', // 坐标刻度，默认是false containLabel: true &#125;, // X轴配置 xAxis: &#123; type: 'category', boundaryGap: false, // 坐标轴配置 axisLine: &#123; lineStyle: &#123; color: '#d6dfea' &#125; &#125;, // 坐标轴上的 label 样式 axisLabel: &#123; margin: 18, fontSize: 14, color: '#56749d' &#125;, // 类目数据，只有在 type: 'category' 中有效。 // 一般情况下我们并不会手动写死数据进去，而是通过 Ajax 请求数据来展示 data: [] &#125;, // Y轴配置 yAxis: [ &#123; // 数值轴 type: 'value', name: '点击量', // 左侧显示 position: 'left', // 下面的样式不再多说 axisLine: &#123; lineStyle: &#123; color: '#d6dfea' &#125; &#125;, axisLabel: &#123; margin: 18, fontSize: 14, color: '#56749d' &#125; &#125;, &#123; type: 'value', name: '曝光量', position: 'right', axisLine: &#123; lineStyle: &#123; color: '#d6dfea' &#125; &#125;, axisLabel: &#123; margin: 18, fontSize: 14, color: '#56749d' &#125; &#125; ], // 系列列表, 这个是数据的关键所在 series: [ // 如果 legend.data 设置了数据的话，那么 series 的数目需要和 legend.data 的数目一致。 // 否则图表会不工作 !! &#123; name: '点击量', // 图表的类型，在这个示例中我们使用是折线图 type: 'line', yAxisIndex: 1, // 系列中的数据内容数组 // 同样的，我们主要展示的数据来自于服务端 data: [] &#125;, &#123; name: '曝光量', type: 'line', // 折线图一维数据可能是这种形式的数组 // [1, 2, 3, 1, 4] data: [] &#125; ]&#125;;随后可以通过 Ajax 获取数据，再使用setOption来设置选项：1234567891011$.ajax(&#123; url: url, method: 'GET', data: data&#125;).done(function(res) &#123; config.series[0].data = res.data.click; config.series[1].data = res.data.exposure; config.xAxis.data = res.data.xAxis; myChart.setOption(option);&#125;);如此，这样我们定义的 echarts 就完成啦~Vue 组件在vue中封装组件也不难，大致如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;template&gt; &lt;div :class="['data-echart', echartClass ]"&gt; &lt;div class="data-echart__header"&gt; &lt;slot name="title"&gt; &lt;div class="header__title"&gt; &lt;span v-if="title" class="title-name"&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;el-popover v-if="tooltip" ref="tooltip" placement='bottom' trigger='hover'&gt; &lt;div v-html="tooltip"&gt;&lt;/div&gt; &lt;/el-popover&gt; &lt;i v-if="tooltip" class="el-icon-question" v-popover:tooltip&gt;&lt;/i&gt; &lt;/div&gt; &lt;/slot&gt; &lt;/div&gt; &lt;div :id="echartId" class="echart__main"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from 'echarts';export default &#123; name: 'echart', props: &#123; title: &#123; type: String, default: '' &#125;, tooltip: &#123; type: String, default: '' &#125;, echartClass: &#123; type: String, default: '' &#125;, option: &#123; type: Object, default() &#123; return &#123;&#125;; &#125; &#125;, loading: &#123; type: Boolean, default: false &#125; &#125;, computed: &#123; domEchartId() &#123; return (document || window.document).getElementById(this.echartId); &#125; &#125;, data() &#123; return &#123; // 随机生成一个ID echartId: this.randomChar(20), myChart: null &#125;; &#125;, watch: &#123; option: &#123; deep: true, handler(newVal) &#123; this.update(newVal); &#125; &#125;, loading(newVal) &#123; this.toggleLoading(newVal); &#125; &#125;, mounted() &#123; this.init(); &#125;, methods: &#123; // 调起loading toggleLoading(flag) &#123; flag ? this.myChart.showLoading() : this.myChart.hideLoading(); &#125;, init() &#123; this.myChart = echarts.init(this.domEchartId); this.myChart.on('click', (params) =&gt; &#123; this.$emit('clickEchart', params); &#125;); // 绘制图表 this.myChart.setOption(this.option); // Object.keys(this.data).length !== 0 &amp;&amp; this.myChart.setOption(this.data); &#125;, update(data) &#123; this.myChart.setOption(data); &#125;, /** * 生成随机字符串 * @param &#123; Number &#125; len - 指定随机字符串的长度 */ randomChar(len) &#123; const x = '0123456789qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'; let tmp = ''; for (let i = 0; i &lt; len; i++) &#123; tmp += x.charAt(Math.ceil(Math.random() * 100000000) % x.length); &#125; return tmp; &#125;, &#125;&#125;;&lt;/script&gt;&lt;style lang='scss' scoped&gt;@import '~Scss/theme';.data-echart &#123; display: flex; flex-direction: column; width: 100%; height: 100%; overflow: hidden;&#125;.data-echart__header &#123; width: 100%;&#125;.header__title &#123; .title-name &#123; font-size: 16px; color: $f-color--title; font-weight: 600; &#125; .el-icon-question &#123; font-size: 18px; color: $f-color--tip; &#125;&#125;.echart__main &#123; flex: 1; width: 100%; height: 100%;&#125;&lt;/style&gt;我们需要将组件放入一个设有高度的容器上：123&lt;div class="container" style="height: 600px;"&gt; &lt;echart :option="charts.option"&gt;&lt;/echart&gt;&lt;/div&gt;调用的方式也面类似。首先声明一个基础的配置作为模板，在通过 ajax 拿到数据。通过动态数据传入组件内，组件watch到数据变化后立即重新渲染：12345678910111213141516171819202122232425// 某处集中封装的 ajax 请求import API from 'Common/apis'// 同上配置const config = &#123;...&#125;export default &#123; data() &#123; return &#123; charts: &#123; title: 'My charts' option： config &#125; &#125; &#125;， created() &#123; API.getChartData() .then(res =&gt; &#123; let data = res.data this.charts.option.xAxis.data = data.xAxis; this.charts.option.series[0].data = data.click; this.charts.option.series[1].data = data.exposure; &#125;) &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Echarts</tag>
        <tag>图表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚点定位导航]]></title>
    <url>%2Fblog%2F2018%2F06%2F09%2Fjavascript-position-navigation%2F</url>
    <content type="text"><![CDATA[一般我们翻阅百科的时候，如果文章过长的话，就不太方便找到我们想要的资源。此时有一个定位导航的话，那可真是帮大忙了~今天，就来聊聊这种常见的锚点定位导航的原理以及是如何实现的。定位原理首先我们来了解一下，什么锚点？在海上，水手们会将锚丢入海中，或者靠岸时将锚抛上岸，其固定目的是让船固定位置。而锚点(anchor)也是一样，只不过场景不同罢了。页面锚点定位可以通过name或者id属性来定位。name已经被HTML5废弃了，就不再多提。在页面上，每个id都会自动创建一个锚点，同时还会生成一个hash，表示所处的文档位置。浏览器可以通过hash来确定位置，使用的方式一般如下：1234&lt;a href="#title"&gt;跳到title&lt;/a&gt;&lt;!-- 地址栏后会加上一段 # 开头的 hash --&gt;&lt;!-- https://anran758.github.io/blog/#title --&gt;这个hash值我们可以通过浏览器的APIlocation.hash取到。但值得注意的是，跳转hash的话是不会像服务端发送请求的(除了第一次请求页面)。深入分析但我们光知道跳转的原理可不够，只要你尝试了上面的跳转方法后，你会发现浏览器跳转方式是很唐突的。它会直愣愣的跳到指定位置(或者没有找到指定位置会，跳到页面最上面)，这在用户看来是十分生硬的，在体验上这个交互并不太友好。这时产品就会要求我们对此处进行优化~ 不过知道了上面的原理后，我们也可以直接使用js的方式来代替这种原生的默认跳转：首先我们页面的结构大致如下:12345678910111213141516171819&lt;nav class="nav"&gt; &lt;a class="actived" href="#title1"&gt;第一组图片&lt;/a&gt; &lt;a href="#title2"&gt;第二组图片&lt;/a&gt; &lt;a href="#title3"&gt;第三组图片&lt;/a&gt;&lt;/nav&gt;&lt;main id="content"&gt; &lt;article id="title1" class="item"&gt; &lt;!-- 许多内容 --&gt; &lt;/article&gt; &lt;article id="title2" class="item"&gt; &lt;!-- 许多内容 --&gt; &lt;/article&gt; &lt;article id="title3" class="item"&gt; &lt;!-- 许多内容 --&gt; &lt;/article&gt;&lt;/main&gt;页面布局固定了后，元素离页面顶部的距离可以通过offsetTop来获取到。同时我们可以操作滚动容器(html)的scrollTop来修改滚动位置。嘿，这样一上(目标距离顶部的高度)一下(滚动条)，两个API双剑合璧后，我们就可以点击模拟滚动啦..1234567891011121314151617// jquery 环境var $menu = $('.nav');var $menuList = $menu.find('a');// 给超链接绑定点击事件$menuList.each(function() &#123; var $this = $(this); $this.click(function(e) &#123; var id = $this.attr('href').replace(/#/g, ''); // 获取目标距离顶部的高度 var top = $('#' + id).offset().top - 60; // 给滚动容器加动画的效果，滚动到目标位置 $('html').animate(&#123; scrollTop: top &#125;, 1000); &#125;);&#125;);蹡蹡！在页面中调试会发现，点击后页面会平滑的滚动到指定的锚点~ 除此之外，我们还得再添加一个功能：在页面滚动的时候，能让用户知道自己所在的位置~1234567891011121314151617181920212223242526272829var contentList = $('#content').find('.item');$(window).scroll(function(e) &#123; var top = $(document).scrollTop(); // 获取目前滚动条所处的区间 var currentID = ''; contentList.each(function() &#123; var $this = $(this); // 获取当前距离顶部的数值 var itemTop = $this.offset().top; // 如果当前滚动距离已经进入了 item 的区间 if (top &gt; itemTop - 250) &#123; currentID = '#' + $this.attr('id'); &#125; else &#123; return false; &#125; &#125;); var currentLink = $menu.find('.actived'); // 移除其他的类名 if (currentID &amp;&amp; currentLink.attr('href') !== currentID) &#123; currentLink.removeClass('actived'); $menu.find("[href='" + currentID + "']").addClass('actived'); &#125;&#125;);这样就锚点定位导航的功能就大功告成啦~ 最后将测试代码放入了codepen上了，感兴趣的同学可以去看看。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>业务组件</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将项目资源上传至七牛CDN]]></title>
    <url>%2Fblog%2F2018%2F05%2F24%2Fnode-%E5%B0%86%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90%E4%B8%8A%E4%BC%A0%E8%87%B3%E4%B8%83%E7%89%9BCDN%2F</url>
    <content type="text"><![CDATA[在实际工作中，常常会遇到需要将项目中的资源传入 CDN 上，以提升用户的加载速度。七牛就是国内一个挺有名的服务商，今天就来分享一下，如何将项目资源上传至七牛吧~一般情况下，我们开发中会有一个脚手架，里面搭建了我们的开发环境，我们通过npm安装七牛的 API 客户端，npm install -D qn。随后我们在 build 目录下(这里我们习惯将脚手架相关的代码放在此处..)创建一个名为upload.js的文件。一般  我们的代码打包后会放在一个dist目录下，我们通过 Node.js 查找我们想要  上传的所有文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');const fs = require('fs');const rootPath = path.resolve(__dirname, '../');// 定义指定目录，以及过滤掉多余的系统文件const distPath = 'dist';const ignore = ['.DS_Store'];/** * 获取全部文件 * @param &#123; String &#125; dir - 指定目录 * @return &#123; Array &#125; 返回待上传的文件数组 */function getAllFiles(dir) &#123; try &#123; let paths = fs.readdirSync(dir); let files = []; paths.forEach(function(file) &#123; // 获取文件相关信息 let dirname = path.resolve(dir, './', file); let stat = fs.lstatSync(dirname); // 过滤文件 let filter = ignore.filter(function(v) &#123; return v === file; &#125;); if (filter.length) return true; if (!stat.isDirectory()) &#123; // 如果是文件的话，就转为将绝对路径转为相对路径 // users/xxx/project/dist/static/js/vendors.js // =&gt; ./dist/static/js/vendors.js' files.push(dirname.replace(rootPath, '.')); &#125; else &#123; // 文件夹，递归继续查找文件 files = files.concat(getAllFiles(dirname)); &#125; &#125;); return files; &#125; catch (e) &#123; console.log(e + '\n'); &#125;&#125;ok~ 有了文件列表后，接着我们就要考虑上传的问题啦。不过在这之前，我们还需要再做一些准备…我们要先去七牛开发者平台获取签名信息，用来作为上传的凭证。123456789101112131415161718// config/base.jsmodule.exports = &#123; // other configuration... cdn: &#123; // https://portal.qiniu.com/user/key accessKey: 'your access key', secretKey: 'your secret key', // https://portal.qiniu.com/bucket/koudaifm/index bucket: 'project', // 就是储存空间的域名，一般来说也是你的项目名 origin: 'http://fs.project.com', // 外链域名，这个可以自己设置，一开始七牛会分配给你一个随机的域名 // https://developer.qiniu.com/kodo/manual/1671/region-endpoint // 这个是跟项目所在的储存区域相对应的，比如华南地区的就是这个示例的uploadURL uploadURL: 'http://up-z2.qiniu.com', // timeout: 3600000 // 超时，唔..这里姑且不需要 &#125;&#125;;考虑到上传资源时，可能会碰到资源已存在的问题，这时就需要再额外创建一个函数来处理这个问题~ 然后我们开始封装上传函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const colors = require('colors');// 将配置项放到单独文件上，统一改起来也方便..const config = require('../config/base');const pluginName = require('../package.json').name;let client = qn.create(config.cdn);let done = 0;// 删除七牛资源function qnDelete(key, cb) &#123; client.delete(key, function(err) &#123; if (!err) &#123; console.log('Delete '.yellow + 'success'.green + ': ', key); cb &amp;&amp; cb(); &#125; else &#123; console.log( 'Delete '.yellow + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; &#125;);&#125;// 上传资源function qnUpload(dir) &#123; // 上传到七牛对应的(bucket)下 var key = pluginName + dir.replace('./', '/'); client.uploadFile(dir, &#123; key: key &#125;, function(err, result) &#123; if (!err) &#123; console.log('Upload ' + 'success'.green + ': ', result.key); &#125; else &#123; // 如果目标资源已存在，七牛会返回一个 614 的错误码 // https://developer.qiniu.com/fusion/kb/1352/the-http-request-return-a-status-code if (err.code === 614) &#123; // 删除文件并重试，以最新 qnDelete(key, function() &#123; qnUpload(dir); &#125;); return true; &#125; // 报错信息 console.log( 'Upload ' + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; if (++done === filesLength) &#123; console.log('\n'); &#125; &#125;);&#125;console.log(`Upload $&#123;distPath&#125;/** to qiniu CDN.\n`);// 对每个文件调用 qnUploadmyFiles.forEach(qnUpload);锵锵！一个可复用的上传组件就这么出现啦~ 最后上完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const path = require('path');const fs = require('fs');const qn = require('qn');const colors = require('colors');const config = require('../config/base');const pluginName = require('../package.json').name;const rootPath = path.resolve(__dirname, '../');const distPath = 'dist';const ignore = ['.DS_Store'];/** * 获取全部文件 * @param &#123; String &#125; dir - 指定目录 * @return &#123; Array &#125; 返回待上传的文件数组 */function getAllFiles(dir) &#123; try &#123; let paths = fs.readdirSync(dir); let files = []; paths.forEach(function(file) &#123; // 获取文件信息 let dirname = path.resolve(dir, './', file); let stat = fs.lstatSync(dirname); let filter = ignore.filter(function(v) &#123; return v === file; &#125;); if (filter.length) return true; if (!stat.isDirectory()) &#123; // 如果是文件的话，就转为将绝对路径转为相对路径 // users/xxx/project/dist/static/js/vendors.js // =&gt; ./dist/static/js/vendors.js' files.push(dirname.replace(rootPath, '.')); &#125; else &#123; // 递归重复查找文件 files = files.concat(getAllFiles(dirname)); &#125; &#125;); return files; &#125; catch (e) &#123; console.log(e + '\n'); &#125;&#125;const myFiles = getAllFiles(distPath);const filesLength = myFiles.length;// 七牛上传配置// https://www.npmjs.com/package/qn#uploadlet client = qn.create(config.cdn);let done = 0;// 删除七牛资源function qnDelete(key, cb) &#123; client.delete(key, function(err) &#123; if (!err) &#123; console.log('Delete '.yellow + 'success'.green + ': ', key); cb &amp;&amp; cb(); &#125; else &#123; console.log( 'Delete '.yellow + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; &#125;);&#125;// 上传资源function qnUpload(dir) &#123; // 上传到七牛对应的(bucket)下 var key = pluginName + dir.replace('./', '/'); client.uploadFile(dir, &#123; key: key &#125;, function(err, result) &#123; if (!err) &#123; console.log('Upload ' + 'success'.green + ': ', result.key); &#125; else &#123; // 如果目标资源已存在，七牛会返回一个 614 的错误码 // https://developer.qiniu.com/fusion/kb/1352/the-http-request-return-a-status-code if (err.code === 614) &#123; // 删除文件并重试 qnDelete(key, function() &#123; qnUpload(dir); &#125;); return true; &#125; // 报错信息 console.log( 'Upload ' + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; if (++done === filesLength) &#123; console.log('\n'); &#125; &#125;);&#125;console.log(`Upload $&#123;distPath&#125;/** to qiniu CDN.\n`);myFiles.forEach(qnUpload);]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Javascirpt</tag>
        <tag>七牛</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的几种压缩图片的思路]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2Fcanvas-compress-prictures%2F</url>
    <content type="text"><![CDATA[在做H5开发时，难免会遇到需要上传图片的需求。那么一般都是如何去处理压缩的需求呢？这里简要的概述一下原理，做个笔记加深印象~目前主流对图片进行处理都是使用canvas技术~当我们碰到需要压缩图片的场景时，第一种我们就可以尝试控制图片的尺寸。因为图片的尺寸越大，里面包含的信息就越多，自然体积也随着增加了起来。我们可以做一个宽高的限制，超出就对其进行尺寸的缩放。那么限制最大值是多少呢？这个应该根据产品或者需求来调整。当然，裁剪图片也是一种思路，那么该如何去裁剪，让用户选择还是我们自定义？这也是需要考虑的一点。判断缩放的方法主要使用drawImage将图片导入canvas，如果图片超过了指定的宽高，就进行缩放图片。关于这一点，我觉得张鑫旭老师的这篇文章讲的已经足够简洁的了，感兴趣的同学可以看这边~第二种就是使用canvas提供的另一个接口：canvas.toDataURL(type, encoderOptions)。这是浏览器原生提供可以压缩图片的方法，该方法返回一个包含图片展示的data URI(也就是我们常说的base64)。它接受两个可选参数，我们可以使用type参数指定其类型，默认为PNG格式。encoderOptions则是压缩图片质量参数，区间在 0~1 之间。值得注意的是，压缩图片质量这个参数只对image/jpeg或image/webp有效。所幸的是，其他格式用不了压缩图片的参数，但浏览器还是会对图片进行压缩处理，剔除对 web 展示没啥用的元数据(虽然可能会涉及到版权纠纷的问题)。123var canvas = document.getElementById("canvas");// 中间处理的过程省略 ...var fullQuality = canvas.toDataURL("image/jpeg", 0.8);但单单是转为 base64 是不能满足我们一些需求的，这时我们可能会想要让它再转为对服务端友好的blob类型。这时我们就需要用到window.atob(), 将已经编译成 base64 的字符串解码为二进制。12345678910111213141516171819202122232425var type = fullQuality.split(',')[0].split(':')[1].split(';')[0];// 解码为二进制var binStr = atob(fullQuality.split(',')[1]);var length = binStr.length;// 创建一个缓存区，容器大小可以容纳 binStr.// 这个缓存区我们是不能直接操作的。var buffer = new ArrayBuffer(binStr);// 建立`Uint8Array`类型数组// 这样我们就可以通过对象的方法或者数组索引读写里面的数据啦//// var buff = new ArrayBuffer(4); =&gt; ArrayBuffer(4) &#123;&#125;// var arr = new Uint8Array(buff); =&gt; Uint8Array(4) [0, 0, 0, 0]// arr[2] = 8;// console.log(buff) =&gt; 缓存区和 Uint8Array 同时被修改了var arr = new Uint8Array(buffer);for (var i = 0; i &lt; length; i++) &#123; // 逐个查询 binStr 里的二进制 Unicode 编码，并存入类型数组中 arr[i] = binStr.charCodeAt(i);&#125;var blob = new Blob([buffer],&#123; type: type &#125;如果是想转为File类型的话，和上面的方法实现的也一致..123// https://developer.mozilla.org/en-US/docs/Web/API/File/File// 第一个参数传入 ArrayBuffer 也行，blob 也行..var file = new File([buff], "img.jpg", &#123; type: type &#125;);哇，转个类型都看起来好像挺麻烦的样子呢…那么有没有内置的方法呀？答案是有，canvas 里有个toBlob(callback, type, encoderOptions)的方法, 它接受三个参数，一个是将canvas转为blob后接受的回调函数、一个是指定的图片格式、另一个是图片质量，区间也在 0~1 之间。看起来这个方法似乎比上面那个更好用呢..然而残念的是，这货还受着兼容性影响，不在乎的兼容性的话倒是可以使用… 不然就需要上一种polyfill 的方式来实现~123456789101112canvas.toBlob(function (blob) &#123; // 接收转换后的 blob 类型 // 此时可以在函数里发起请求 $.ajax(&#123; url: baseURL + '/uploader/', data: &#123; act_id: actID, pic_1: blob &#125;, type: 'POST', success: function (data) &#123; // success &#125; &#125;);&#125;, 'image/png');]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈CSS3 Matrix 的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2F%E8%B0%88%E8%B0%88CSS3-Matrix-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CSS3的transform里有一个方法叫做Matrix，该需要六个参数，可以使用数学函数让元素进行旋转、缩放、移动以及倾斜元素。光是看这名词好像有点吓人，仿佛又回想起当初被数学支配的恐惧。的确，相比那些translate(25deg)之类有着明确语义跟容易调用方法外，Matrix使用起来确实有些复杂~Matrix的参数分别有a, b, c, d, e, f六个参数，我们可以分别对应：1transform: matrix(X轴的缩放， X轴拉升, Y轴的拉伸, Y轴的缩放, X轴的位移, Y轴的位移);这样看上去好像好多了，我们常使用的几个方法也是可以通过Matrix来实现：元素默认情况下的表现可以用Matrix来表示为：matrix(1, 0, 0, 1, 0, 0);通过上面的例子，我们很容易推测出缩放的公式为：translate(sx, sy)等于matrix(sx, 0, 0, sy, 0, 0);位移就更简单啦： translate(tx, ty)等于matrix(1, 0, 0, 1, tx, ty);拉升则是：skew(degx, degy)等于matrix(1, tan(degx), tan(degy), 1, 0, 0)旋转没有提供相应的参数，他需要套用数学的公式，毕竟这个方法名就是矩阵嘛：rotate(deg)等于matrix(cos(deg),sin(deg), -sin(deg), cos(deg), 0, 0)那问题来了，为啥有简单易用的方法不用，我们非要搞这么麻烦的东西呢？这是因为很多时候我们需要高度精确定制动画时，那些简单的方法以及不能满足我们的需求啦~]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>transform</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-flow 练习笔记]]></title>
    <url>%2Fblog%2F2018%2F04%2F23%2Fgit-flow%2F</url>
    <content type="text"><![CDATA[在我们团队开发中，必不可免会使用到版本控制。同时还需要一个统一的工作流程，创建新的功能、打补丁、正式版发布打tag等等，git-flow工作流就这些繁琐的东西简化了，它封装了git命令，将命令组合了起来，我们只需要几行代码就能解决这些繁琐的工作。正好工作也有好一段时间了，想将这方面的知识梳理一下。git flow 有好几个版本，这里笔者演示使用的是git-flow-avh的版本。初始化首先我们先开始初始化仓库的工作流，我们在命令行使用git flow init。12345678910$ git flow initflags:ERROR short flag required for (showcommands) on this platformflags:ERROR short flag required for (local) on this platformflags:ERROR short flag required for (global) on this platformflags:ERROR short flag required for (system) on this platformflags:ERROR short flag required for (file) on this platform/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedNo branches exist yet. Base branches must be created now.命令行出现了警告，告诉我们还没有基础的分支。这是因为测试是全新的仓库作测试，这个我们姑且先不管它，接着引导会向我们确定需要初始化分支的名字，我们都采用默认即可。直到询问Version tag prefix时，我们采用v作版本前缀，这其实也是很常见的一种习惯。1234567891011121314151617181920212223242526Branch name for production releases: [master]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedBranch name for "next release" development: [develop]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedHow to name your supporting branch prefixes?Feature branches? [feature/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedBugfix branches? [bugfix/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedRelease branches? [release/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedHotfix branches? [hotfix/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedSupport branches? [support/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedVersion tag prefix? [] v/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedHooks and filters directory? [/Users/anran/MyProject/git-flow-test/.git/hooks]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected随后我们使用git branch查看一下当前分支，我们会发现，git flow 创建了两条分支————主分支（master）和开发分支（develop），并自动切换到了 develop 上。一般来说，我们常将 master 作为部署的分支，这个版本的产品防止稳定的代码和功能，作为产品的一个正式版部署。正常情况下，我们不能直接在 master 分支上进行工作，而该是在 develop 开发环境下进行工作。除此之外，develop 还是一个基础的分支，当我们开发新的功能时，我们会另开一个分支，在新的分支上进行功能开发，等功能开发完毕后再合并进来 develop 分支。嘿，我们先创建一个README.md，在里面添加一些文字进去，再提交上去。1234567891011121314151617➜ git-flow-test git:(develop) git branch* develop master➜ git-flow-test git:(develop) touch README.md➜ git-flow-test git:(develop) ✗ vim README.md➜ git-flow-test git:(develop) ✗ git add .➜ git-flow-test git:(develop) ✗ git statusOn branch developChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: README.md➜ git-flow-test git:(develop) ✗ git commit -m "First commit"[develop 61ec91a] First commit 1 file changed, 1 insertion(+) create mode 100644 README.md如果这时直接用push的话，git会提示你没有设定上游分支————别忘了现在我们在使用全新的测试仓库。bash12345678910111213141516➜ git-flow-test git:(develop) git pushfatal: The current branch develop has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream origin develop➜ git-flow-test git:(develop) git push --set-upstream origin developCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (5/5), 385 bytes | 385.00 KiB/s, done.Total 5 (delta 0), reused 0 (delta 0)To github.com:anran758/git-flow-test.git * [new branch] develop -&gt; developBranch &apos;develop&apos; set up to track remote branch &apos;develop&apos; from &apos;origin&apos;.➜ git-flow-test git:(develop)功能分支umm..现在假设我们现在碰到了一个需求，需要加一些功能，这时我们就需要开一个功能分支了，这时工作中常用的分支。那为啥都切到开发环境了还要单独开一个分支呢？这是避免产品调皮的说，“诶嘿，兄弟，刚才那个功能只是我突发奇想，咱们不要了吧”。嗯，这时宰一个产品祭天事小，污染了全局的开发环境才事大，回退都不好回退（可能团队中其他人也在写一些功能上去或者修复了一些bug上去，回退意味着其他人也会收到影响）。而单独开一个分支则没那么多破事需要烦恼，再不济就删除这个分支即可，不需要耗费额外的成本。我们先看一下给flow都有啥，使用命令git flow -h会提示如下：12345678910111213141516➜ git-flow-test git:(develop) git flow -hflags:ERROR short flag required for (showcommands) on this platformusage: git flow &lt;subcommand&gt;Available subcommands are: init Initialize a new git repo with support for the branching model. feature Manage your feature branches. bugfix Manage your bugfix branches. release Manage your release branches. hotfix Manage your hotfix branches. support Manage your support branches. version Shows version information. config Manage your git-flow configuration. log Show log deviating from base branch.Try 'git flow &lt;subcommand&gt; help' for details.因为我们现在是想做一个新功能，feature 就是我们想要的命令。我们进一步查看详情：12345678910111213141516➜ git-flow-test git:(develop) git flow feature helpflags:ERROR short flag required for (showcommands) on this platformusage: git flow feature [list] or: git flow feature start or: git flow feature finish or: git flow feature publish or: git flow feature track or: git flow feature diff or: git flow feature rebase or: git flow feature checkout or: git flow feature pull or: git flow feature delete Manage your feature branches. For more specific help type the command followed by --help我们使用git flow feature start再加上一个名字，这个名字代表着这个功能分支是做什么的。12345678910111213➜ git-flow-test git:(develop) git flow feature start homeflags:ERROR short flag required for (showcommands) on this platform/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedSwitched to a new branch 'feature/home'Summary of actions:- A new branch 'feature/home' was created, based on 'develop'- You are now on branch 'feature/home'Now, start committing on your feature. When done, use: git flow feature finish home这时我们创建了一个名为feature/home的新分支，并且切换到了新分支上。feature的前缀就是前面使用默认的功能分支的名字。这个 feature 可以当成一个放置功能的文件夹。随后我创建一个 HTML 文件，并在上面写了少许代码假装（雾）完成了这个新功能的开发。使用git flow feature finish &lt;name&gt;完成本回合的开发。12345678910➜ git-flow-test git:(feature/home) ✗ git flow finish homeSwitched to branch 'develop'Your branch is up to date with 'origin/develop'.Already up to date.Deleted branch feature/home (was 61ec91a).Summary of actions:- The feature branch 'feature/home' was merged into 'develop'- Feature branch 'feature/home' has been locally deleted- You are now on branch 'develop'git flow 将分支合并后，会将feature/home分支删除。这时分支会切换到develop。注意，这时候的代码还没有提交到远端！12345678910111213➜ git-flow-test git:(develop) ✗ git add .➜ git-flow-test git:(develop) ✗ git commit -m "添加新的功能"[develop 9ca31f9] 添加新的功能 1 file changed, 12 insertions(+) create mode 100644 index.html➜ git-flow-test git:(develop) ✗ git pushCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 482 bytes | 482.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:anran758/git-flow-test.git 61ec91a..9ca31f9 develop -&gt; develop正式发布好啦，当我们开发的差不多了，bug都修完并且都测试过了，这时就可以考虑部署一版了。这时我们可以使用git flow release start &lt;version number&gt;进入发布的状态。12345678910111213➜ git-flow-test git:(develop) ✗ git flow release start 1.0.0Switched to a new branch 'release/1.0.0'Summary of actions:- A new branch 'release/1.0.0' was created, based on 'develop'- You are now on branch 'release/1.0.0'Follow-up actions:- Bump the version number now!- Start committing last-minute fixes in preparing your release- When done, run: git flow release finish '1.0.0'git flow 基于develop创建了一个新的分支，同时切换到新分支release/1.0.0上了。这时我们可以进入最后的准备啦~比如我们一般发布都需要写版本信息，说明这版本都做了什么？新加了哪些功能？修了哪些bug等信息。1234567891011121314151617181920212223➜ git-flow-test git:(release/1.0.0) ✗ touch changelog.md➜ git-flow-test git:(release/1.0.0) ✗ vim changelog.md----# item name## v1.0.0 2018/04/23* 基础功能完善* 完成巴拉巴拉功能~~~"changelog.md" 6L, 83C----➜ git-flow-test git:(release/1.0.0) ✗ git add changelog.md➜ git-flow-test git:(release/1.0.0) ✗ git commit -m "增加版本号信息"[release/1.0.0 f8464d6] 修改版本号信息 1 file changed, 6 insertions(+) create mode 100644 changelog.md这时暂时先不用push，不过这里值得注意的是，一般来说，我们只有两个长期分支，一个 develop，另一个是 master分支。例如release 、feature等分支一般不会出现在远程的分支中。这是以为当我们做完这些工作流后，这些分支都会合并删除了。等完成这些工作后，我们把发布流程结束，在命令行输入: git flow release finish 1.0.0。git flow将会做以下几个步骤：pull代码，以确保本地分支的代码都是最新的版本。然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。这时命令行会进入vim编辑器里的合并信息页，默认会以Merge branch &#39;release/1.0.0&#39;作为 commit信息提交。我们也可以自己输入一些信息进行描述。(vim编辑器状态下，输入a则进入编辑状态，使用:q为不保存信息退出编辑器，:wq为保存信息并退出vim)。123456789101112Merge branch 'release/1.0.0'# Please enter a commit message to explain why this merge is necessary,# especially if it merges an updated upstream into a topic branch.## Lines starting with '#' will be ignored, and an empty message aborts# the commit.~~~"~/MyProject/git-flow-test/.git/MERGE_MSG" 7L, 256C保存后又会进入另一个信息，这次这个是确定版本号信息。我们将v1.0.0前面的#去掉，让其作为tag，v是一开头初始化所用的前缀，而1.0.0则是我们这次发布的名称（版本号）。12345678## Write a message for tag:# v1.0.0# Lines starting with '#' will be ignored.~~~"~/MyProject/git-flow-test/.git/TAG_EDITMSG" 5L, 84C为便于识别和做历史参考，release 提交会被标记上这个 release 的名字。清理操作，版本分支会被删除，并且回到 “develop”。hotfix上线后，在进行测试时会可能会发现之前没有留意到的小bug，比如展示的数据调错了字段，当bug修复后，这时就可以使用git flow 里的hotfix，用来表示bug的修复。值得注意的是，hotfix与之前两个分支有些不同，hotfix是基于master主分支的修复，而前面两者是基于develop分支。12345678910111213➜ git-flow-test git:(master) git flow hotfix start v1.0.1hotfixSwitched to a new branch 'hotfix/v1.0.1hotfix'Summary of actions:- A new branch 'hotfix/v1.0.1hotfix' was created, based on 'master'- You are now on branch 'hotfix/v1.0.1hotfix'Follow-up actions:- Start committing your hot fixes- Bump the version number now!- When done, run: git flow hotfix finish 'fixShoppingCart'然后你会看到git flow会提示你：开始修复你bug修复bug也是需要影响版本号的完成上述工作后就可以结束这个补丁啦~123456789101112131415161718192021222324252627➜ git-flow-test git:(hotfix/v1.0.1hotfix) vim index.html➜ git-flow-test git:(hotfix/v1.0.1hotfix) ✗ vim changelog.md➜ git-flow-test git:(hotfix/v1.0.1hotfix) ✗ git add .➜ git-flow-test git:(hotfix/v1.0.1hotfix) ✗ git commit -m "fixed shopping cart bug"[hotfix/v1.0.1hotfix 1506b7f] fixed shopping cart bug 2 files changed, 4 insertions(+), 2 deletions(-)➜ git-flow-test git:(hotfix/v1.0.1hotfix) git flow hotfix finish v1.0.1hotfixSwitched to branch 'master'Merge made by the 'recursive' strategy. changelog.md | 2 ++ index.html | 4 ++-- 2 files changed, 4 insertions(+), 2 deletions(-)Switched to branch 'develop'Your branch is up to date with 'origin/develop'.Merge made by the 'recursive' strategy. changelog.md | 8 ++++++++ index.html | 4 ++-- 2 files changed, 10 insertions(+), 2 deletions(-) create mode 100644 changelog.mdDeleted branch hotfix/v1.0.1hotfix (was 1506b7f).Summary of actions:- Hotfix branch 'hotfix/v1.0.1hotfix' has been merged into 'master'- The hotfix was tagged 'vv1.0.1hotfix'- Hotfix tag 'vv1.0.1hotfix' has been back-merged into 'develop'- Hotfix branch 'hotfix/v1.0.1hotfix' has been locally deleted- You are now on branch 'develop'我们使用git flow hotfix finish v1.0.1hotfix结束工作流后，跟之前那样会出现合并的信息，如果需要的话，就添加相应秒速信息，再保存退出即可。这时会将修复的部分同时合并到master和develop分支上，同时会为这次hotfix打上 tag。其他bugfix，它也是修复bug分支。看到这里就会有同学会疑问了：“啥？又改bug，这和之前那个又有啥区别？”。原来它与hotbug不同的是，它是基于develop分支的。事实上这一个工作流在笔者的日常开发中用的比较少，似乎有些gif flow 的模型中都没有这个工作流，不过我也没有深入的去考证~因为目前没有遇到碰到这个的场景，了解的同学不妨留言讨论分享一下。除此之外还有一个support的功能，是想用来支持以前的版本产品，这是一个实验性的功能，不太建议使用这个。如果你偏爱于可视化的git的话，如同 sourcetree 之类的 Git GUI 也内置有git flow。总结git flow实际上就一连串命令的组合，我们也可以单个单个的输入命令达到同样的效果。虽说git flow统一了工作流程，但并不是适用于全部的场景。项目中只有一个人时却反而会显得有点繁琐了。我们应该根据实际项目去选择符合项目的工作流。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>git flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器与服务端的背后交互: 详解页面请求的过程]]></title>
    <url>%2Fblog%2F2018%2F04%2F06%2FURL-to-browser%2F</url>
    <content type="text"><![CDATA[这其实一个很经典的一个题目啦~但其涉及知识面之广，却值得一说。开始我们将 URL 输入至浏览器的地址栏后回车, 首先浏览器就会开始检查 URL 是否合法, 是否 IP 地址， 若是不符合匹配规则, 将会以关联字进行搜索， 并带至搜索页（这个看浏览器设置）.我们以掘金为例, 我在输入 URL 的时候粗心的输错了协议. 但 Chrome 浏览器不认识这玩意呀, 然后将我们带到了搜索页. 仿佛在说: “嘿, 兄弟. 虽然不太理解你想干嘛, 但是你可以看看这里有你想要的东西吗?”DNS嘿, 接下来我们需要了解一些基础的概念~通常我们看到诸如www.baidu.com/之类的网址， 我们将其称之为域名. 而 DNS就是域名系统(Domain Name System)，它所处于的角色就是将主机名和域名映射为相应的 IP 地址.事实上  我们向服务端请求资源时, 也可以直接输入目标 IP, 并不一定需要通过域名才能访问到. 但更多的时候， 我们常见的还是使用域名的方式进行访问， 这是为什么呢？ 其实这个也很好理解，当你需要记住十个以上诸如111.13.101.208的 IP 地址的话，你就会感觉头疼了，如果我们使用我们熟悉的单词去记的话，相反就没那么困扰了（想想淘宝，京东和百度的域名~）.然而当计算机在网络进行通讯时, 它们仍然需要 IP 地址————因为它们不认得域名，这时 DNS 就派上用场啦~ 换句话说, 域名对于服务端来说, 并不是必须的，这只不过是方便人脑记忆罢了~ok, 咱们回归正题, 我们把前面的错误纠正, 输入正确的 URL =&gt; 浏览器开始解析 DNS:首先浏览器将接收到的 URL 抽出主机名，并将主机名发送到 DNS  客户端.随机查找缓存中是否有该域名的记录， 缓存查找会根据以下几步进行查找：每个浏览器都有自己的缓存, 浏览器会先检查自身的缓存的是否存在目标的 DNS 记录? 如果有则进行尝试连接.(chrome 浏览器的 DNS 是采用预解析的, 我们可以在地址栏输入 about:DNS 查看浏览器本地的 DNS)如果浏览器缓存没有找到, 进而会查找操作系统中的 DNS. (windows 可以在命令行使用 ipconfig /displaydns来查看 DNS)如果在本地 DNS 都没有找到的话, 则会查找hosts 文件(域名解析文件), 它是负责将主机名映射到相应的 IP 地址。随带一提，我们在日常开发中常用到的127.0.0.1默认就在hotst 文件中映射了域名为localhost, 因此我们直接使用localhost来访问127.0.0.1。这些都是可以由我们自定义的。如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器（比如谷歌通用 DNS 地址 8.8.8.8），我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析。如果仍然没有找到的话， 本地 DNS 会发出一个请求到 ISP DNS 缓存服务器（互联网服务提供商，如电信，你用的是哪一家的网）进行递归查询.如果仍然没有找到，就  会去根域名进行查询，根域名服务器全球只有十三台。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器 IP 告诉本地 DNS 服务器。顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的 IP 地址告诉本地 DNS 服务器。主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录。找到会将结果缓存起来， 同时返回结果给客户端.从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查询。资料借鉴： DNS 解析的过程是什么，求详细的？TCP/IP 连接世界上几乎所有的 HTPP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层。 HTTP 的连接实际上就是 TCP 连接以及其使用规则。 –《HTTP 权威指南》紧接着，浏览器拿到 IP 地址后， 浏览器获取 URL 的端口（每个协议都有默认的端口号，比如 http 默认端口就为 80.），URL 中没有则获取协议的默认端口。随即浏览器发起 TCP 连接请求：创建新的套接字（socket）.浏览器发起到 120.41.39.47:443(掘金主页 IP 及端口) 的连接.建立一条新的 TCP 连接时， TCP 软件会进行交换一系列的 IP 分组，对连接的有关参数进行沟通.a1). 首先浏览器会发送一个小的 TCP 分组，这个分组设置了一个特殊的 SYN 标记，用来表示这是一条连接请求，然后等待服务端的回应.a2). 服务器接受了连接后， 会对一些连接参数进行计算，并向客户端传回个 TCP 分组，这分组中包含有 SYN 和 ACK(确定字符) 标记，说明请求已经成功建立.a3). 如果浏览器迟迟没有收到 ACK 标记时， 可能会重新发送一个请求。如果 收到后，则会向服务器回送一条 ACK（确认信息），将完整的请求头发送出去.服务器读取请求后，对 HTTP 请求进行处理.判断请求是否合理合法，合理的话就执行所请求的动作，并将数据写回客户端.在输入网址后，浏览器向服务端发起请求，服务端先是返回一个doc类型的HTML文件回来，浏览器解析文档时，再一次根据文档里的(link 或者 script 标签)进一步请求外部资源（详情放在下面再说）.我们可以在Network上看到，浏览器将请求发出去后，请求的status会变为pending，这也是上面说到开始建立连接请求的第一步，正在等待服务器的回应。随即我们点进请求详情内，可以发现请求头只有少量的字段。我们再打开一个请求状态（status）为 200 的请求，就能看到完整的请求头以及服务端传回来的响应了.渲染文档接着上面的问题， 浏览器开始解析页面。不过不同的浏览器引擎渲染过程都不太一样，这里姑且先说说webkit内核的渲染方式.首先浏览器的HTML解释器（HTML Parser）先工作，它将HTML的标签解析为DOM树。（DOM树构建）.如果遇到了&lt;script&gt;标签则会停止解析文档，这是因为JavaScript中可能会带有document.write方法，可能会重写页面的结构，因此浏览器会等待script标签下载完毕并执行后才会继续解析文档。这也是著名的web开发最佳实践的规则之一的由来————将&lt;script&gt;放在&lt;body/&gt;&gt;之上，这样就不会阻塞文档解析了。接着css解析器（CSS Parser）会在DOM树构建完毕后开始解析css，它和DOM树一样最后解析出来的是树形结构的CSSOM（css object module，别名也要StyleRules），浏览器将解析后的样式信息保存到新建的RenderStyle对象中。RenderStyle对象被RenderObject类所管理和使用.当创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息，这个过程也被称之为回流与重绘（reflow and reflow）.页面呈现.页面绘制的过程在下图的加载Mozilla官网动图就很好的体现了出来~]]></content>
  </entry>
  <entry>
    <title><![CDATA[详解图片的加载方式]]></title>
    <url>%2Fblog%2F2018%2F03%2F24%2Floading-pictures%2F</url>
    <content type="text"><![CDATA[[大图预警，流量慎入！] 我们在浏览页面获取信息时, 细心的你可能会留意到, 不同网页的图片可能有不同的加载方式. 那么究竟是由什么决定图片的加载方式的呢? 然后不由的陷入了沉思(.jpg), 所谓耳听为虚, 就让自己来动手操作一下吧~加载方式目前所知的图片加载方式主要有两种: 一种是线性加载, 而另一种则是渐进式加载.线性加载其实我们已经很熟悉啦, 图片的加载方式由上至下, 一点一点的加载的方式. 同时也是最常见的方式. 如下为例:渐进式则如同名字一般, 它会先显示低分辨率的近似图像, 再逐步的增加图片分辨率(模糊到清晰). 这里容我卖个关子, 不上示例图先.实现原理那么到底是什么决定了图片的加载方式呢? 事实上, 加载方式在作图的时候就已经被定下来了.比如在 Photoshop 中, 我们使用快捷键ctrl + shift + alt + s, 弹出储存为 Web 所用格式, 再选择jpeg格式后能看到下面有一个连续的选项(悬浮提示以多条路径下载), 这个选项的背后就是一个算法的接口，默认是不勾选的。渐进式使用的是小波变换, 而默认线性加载则是离散余弦变化算法. (关于算法的问题已经超出了本文的讨论范围, 这里姑且不谈.)浏览器在加载页面的时候, 读取图片的压缩算法, 再根据不同的压缩算法来选择相应的渲染算法.两者对比嗯, 看似很有道理的样子呢, 那实际效果如何呢? 来动手测试一下: 我准备了两张相同内容但不同加载方式的图片. 将控制台打开, 设置一个比较差的网速来对比两张图片的加载情况.what? 怎么好像跟想象中的有所出入? 仔细一瞧, 图一虽然从上至下的加载, 但同时它的清晰度也跟着变化. 而图二则没有这种的效果.随后我想到了文件大小的限制的问题, 为了了解更详细加载过程, 我再次准备了两张png的格式, 只不过在ps上png格式需要勾选的选项变成是交错, 然后再次进行试验:啊哈… 由于图片本身也挺大的, 在这加载期间两者之间差距就体现出来了 —— 原来前面那只是因为算法前期结构的构建. 细心的同学还会看到, 虽然图一看上去最先加载完了图片, 但控制台里跳动Size和Time还在告诉我们, 浏览器仍然还没有下载渲染完这张图片, 安静的等待渲染完毕后, 你可能还会惊讶的发现: 什么? 图一竟然比图二还加载的时间还长一点?是的, 得益于渐进式逐步加载的算法, 人们在视觉上会感觉渐进式相比线性更快一些, 虽然实际加载的时间可能还会长点, 但用户体验的确是上去.然而并非所有浏览器都支持渐进式加载, 翻阅了一下资料, 发现早期张鑫旭dalao也写过类似的内容, 也可以参考一看: 渐进式jpeg(progressive jpeg)图片及其相关JavaScript的渐进式前文介绍渐进式的时候卖了个关子, 没上示例图是为啥呢~ 这是因为此物非彼物, 我们常看到的渐进式加载可能不是由图片本身算法的效果, 为了避免混淆才暂时不上. 文章看到这里, 有过开发经验的同学就会明白, 若真有这种需求, 我们总不能祈祷全部用户上传图片都是渐进式的吧, 这也不现实.google 图片就是使用javascript来操作图片的渐进式. 在点击查看大图的时候, 预先加载一个缩略图, 同时图片底布有一条loading的效果. 加载完毕后就显示清晰的图片, 并且将 loading 隐藏起来. 我在控制台研究了一段时间, 没研究出具体的实现手法. 知道的dalao也不妨留言, 交流一下~至于知乎的渐进式加载图片, 已经有知友分析过了, 实现方式跟我上一篇文章讲的东西思路也有相似之处, 只不过是针对方向不同~ 有兴趣的可以移步知友的回答: 新版知乎加载图片时从模糊到清晰的这个效果是如何做出来的？ - Tw93的回答最后如果有什么说的不对的或者, 欢迎dalao们指出批评~]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>image</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于移动端GIF动图逐个播放的思路]]></title>
    <url>%2Fblog%2F2018%2F03%2F11%2F%E5%85%B3%E4%BA%8E%E5%89%8D%E5%8F%B0GIF%E5%8A%A8%E5%9B%BE%E9%80%90%E4%B8%AA%E6%92%AD%E6%94%BE%E7%9A%84%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最近碰到了一个需求, 大致是移动端有一个提示页, 在页面中会四个GIF图, 连起来像一个”小视频”一样, 用来展示商品的步骤.但是四个GIF一起播放的话, 那么用户体验就自然没有那么好啦. 我仔细的想了想, 想到了微博的GIF图好像就是一张一张播放的, 那么我们前端有没有办法也实现这个逐个播放的功能呢…事实上, 浏览器并没有给我们提供控制GIF的API(据说曾经好像有, 但因为用户体验的问题被废除了, 关于这点我没有去考证过), 我们无法得知这个动画是否已经结束了, 或者控制它的播放和停止.网上并没有太多关于这方面的资料, 不过张鑫旭dalao的这篇文章. 其中一个方法给我一个思路 —— 虽然img并没有这种事件, 但是我们可以使用canvas做替换呀.说干就干, 这里借鉴dalao的代码, 对HTMLImageElement(可以用来操纵&lt;img&gt;元素的布局和图像)的原型作扩展, 增加两个方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950if ('getContext' in document.createElement('canvas')) &#123; // 扩展播放功能 HTMLImageElement.prototype.play = function () &#123; if (this.storeCanvas) &#123; // 移除存储的canvas this.storeCanvas.parentElement.removeChild(this.storeCanvas); this.storeCanvas = null; // 透明度还原 this.style.opacity = ''; &#125; if (this.storeUrl) &#123; this.src = this.storeUrl; &#125; &#125;; // 扩展停止功能 HTMLImageElement.prototype.stop = function () &#123; const canvas = document.createElement('canvas'); let width = this.width; let height = this.height; if (width &amp;&amp; height) &#123; // 存储图片链接 if (!this.storeUrl) &#123; this.storeUrl = this.src; &#125; // canvas 和图片相同宽高 canvas.width = width; canvas.height = height; canvas.getContext('2d').drawImage(this, 0, 0, width, height); // 重置当前图片 try &#123; this.src = canvas.toDataURL("image/gif"); &#125; catch (e) &#123; // 跨域, 这时画布被污染 this.removeAttribute('src'); canvas.style.position = 'absolute'; // 插入图片 this.parentElement.insertBefore(canvas, this); this.style.opacity = '0'; this.storeCanvas = canvas; &#125; &#125; &#125;;&#125;因为前台并没有我们想要操作图片的事件, 因此无法得知gif能持续多少秒, 这点只能由服务端来判断. 所幸这次情况没有那么复杂, 我们不需要适配随机的GIF. 就根据我们手头的动图计算有多少帧, 查看得知每个GIF播放时间都为3s. 再使用定时器的方式去调用方法, 为了防止用户没看清GIF的动作, 因此在定时器时间上再翻了一倍.页面代码大致如下:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class="body"&gt; &lt;!-- .split-line End --&gt; &lt;h3 class="body-title"&gt;观影指南&lt;/h3&gt; &lt;div class="body-tips"&gt; &lt;div class="tips-line clearfix"&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-1.gif" alt="tips-1"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;1.坐上座椅，系好安全带&lt;/p&gt; &lt;/div&gt; &lt;!-- .tips-group End --&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-2.gif" alt="tips-2"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;2.于右手边取眼镜佩戴，并带上耳机&lt;/p&gt; &lt;/div&gt; &lt;!-- .tips-group End --&gt; &lt;/div&gt; &lt;!-- .tips-line End --&gt; &lt;div class="tips-line clearfix"&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-3.gif" alt="tips-3"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;3.按下扶手上的按钮，开始观影&lt;/p&gt; &lt;/div&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-4.gif" alt="tips-4"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;4.如感不适，长按按钮停止观 影&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- .tips-line End --&gt; &lt;/div&gt; &lt;!-- .body-tips End --&gt; &lt;/div&gt;首先选择全部目标GIF, 使其暂停(初始化). 紧接着包装一下定时器用函数调用:123456789101112131415161718192021// 注意这里是 ES6 的写法const images = document.querySelectorAll('.tips-img img')let palyTimer = null;function palyGif (num = 0) &#123; clearTimeout(palyTimer) images[num].play() // 递归 palyTimer = setTimeout(() =&gt; &#123; images[num].stop() num = (images.length - 1 &lt;= num) ? 0 : ++num images[num].play() return palyGif(num) &#125;, 6000);&#125;// 初始化images.forEach(img =&gt; img.addEventListener('load', img.stop, &#123; once: true &#125;))// 函数提升, 将其推向下一队列setTimeout(() =&gt; palyGif(), 50);仅仅几行代码留实现我们想要的效果啦(图片压了下):至于微博那种逐个播放的效果, 我原本想在控制台研究一下它实现的原理. 但仔细一看, 发现微博动图在手机客户端和非客户端上的效果是不一样的. 也就是说在安卓客户端上的确逐个播放, 但是在手机网页上却是一起播放, 并没有实现这个功能, PC页面同理, 因此推测并不是使用js实现的.最后各位看官如果有什么好的想法的话, 可以留个言一起交流一下呗~]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>移动端</tag>
        <tag>gif</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊常见的跨域问题]]></title>
    <url>%2Fblog%2F2018%2F03%2F04%2F%E8%81%8A%E8%81%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[跨域是前端工程中一个很常见的问题啦. 今天就来聊一聊跨域, 以及常见的处理方式和原理.什么是跨域?跨域实际上源于浏览器对javascript的一种安全限制(也被称之为同源策略). 默认情况下, 我们只能访问同一协议、同一域名、同一端口下的资源. 如今都是提倡前后分离的情况下, 前端更是需要调用大量后台接口的场景, 因此解决跨域的问题就摆在了面前.产生跨域的原因产生跨域的原因我们主要归为这两点:浏览器安全限制(不能读取不同域、端口、协议下的内容)使用的是XHR(XMLHttpRequest)请求同源策略这个原因是众所周知了, 它作为一个安全策略, 的确有效预防了某些安全上的问题. 但同时又阻止了大量适合使用的跨域请求. 而 XHR 也受同源策略影响: 浏览器不允许 javascript 查找跨域文档的内容. 使用 XHR, 文档内容都是通过responseText属性暴露, 因此同源策略不允许 XHR 进行跨域请求.解决跨域跨域很多情况下都需要后端的配合, 因此主要先来谈谈前端的跨域方案.JSONP前文我们说过, 产生跨域的原因之一XHR请求, 但是script发出的请求类型(type)并不是xhr, 因此可以解决跨域的问题.JSONP 由回调函数和数据组成的, 实现方式就是动态创建一个&lt;script&gt;标签, 然后设置src属性指向的跨域的URL(包涵请求参数). 来向服务端请求数据.比如我们要查询小明的信息, 这时我们得知它的userID为 1150, 同时我们都知道GET请求可以通过url进行传参, 因此我们向服务器发起请求:123var script = document.createElement('script')script.src = "https://www.example.com/users?user_id=1150"document.body.appendChild(script)在插入&lt;script&gt;标签到&lt;body&gt;后, 浏览器立马就去请求服务器的资源. 值得注意的是, 使用jsonp也需要服务端的配合. 因此必须通过某种方式来告知服务端, 我们正在通过&lt;script&gt;标签调用请求, 必须返回一个JSONP响应, 而不应该是普通JSON响应.至于什么叫jsonp响应呢? 这里其实很好理解.. 假设后端发回来的是json格式的数据, 我们也用不了呀, 数据还是数据, 不会做任何变化.. 为了让浏览器可以在&lt;script&gt;标签里直接使用, 我们需要让服务端返回一段js代码 —— 用函数包装的json的形式(这也jsonp中”P(padding)”的含义). 这个函数名前后端可约定. 如下:1234567// 服务端返回 js 代码到 &lt;script&gt;里userData(&#123;'naem':'小明','id':1150,'level':'中等'&#125;)// 前端定义函数function userData(data) &#123; // 当 jsonp 请求成功后, 将json传入函数并调用, 我们拿到 json 后就可以做一些其他的事&#125;我们来拿B站为例. 打开chrome下的network, 上图就是jsonp的应用, 服务端返回的js脚本. 下图可以发现, 我们发出去的请求类型是script, 验证了前文所说的&lt;script&gt;不受同源策略影响的.目前主流的类库都对jsonp进行了封装, 如JQuery的getJSON和ajax, 这里就不深入讲解了. 最后对jsonp总结一下:jsonp实际上是一个非正式传输协议, 或者说是一种”投机取巧”的方式. 我们可以利用&lt;script&gt;的特性从而进行数据交互解决跨域的问题. 相对来说, 它也有一定的局限性: 只能应用在GET请求上, 除此之外还有安全性的问题 —— 只能用在我们信任的服务端, 因为你不能保证对方未来会给你传些什么…跨域资源共享(CORS)概述说完了”不正规”的jsonp, 紧接着我们再说说原生的CORS规范. 我们先来看看官方的定义:CORS(Cross-origin resource Sharing, 跨资源共享), 定义了访问跨域资源时, 浏览器和服务器应该如何沟通. 其背后主要思想就是使用自定义的HTTP头部来让浏览器与服务器进行沟通, 从而决定请求或相应是否成功, 还是应该失败.目前主流的浏览器都已经对CORS有着良好的支持, 而IE8 ~ 9则还需要使用专用的XDomainRequest这里我们抛开不谈.这个功能实际上是由浏览器自动完成的, 我们并不需要做什么额外的工作. 对于开发者来说, 也就需要了解一些安全细节的问题, 这一点我们放在后面讲.两种请求浏览器发送CORS请求时, 会将请求分为简单请求与非简单请求.在我们日常工作中, 常用的简单请求可以将其归为以下几点:使用的方法(Methods)为HEAD、GET、POST请求头无自定义头Content-Type只能是以下几种text/plainmultipart/form-dataapplication/x-www-form-urlencoded非简单请求:PUT, Delete 方法的 ajax 请求发送 JSON 格式的 ajax 请求(比如post数据)带自定义头的 ajax 请求如果是简单请求, 则会先执行, 后判断。执行的过程大致如下:浏览器发起请求检测到是 CORS 请求, 然后添加一个origin字段(其中包含页面源信息: 协议、域名、端口) =&gt; 服务端收到后作相应的处理(对比origin, 服务端判断这个源是否接受)返回结果给浏览器 =&gt; 浏览器检查响应头是否允许跨域信息 =&gt; 允许, 那就当做没事发生. 不允许, 浏览器抛出相应的错误信息(值得一提的是, 这时状态码也还有可能是200).非简单请求执行顺序又有些不同. 在发生 CORS 请求时, 浏览器预先发送一个option请求. 浏览器这种行为被称之为预检请求(Preflighted request). 其中包含如下的请求头:origin: 同上，包含页面源信息.Access-Control-Request-Methods: 请求方法Access-Control-Request-Header: 自定义头部信息, 多个头部以逗号分隔(可选, 看请求时有没有定义请求头)举个栗子, 我们用JQuery发送一段JSON格式的请求做演示:1234567891011var result;$.ajax(&#123; type : "post", url: "https://www.example/api/rank", contentType : "application/json;charset=utf-8", data: JSON.stringify(&#123;name: "something"&#125;), success: function(json)&#123; result = json; &#125;&#125;);这时请求头(Request Headers)信息如下:123456789Accept: */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Access-Control-Request-Header: content-typeAccess-Control-Request-Methods: POSTConnection:keep-aliveHost: https://www.example.comorigin: localhost:8080User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1服务端接收到预检请求后, 判断是否允许这种类型的请求. 在响应头(Response Header)上返回如下头部与浏览器进行交流:Access-Control-Allow-Origin: 服务端允许的源信息Access-Control-Allow-Methods: 服务端允许的方法, 多个方法可以使用顿号分隔Access-Control-Allow-Headrs: 服务端允许的头部, 多个头部可以使用顿号分隔当预检请求被通过后, 我们原本想要发送的请求才会发送出去.另外, 细心的你或许已经注意到了, 非简单请求这一来一回需要发送两次请求, 如果频率高的情况下岂不是很费性能又影响效率? 所幸的是HTTP协议新增(IE10+)了一个响应头用于缓存预检请求. 服务端在响应头添加如下字段:1Access-Control-Max-Age: 3600这个响应头表示这个预检请求可以缓存多长时间, 单位为秒. 这里3600s = 1h, 也就是说一个小时内可以不用再发预检命令了.带 cookie 的跨域请求默认情况下, 跨域请求是不带上 cookie 的. 前端需要将withCredentials属性设置为true, 同时还需要服务端设置Access-Control-Allow-Credentials为true启动 cookie. 如果在发送 cookie 的时候, 浏览器检测到服务端响应头没有这个头部, 那么就会在控制台抛出一个错误.另外, 还有一个值得注意的是. 服务端响应头设置了Access-Control-Allow-Origin: *的话, 是不能满足带 cookie 的跨域请求的. 因此有这种场景不能使用通配符, 需要全匹配字段.CORS 总结简单总结一下 CORS. CORS的出现也是为了解决跨域的问题. 只不过和JSONP不同, 它是纳入规范的一部分, 它几乎支持所有的类型的HTTP请求(JSONP只能使用GET). 唯一美中不足的也就是兼容性的问题, 因此可以使用JSONP作向下的兼容事实上前端在 CORS 上并没有多少可操作的余地, 主要的还是浏览器来处理、服务端在设置, 但是并不代表我们就不需要了解这些知识啦.嗯, 其他的跨域方法先挖个坑..]]></content>
  </entry>
  <entry>
    <title><![CDATA[VSCode: 从零开始配置前端环境]]></title>
    <url>%2Fblog%2F2018%2F02%2F06%2FVSCode-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[我们在进行开发工作时，选择一个顺手好用的IDE是必不可免的, 其中vscode就是一个很好的选择. 它能让你大部分的工作都在编辑器内完成, 大大的提高开发效率~ 本文将会从零开始搭建一个基础的前端开发环境.概述vscode有着自己的插件商城, 并且有成熟良好的生态圈, 足够满足我们日常开发的所需的东西. 同时vscode提供了很多便捷的自定义配置，还很贴心的给每行设置都加上了备注.除此之外，vscode对中文的支持也挺好，对于啃英语有些吃力的同学会比较友善(虽然作为一个程序员, 英语的学习也很重要呀~).另外vscode内置git管理系统, 也就是说我们在写完代码后无需再另开一个bash来提交代码, 直接编辑器上完成审阅代码差异, 提交代码这些工作. 还可以直接在编辑器上进行代码调试, 不过这些不在本文的讨论中.主题One Monokai Theme我们每天在跟编辑器打交道, 因此编辑器的颜值也是很重要的~ 在扩展商城里, 我们可以去挑选一些自己喜欢的主题, 让我们在coding时变得更加舒服. 目前笔者使用的One Monokai, 它的一些配色和主题个人还是蛮喜欢的. 同学们也可以去尝试其他的主题~但值得注意的是, 下载主题后还需要用户设置上设置使用的主题.扩展插件善用插件的力量能很大的提升我们的开发效率. 下面是一些自己常用插件跟大家分享一下.其他编辑器的快捷键如果你觉得换一个编辑器又要重新设置自己熟悉的快捷键(或者说记住vscode本身的快捷键)很麻烦的话, 没关系~ vscode为你准备了其他编辑器快捷键插件, 节省你宝贵的时间成本. 笔者曾经也是从 sublime 无障碍转向 vscode 从此一去不复返~Open-In-Browser由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项. 在windows下, 可以使用快捷键Alt + b快速的打开.CSS Peek使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。PrettierPrettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。SVG Viewer前端开发中, 无可避免会遇到查看svg的地方, 这时这个插件就能配上了用场.Minify这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。Auto Close Tag这个扩展是为XML，PHP，Vue，JavaScript，TypeScript，JSX，TSX等其他语言启用的。同时它是可配置的。输入标签的右括号后，结束标签将被自动插入。Auto Rename Tag自动重命名配对的HTML / XML标记, 这在修改标签名上一点挺便捷的.JavaScript (ES6) code snippetses6已经是经常运用在我们的项目中了, 该扩展包含用于 Vscode 编辑器的ES6语法的JavaScript代码片段.（同时支持JavaScript和TypeScript）。ESLint嘿, 要养成一个良好的编程习惯, ESLint就是一个不错的选择. 它会根据某种风格来纠正你的不好的习惯. 值得注意的是, 使用的话需要在全局安装有ESlintEditorConfigEditor Config 可以让你团队开发时统一约定好一种规范. 这个主流的编辑器都支持.Vetur格式化, 格式化.vue文件, 官方维护.Vue 2 Snippets这个插件基于最新的Vue官方语法高亮文件添加了Syntax Highlight, 并且依据Vue 2的 API 添加了Code Snippets`. 挺不错的一个扩展.language-stylusstylus语法高亮, 还有其他的预处理器的插件这里不展开讲.用户配置分享一下自己目前的配置, 可以根据项目所需或者自己的习惯进行调整.1234567891011121314151617181920212223242526272829303132333435&#123; "workbench.colorTheme": "One Monokai", "sublimeTextKeymap.promptV3Features": true, // 编辑器 "editor.multiCursorModifier": "ctrlCmd", "editor.snippetSuggestions": "top", "editor.renderWhitespace": "all", "editor.formatOnPaste": true, "editor.wordWrap": "on", "editor.fontSize": 12, "editor.tabSize": 2, // 文件资源管理 "explorer.confirmDragAndDrop": false, "explorer.confirmDelete": false, // 终端 "terminal.integrated.cursorBlinking": true, "terminal.integrated.cursorStyle": "line", "emmet.includeLanguages": &#123; "vue-html": "html" &#125;, // 文件 "files.eol": "\n", "files.associations": &#123; "*.vue": "vue" &#125;, // 窗口 "window.zoomLevel": 1, // 使用 vscode-typescript 来整理代码 "vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatter.ts": "vscode-typescript", "javascript.format.insertSpaceBeforeFunctionParenthesis": true, // 可能是让 CPU 炸了的罪魁祸首 "search.followSymlinks": false, "html.format.extraLiners": ""&#125;总结实际上促使自己写这篇文章的源头, 仅仅是因为某个不可抗拒的因素, 导致系统重装.. 重装环境简直让人绝望呀~ 因此借着这个机会基础一下, 如果有遗漏哪个部分, 后来还会继续加进来吧~参考链接精选！15 个必备的 VSCode 插件（前端类）]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>vue</tag>
        <tag>vscode</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的console]]></title>
    <url>%2Fblog%2F2018%2F01%2F30%2FDebug-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6console%2F</url>
    <content type="text"><![CDATA[打断点和console.log是我们前端调试中, 使用最为频繁的一种. 但实际上console API 可不仅仅用来查看某个值或者某个变量是否存在, 它还有更多的用法是不为人知的.概述console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的. 其次它是一个全局对象, 我们先在控制台将console打印出来, 看看它里面都有些什么东西, 再来一一讲解吧.Methodlogconsole.log就是向web控制台输出一条信息. 参数可以是变量, 数字, 字符串等.123456// 常规下var name = 'Jack'console.log('Hello') // Helloconsole.log(name) // Jackconsole.log(`Hello, $&#123;name&#125;`) // Hello, Jack除此之外, 还支持格式化输出.1234var name = 'Jack'console.log('Hi, %s. what are you doing', name) // Hi, Jack. what are you doingconsole.log('%c I am some great text', 'font-size: 50px;') // 假装 50px: Hi, Jack. what are you doing下面是它所支持的参数, 学习C语言的同学有没有感觉扑面而来的熟悉感呀~占位符描述%s字符串%d or %i整数%s打印字符串%f浮点数%c样式代码这里连知乎, 百度等大厂也用console来做招聘广告或做些有意思的事~ info, warn, error这三者实际上在我们开发时也时常出现. 现在主流的一些框架, 比如说Eslint, 就封装了相关方法. 当你语法出现不规范的地方, 就会根据错误来弹出指定的提示框来提示你.12345678// Infoconsole.info('Hi, This is message')// warning 警告console.warn('On, Your operation may cause a security breach!')// Error 报错console.error('Shit! Variable does not exist!')实际效果:tableconsole.table只接受一个数组或者对象, 可以接受一个额外的参数来描述表格的列数.它会把数据通过表格的形式打印出来, 这样我们看数据的时候就能直观了很多:1234567var array = [ &#123; name: 'Jack', age: 12 &#125;, &#123; name: 'Tome', age: 18 &#125;, &#123; name: 'baka', age: 15 &#125;]console.table(array)groupconsole.group和console.groupWEnd就像一对标签一样. group在控制台创建一个新的分组, 输出到控制台上的内容都会被添加一个缩进, 表示该内容属于当前分组, 直到调用console.groupEnd()之后, 当前分组才结束.12345678910111213var boys = [ &#123; name: 'Jack', age: 12 &#125;, &#123; name: 'Tome', age: 18 &#125;, &#123; name: 'baka', age: 15 &#125;]boys.forEach(item =&gt; &#123; console.group(`$&#123;item.name&#125;`) console.log(`This is $&#123;item.name&#125;`); console.log(`$&#123;item.name&#125; is $&#123;item.age&#125; years old`); console.log(`$&#123;item.name&#125; is $&#123;item.age * 7&#125; years old`); console.groupEnd(`$&#123;item.name&#125;`)&#125;)dirconsole.dir —— 在控制台中显示指定JavaScript对象的属性，并通过类似文件树样式的交互列表我们知道console.log实际上是可以输出DOM节点的, 但有时候我们只想知道 DOM 属性的话, 这里就可以使用dir来输出DOM对象.1234var head = document.getElementById('head')console.log(head)console.dir(head)值得注意的是. MDN提醒我们, 这个特性是非标准, 尽量不要在生产模式下使用.countcount, 如同字面意思一样. count()会输出每一次被调用的次数. 该方法的兼容性也需要注意, 不适用于生产模式.12345678console.count('Steve')console.count('Steve')console.count('zeo')console.count('Steve')console.count('zeo')console.count('Steve')console.count('zeo')console.count('Steve')clearclear, 顾名思义就是清除. 看到别人那乱七八糟的用于调试的log或者info时, 这时只想要保留自己的调试信息. 那么console.clear()就可以为你解决这个烦恼, “一键清空”前面控制台所有的信息, 从头再来(雾)12// something infoconsole.clear()time启动一个计时器（timer）来跟踪某一个操作的占用时长。每一个计时器必须拥有唯一的名字。 页面中最多能同时运行10,000个计时器。跟group一样, time也是配套的。 当以此计时器名字为参数调用 console.timeEnd() 时，浏览器将以毫秒为单位，输出对应计时器所经过的时间.比如我们起一个fetch:1234567console.time('fetching data')fetch('https://api.github.com/users/anran758') .then(data =&gt; data.json()) .then(data =&gt; &#123; console.timeEnd('fetching data') console.log(data) &#125;)oh, 这样我们就轻易的知道了这次我们请求花费了多少时间啦~assertconsole.assert()还是蛮有意思的. 它第一个参数接受一个断言(声明), 第二个参数是一个message. 如果断言为false，则将一个错误消息写入控制台。如果断言是true，就当做没发生。语法如下:1console.assert(assertion, message [, subst1, ..., substN]);这里的断言不一定是false才会触发错误. 我特意去测试了一下, 触发的规则也跟if的判断里的逻辑相反. 只要是断言是0, NaN, undefined, false, null, 空字符串&#39;&#39;就会激活报错.12345678910111213// Assertion failed: Here is the "name" can not be emptyvar str = '';console.assert(str, 'Here is the "str" can not be empty')// Assertion failed: 0 is not allowed!var num = 0console.assert(0, '0 is not allowed!')// Assertion failed: That is wrong!console.assert(1 === 2, 'That is wrong!')// 什么都不会发生console.assert(1 === 1, 'That is wrong!')总结在适当的地方使用恰当的方法能使调试变得更清晰. 发现身边很多小伙伴都只了解log的方法, 正好最近看到了这方面的知识, 总结了一下, 活用于开发中能使效率变得更好~参考资料:MDN - Console: https://developer.mozilla.org/zh-CN/docs/Web/API/Console从console.log说起（上）: http://www.alloyteam.com/2013/11/console-log/javascript30: https://courses.wesbos.com/account/access/5a658ec8a6b56c55273b4078/view/194129876]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>Javascript</tag>
        <tag>tools</tag>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进 web 移动端开发]]></title>
    <url>%2Fblog%2F2018%2F01%2F25%2Fweb-%E8%B5%B0%E8%BF%9Bweb%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[近年来, 人们逐渐倾向移动端的使用. 越来越多的人使用手机/平板来上网. 既然有需求, 那就自然会有市场~ 作为一个身在一线的前端工程师在工作中也难免会遇到这种场景/需求. 下面就分享一下对于移动端的一些学习笔记~移动端基础的知识移动端的屏幕相比PC来说多的太多了, 因此我们不能只是使用传统的px, 首先来认识一下我们常用的单位吧.px: css pixels 逻辑像素, 浏览器使用的抽象单位dp, pt: device independent pixels 设备无关像素dpr devicePixelRatio 设备像素缩放比它们之间的计算公式是: 1px = (dpr)² * dp这里我们用IPhone 5为例, 我们知道, iPhone 5 的dpr为2, 根据上面的公式, 我们能得出:平面上: 1px = (2)² * dp =&gt; 1px = 4dp(四个物理像素)但我们在实际的开发中, 更多的是按照长度(维度)来换算:维度上: 1px = dpr * dp =&gt; 1px = 2 * dp因此在移动端开发的时候. 我们拿到UI的设计图, 设计图(IPhone5)的尺寸是640 * 1136. 这是因为dpr的缘故. 因此我们需要在开发时, 将原先的宽度除于2才行.还有我们常说的Retina屏又是什么? Retina屏(高清屏幕)就是dpr &lt;= 2.viewportviewport, 就是视图窗口. 其中它在手机上又分为一下两个窗口.Visual viewport (可视窗口)Layout viewport (布局窗口)最下面一层就是layout viewport, 上面一层就是visual viewport, visual viewport可以控制窗口的缩放(salce), 能看得到更多底层的layout viewport的东西.这里值得注意的是, layout viewport的宽度是大于浏览器可视区域的宽度的.Meta标签如果我们没有限制viewport的缩放比的话. 我们通过获取window.innerWidth(布局窗口) / document.body.clientWidth的缩放比得知, 设备会根据页面的大小, 自动的去调整缩放比. 这就会不符合我们的预期.这时我们可以通过Meta标签来控制viewport. 它的语法如下:1&lt;meta name="viewport" content="name=value,name=value"&gt;参数如下:width: 设置布局 viewport 的特定值(“device-width”)initial-scale: 设置页面的初始缩放minimum-sacle: 最少缩放maximum-scale: 最大缩放user-scalable: 用户能否缩放目前主流的编辑器在使用emmet生成基本HTML模板时都会自带插入一句1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;而有时候我们不希望用户能控制页面的搜索，那我们就可以设置user-scalable为no, 百度就是如下的做法:1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt;移动端布局移动端的布局就能不像PC端一样用固定宽度了, 因为移动端有太多不同的屏幕分辨率了.. 因此现在主流的布局方式还是响应式布局和flex布局. 未来还有Grid布局, 不过现在普及度不够高暂时放放, 以后有机会单独开一篇.响应式布局响应式布局实际上是一个设计理念, 它是多项技术的综合体. 其核心就是媒体查询(@media).响应式网站的优点主要有:减少工作量: 代码, 设计, 内容只需要一份. 多出的工作也仅仅是js和css样式的调整.相对来说会节省时间每个设备都能得到正确的设计相反, 它也带有一些副作用(缺点):由于我们是响应式布局, 需要加载更多的样式和脚本资源设计比较难精准定位和控制media实际上是css3的玩意, 对老版本浏览器兼容不好(特指IE)接着我们继续看看响应式设计着重的几个点吧:关于响应式设计中针对不同分辨率的媒体查询设计, 可以看我Repo中的这一块.百分比布局仅仅使用媒体查询来适应不同的固定宽度设计, 只会从一组css 到另一组css的切换. 两组之间没有任何平滑渐变. 当没有命中媒体查询时, 表现就会不可控.就比如说iPhone又出了个iPad mini, 这个设备的宽度介于iphone和ipad之间. 这样就有可能会导致布局的错乱, 我们应该要尽量避免这种情况发生.弹性图片很简单也很常见的思路. 图片设置宽度100%, 外层一个div包裹着, div设置宽度, 可以随着媒体查询改变宽度 从而实现自适应123img &#123; max-width: 100%&#125;当页面达到手机屏幕宽度的时候, 我们可以考虑放弃一些传统页面的设计思想. 力求页面简单, 简洁(手机屏幕小). 因此需要作出以下处理:同比例缩减元素尺寸调整页面结构布局隐藏冗余的元素除此之外, 应该将经常需要切换位置元素使用「绝对定位」, 减少重绘提高渲染性能.Flex布局Flexbox的出现是为了解决复杂的web布局，因为这种布局方式很灵活。容器的子元素可以任意方向进行排列. 有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。Flex在移动布局上已经运用的很广泛了. 比如我们常见的垂直居中, 原先需要好几行代码的效果, 现在就一行align-items: center就能解决了, 十分便利.Flex网上已经有太多的详细教程了. 考虑到篇幅限制, 这边也就不再过多的赘述了. 不过值得一提的是, Flexbox是有新旧两个版本的, 新的是display: flex, 旧的(2009年的语法)是display: box; 两者作用都差不多, 只是使用的属性名有些差异, 如果要兼容低版本的浏览器的话可以考虑后者.扩展阅读:[张鑫旭]CSS box-flex属性，然后弹性盒子模型简介: http://www.zhangxinxu.com/wordpress/?p=1338Flex入门: http://ife.baidu.com/note/detail/id/952Flexbox详解: https://segmentfault.com/a/1190000002910324移动端一些常见的坑1px border这个问题常出现在ios下, 其根本原因还是retina屏的问题. 1px使用了2dp渲染, 因此看上去就会粗一点.常见的解决方案有以下几个:背景渐变CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的。12345678910111213@mixin commonStyle() &#123; background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top;&#125;@mixin border($border-color) &#123; @include commonStyle(); background-image:linear-gradient(180deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(270deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(0deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(90deg, $border-color, $border-color 50%, transparent 50%);&#125;缺点就是没办法实现圆角.使用 scale 缩放0.5倍1234567891011121314151617.sidebar .folder li &#123; padding: 8px 0 8px 15px; color: #7c7c7c; Cursor: pointer; position: relative;&#125;.folder + li:before &#123; position: absolute; top: -1px; left: 0; content: ''; width: 100%; height: 1px; border-top: 1px solid #ddd; -webkit-transform: scaleY(0.5);&#125;多行文本溢出webkit内核的浏览器可以尝试使用-webkit-line-clamp, 可惜兼容性不高.12345678.intwoline &#123; display: -webkit-box !important; overflow: hidden; text-overflow: ellipsis; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2;&#125;终端交互优化最近几年，爆炸式的移动Web浏览器的使用打破了这个途径。低带宽，高延迟，小内存，低处理器性能的移动设备环境，迫使开发者不得不想办法通过优化前端页面的性能来满足用户的性能预期。300毫秒的故事移动web页面上的click事件响应都要慢上300ms移动设备访问的web页面都是pc上的页面. 在默认的viewport(980px)的页面往往都是需要”双击”或”捏开”放大页面, 来看清页面. 正是为了确定用户是”双击”还是”单击”. sofari需要个300ms的延迟来判断. 而后来的Iphone也一直沿用这样的设计, 没借鉴成功iPhone的android也沿用了这样的设计. 于是”300ms的延迟”就成为了一道规范.因此针对这个延迟, 出现了使用tap基础事件去代替click事件. 已经有成熟的类库去帮我们实现了, 这也不展开讲.移动端的事件现在智能手机的普及, 触摸成为了移动设备的交互的核心事件, 主要有这几种常用的事件• Touchstart: 手指触摸屏幕触发(只有第一下才会触发)• Touchmove: 手指在屏幕滑动, 连续触发• Touchend: 手指离开屏幕时触发• Touchcanel: 系统取消touch时候触发(不常用)除了常见的事件属性外, 触摸事件也有自己专有的触摸属性:touches: 跟踪触摸操作的touch对象数组targetTouches: 特定时间目标的touch对象数组changeTouches: 上次触摸改变的touch对象数组其中touches是最为常用的. 它是一个数组, 包含着几个touch对象, 每个touch对象包含如下属性:• clientX: 触摸目标在视口中的x坐标• clientY: 触摸目标在视口中的y坐标• Identifier: 标识触摸的唯一ID• pageX: 触摸目标在页面中的x坐标.• pageY: 触摸目标在页面中的y坐标.• screenX: 触摸目标在屏幕中的x坐标• screenY: 触摸目标在屏幕中的y坐标• target: 触摸的DOM节点目标不过值得注意的是 Android 下可能会有touchend不触发的bug, 已知 Android 4.0, 4.1, 4.4 ~ 5.0都有这个bug.弹性滚动当客户端的页面滚动到底部或顶部的时候, 滚动条会允许我们再向上(下)拖, 松开就会有缓冲反弹的效果, 能有一个良好的用户体验.移动web页面也有这样的能力. 但是滚动有几种情况需要考虑(副作用):body层滚动: (系统特殊化处理)自带弹性滚动, overflow:hidden失效, GIF和定时器暂停局部滚动: 没有弹性滚动, 没有滚动惯性, 不流畅而局部滚动开启弹性滚动的方式也很简单, 只需要在body上添加如下的代码:12345body &#123; /* android 不支持, 但是有类库支持*/ overflow: hidden; -webkit-overflow-scrolling: touch;&#125;上拉刷新, 下拉加载在移动端, 我们常常能看到这种 —— 顶部会允许下拉一小点距离, 松开时页会有弹性的滚动向下, 并且加载数据. 这是一种良好的交互. 多数类库或者插件都能实现这种效果. 可惜本人移动端的经验不足, 没有自己去实现过一次. (再占一个坑吧~总结移动端与PC端的开发主要还是着重点不同吧. 比如在移动开发时, 我们必须要考虑用户的流量, 并不是所有人都在用着好的WIFi来上网.其中如何在这个小屏幕下给用户带来良好的体验也是另外一门学问. 本文只是总结一些常见的东西, 比如移动端适配也还没有讲. 如果以后自己的工作重心倾向移动端的话, 就会继续再更新相关的内容吧~参考资料:饿了么 - 移动端Web开发踩坑之旅: https://zhuanlan.zhihu.com/p/26141351Hello, 移动WEB: https://www.imooc.com/learn/494]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>解决方案</tag>
        <tag>移动端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我们要选用 Vue/React/Angular 进行开发]]></title>
    <url>%2Fblog%2F2018%2F01%2F23%2FJavaScript-%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%94%BE%E5%BC%83JQuery%E8%80%8C%E9%80%89%E7%94%A8Vue-React-Angular%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[JQuery, 曾经从事网页工作者的标配, 以前还没有前端的概念, 但不懂JQuery几乎是会被嘲讽的. 而当下的使用量却逐年降低, 更多的用户转向新兴的 React/Angular/Vue . 今天我们来聊聊, 相比JQuery成熟庞大生态圈, 为什么我们现在开始逐步的放弃 JQuery.前言截止至笔者写这篇文章为止(2018.1), 前端开发的大趋势主要是以下几点:旧浏览器逐渐被淘汰(比如IE8及以下, 主流框架已经放弃了支持)移动端需求的增加用户体验要求变得更高前端架构从传统的后台 MVC 向 RESTFul API + 前端 MV* 迁移众所周知. JQuery只是一个DOM和ajax的封装库. 现在前端项目的日益发展导致JQuery已经不足以承载太多的复杂项目了. JQuery能兼容各种低版本的浏览器这一大优势也在旧浏览器淘汰的路上逐步减弱. 越来越多的开发者开始拥抱新型框架, 它们使前端不太需要关心DOM了, 只需要关心状态.Vue因为我目前主要使用的是Vue的技术栈, 就来说说为什么要选择 Vue 吧.首先, Vue.js是一个库, 并不是一个真正框架(或者说是一个UI层面的框架). 它相比其他两个主流框架 (React/Angular) 来说 Vue 的学习成本相对来说会比较低. 其次 vue 的作者是国人尤雨溪, 因此它对中文的支持会更友好一点(说句题外话, 偶尔能看到有老外吐槽. Vue.js的源码偶尔能看到中文的注释2333).Vue是渐进式框架, 它主要关注的是视图管理. 其核心思想主要是数据驱动和组件化. vue的优势主要有以下几点:侵入性低不对整体构架做过多约束, 方便与其他库或是已有的前端技术栈整合. 比如说当前的项目就是在使用JQuery, 我们也可以将项目移入vue里, 然后逐步的进行改良.vue鼓励模块化因为组件系统是 Vue 的另一个重要概念, 因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用. 这将有利于将界面代码自然分割成更容易维护的模块. 简而言之就是模块化开发, 减少代码的重复性和提高复用性.vue.js比较推荐的是基于commonJs的一个模块方案. 通过webpack这样的模块构建工具, 将一个组件的模块, css和js都写在同一个文件里. Vue本身也有自己脚手架叫做vue-cli, 通过脚手架来帮助我们自动构建项目, 再使用npm进行包管理也是使项目模块化的一种.Vue的语法糖和各种修饰符使得编写JS变得更加的容易. 同时使用一些依赖库, 比如babel使我们能大胆的使用ES6的语法糖. 原先需要封装一个函数的命令, 现在只用一句代码就能解决了. 大大的提高效率.Vue也有自己的生态系统和一个活跃的社区.后记JQuery作为曾经的霸主, 现在市场使用的份额仍然不小. 原因主要是一些老旧的项目仍然在使用着. 其次, 有些时候我们也会遇到需要频繁操作DOM的场景, 再加上JQuery庞大的生态圈. 有很多完善的插件仍然可以使用. 因此, JQuery虽然过时了, 但在未来几年中, 也必然还会有它的份额存在.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>框架</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化 - 回流与重绘]]></title>
    <url>%2Fblog%2F2018%2F01%2F15%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[回流与重绘已经是个老生常谈的问题啦, 但提到性能优化上却又必不可免的提到它. 今天来谈一谈什么是回流与重绘, 我们该如何去测试, 如何针对性的去优化.概述在HTML中, 每一个标签都有自己的盒子模型. 浏览器在解析HTML的过程中会通过一个叫frame的对象对盒子进行操作. 它主要有三个动作:构建frame, 以建立DOM树.reflow, 布局引擎为frame计算图形, 以确定对象位置, 浏览器根据各种样式来计算结果放在它该出现的位置.repaint, 当计算好盒子模型的位置, 大小以及其他属性后, 浏览器就根据各自的特性进行绘制一遍, 显现出来给用户看.回流的代价回流(reflow)就是布局引擎为 frame 计算图形的过程. 但是这里需要我们注意的是, 回流并不仅仅只是在渲染页面的时候会触发, 实际上当你修改某个 css 属性或者操作 DOM 时, 就有可能会触发回流和重绘.也就是说, 我们操作 DOM 实际上是有代价的. 因为 DOM 的改变会导致浏览器重新计算的它的位置和渲染的样式. 我们来做一个假设, 当用户作出某个操作时(比如下拉滚动条), 你的页面中有几十个 DOM 节点同时发生回流绘制, 那这中间消耗的可是浏览器的资源, 可想而知这样页面的性能自然弱了下来.如何触发YaHoo!性能小组总结了一些导致reflow发生的一些因素:调整窗口大小改变字体增加或者移除样式表内容变化，比如用户在 input 框中输入文字, CSS3 动画等激活CSS伪类，比如:hover操作class属性脚本操作DOM计算offsetWidth和offsetHeight属性设置 style 属性的值而repaint只要视觉效果改变了, 就一定会触发repaint. 比如color或者background. 这个很好理解, 如同字面意思一样. 重绘嘛, 就是字体颜色发生了变化浏览器需要重新绘制一遍. 这里值得一提的是, 触发reflow一定会触发repaint, 而触发repaint却不一定会触发reflow.如何调试接下来我们找个页面测试一下, 看看该如何去调试回流与重绘的.先来介绍一下我使用的工具. 我们打开天猫官网, 打开Chrome开发者工具, 找到 More tools =&gt; Rendering 面板， 可以看到以下几个选项:Paint flashing - 高亮(绿色)显示重绘的页面区域Layer boders - 我们知道页面是由多个”图层”组合的, 最终显示给用户看的就是多图层叠加在一起的效果, 区别无非是层级的问题(css的absolute和z-index就可以很好的说明这一点). 勾选这个选项可以显示图层边款, 我们再根据分析哪些不是我们想要的.FPS meter - 玩游戏的同学大概会比较了解这个, 也就是显示绘制每秒帧数，帧速率分布和GPU内存. 这个更多的是用来分析页面交互和动画性能.Scrolling performance issues - 滚动性能问题. 它会高亮显示可能减慢滚动速度的元素(蓝绿色), 其中包括触摸和滚轮事件处理程序以及其他主线程滚动情况.(有兴趣的同学可以在淘宝的官网勾上这个选项, 看下都有啥).这里主要讲Paint flashing. 我们勾上按钮后, 首先能看到天猫的Logo是一个GIF的动态图, 不断闪烁的绿色高亮提醒着我们, 浏览器正在努力的绘制的图形. 这点很好理解, 因为它是动态的, 浏览器需要绘制 gif 的每一帧展示给用户看. 首屏的轮播图也同理, 内容的不断变化触发着回流与重绘.紧接着我们往下滚, 发现左下角的工具栏会随着滚动而发生重绘. 很显然, 这种是使用了fixed定位. 我们知道fixed是相对浏览器窗口进行定位的. 我们滚动一点, 它会重新计算位置, 导致触发回流. 所幸的是fixed定位只会对自己渲染, 而不会影响身边的DOM.接着我们继续测试. 咦? 这几个商品模块好像不太对劲呀? 怎么停止滚动了, 还是会发生不断的重绘? 打开审查元素一看, 模块中有一个 gif 的背景图片. 我们将属性关闭, 发现几个模块的重绘都消失了, 果然是这东西作祟呀. 紧接着我们来检查一下这 gif 是有什么特殊的作用. 将表面的DOM删掉, 还原background属性 —— 噢~原来是一个加载的loading…. 父元素加一个loading动图, 在子元素还没加载出来时显示loading. 加载后由于层级的关系自然就覆盖了上去, 用户自然就看不到了.这种看似巧妙简便的方法实则是在用户看不到的地方在浪费无意义的性能消耗而已. 因此我还特意的去测试了淘宝和京东的情况, 发现这种写法只有天猫才有. 不知道写页面的同学是偷懒还是什么其他的原因, 这里我们可不要养成这种习惯~很多时候坑就是自己挖的最后又自己踩了上去.如何优化到这里我们已经了解了渲染规则后, 那么就可以针对性的进行控制优化 —— 在我们 coding 的时候合理的去避开回流的影响来减少页面的开销.display:none这个属性已经被玩烂了, 该属性的作用就如同它名字一样直观. display就是用来控制显示的状态嘛… 因此很多人喜欢拿它来做隐藏某一个元素的方法. 而背后却忽略了(或者说不知道)它本身所带的回流性能开销(因为会影响节点的位置从而触发回流和重绘).值得庆幸的是, 已经有前行者帮我们踩过很多坑, 我们只需站在巨人的肩上, 借鉴一下前人的经验:如果想设定元素的样式，通过改变元素的class类名 (尽可能在 DOM 树的最里层)避免设置多项内联样式应用元素的动画，使用position属性的fixed值或absolute值(前文说过, 它只会影响自己)权衡平滑和速度避免使用table布局避免使用 CSS 的JavaScript表达式 (仅 IE 浏览器)除此之外, 使用JavaScript想要动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能.总结最后总结一下所学的概念, 回流(reflow), 就是布局引擎为frame计算图形, 确定节点位置的一个步骤. 其中触发回流的原因主要是节点(DOM)大小或者位置的改变才会触发回流. 而重绘, 就是表面的视觉效果改变了, 就会触发重绘. 其中触发了回流紧接着也会触发重绘, 而触发重绘不一定会触发回流(ahh..有点像绕口令).参考资料形象化的reflow: http://www.aoao.org.cn/blog/2008/05/reflow/影响 reflow 的因素及其优化: http://www.planabc.net/2009/04/13/reflow/Gecko Reflow Visualization - mozilla.org: https://www.youtube.com/watch?v=ZTnIxIA5KGw回流与重绘: CSS性能让JavaScript变慢?]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
        <tag>HTML</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化 - 基础的性能优化]]></title>
    <url>%2Fblog%2F2018%2F01%2F13%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[其实很多性能方面的问题, 很多都是从基础就开始影响. 既然如此我们也从最底层逐步分析, 切入每一点小细节~图片优化web早期, 人们有很多想要实现的设计效果出于css或兼容性的限制, 不得不由图片来去实现这种效果. 以现在时代的眼光来说, 无疑是很不优雅的. 撇开图片本身所占用的空间大小外, 本身代码结构就不够语义化. 那么现在这个CSS3都已经普及的年代, 来试着让HTML, CSS属性或SVG用寥寥数行的代码来代替图片来实现效果吧~ 比如一个圆角, 一个渐变的海浪线等.图片格式每一种图片格式都有着自己的特点和优势, 下面来了解一下现在常见的图片格式来”对症下药”.主流的图片格式jpg 全名是JPEG. JPEG图片以24位颜色存储单个位图.png 可移植网络图形格式. 使用png格式的图片更多的是看中它有透明图层, 因为它是256色, 每一色都可以作为透明像素. 但相对的代价就是体积较大(这个可想而知嘛, 图片里面的信息装的多了, 体积自然就大了).GIF 这个稍微有点网络常识的对会知道, 常用于做动画.SVG 可缩放矢量图形. 它能很好的处理图形大小的改变, 放大缩小都不会失真, 适合静态图片展示，高保真文档查看和打印的应用场景. 如今主流浏览器都对它有着很好兼容性支持.没有被Web标准采纳的格式, 但还是值得关注图片格式APNG APNG 是出自 Mozilla 公司下的两位程序员之手, APNG 的出现是为了代替 GIF. 它相较GIF来说有着更好的图片质量, 还支持着透明图层, 同时图片的大小都比 GIF 格式要小.可惜由于出现的较晚, 没有被Web标准给采纳. 截止到笔者写这篇文章的时间(2018.1), Edge这个不合群的家伙在最新版本 Edge 17 仍然还没有支持这个格式, 而chrome 59才开始支持. 因此兼容性不高, 平时也很少能看到这种格式的出现.Webp是出自Google之手, WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。同上面的 APNG 一样, 同样没有被Web标准所采纳. 不过在 caniuse 上能发现, 如今国内大半的用户已经支持了 WebP , 这个未来还是可以小小的期待一下.正确的使用图片格式话归正题, 下面针对不同的使用场景, 来选择正确的图片格式.首先是jpg, 一般不需要透明图层的图片一律使用jpg, 它相对png来说两者的体积之差能有几倍之差.如果需要比较通用的动画的话, GIF是唯一的选择. 如果是相对简单的GIF动画的话, 也可以考虑使用CSS3来实现.如果需要清晰显示颜色丰富的图片或者需要用到透明图层的话, png是一个比较好的选择页面中图片加载方式细心的你或许会发现, 有时在网络慢的情况下, 能看到图片一点一点从上到下的加载. 或者是先模糊, 再清晰的加载方式.实际上这是图片的压缩算法呈现的效果, 逐行显示是离散余弦变化. 而模糊到清晰的是小波算法. 浏览器先读取图片的压缩算法, 再根据算法来选择不同的渲染算法. 下面是某图站的一张大的壁纸加载过程(没有找到小波算法的图, 以后留意到了再回来补)参考资料APNG 那些事常见的图片优化方案CSS-Sprite在页面中, 我们经常能看到一些icon图标. 这些icon实际上占用并不大, 但奈不住多呀. 100个icon的话就要发送一百个HTTP请求. CSS Sprite(精灵). 利用CSS的background-position和background-image属性, 只需要引用一张图片即可. 这极大的节省了HTTP请求量.iconfonticonfont 和上面所提的css-sprite方法类似, 不同的是这个方法是通过引入字体图标的形式. 好处是设置字体图标的颜色或者可以通过设置font-size来改变尺寸, 并且不容易失真.当然, 现在都是使用自动化工具, 都不需要自己手动去调整&lt;picture&gt;标签HTML5新出了一个&lt;picture&gt;标签, 它是一个容器, 用来为其内部特定的&lt;img&gt;提供多样的&lt;source&gt;元素. 浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源. 也就是所谓的响应式图片. 由于兼容性所限, 因此当下并没有广泛使用.media属性允许你提供一个用于给用户代理作为选择&lt;source&gt;元素的依据的媒体查询。如果这个媒体查询匹配结果为false，那么这个&lt;source&gt;元素会被跳过, 使用如下.12345&lt;picture&gt; &lt;source srcset="mdn-logo-smaller.png" media="(max-width: 768px)"&gt; &lt;source srcset="mdn-logo-big.png" media="(min-width: 1000px)"&gt; &lt;img src="mdn-logo-narrow.png" alt="MDN"&gt;&lt;/picture&gt;构建自动化工具实现优化这个一句话说不完, 以后单独拎出来说这东西吧.视频优化当下视频播放器分为两大流派, 一个是HTML5新进入的video标签, 使用方式简洁. 也是现在主流播放方案. 另一个是Flash播放器, 也是过去常用的播放方案. 虽然技术成熟, 插件多, 但也是逐步的将被淘汰. chrome浏览器默认禁止Flash播放器的使用, 就连Edge都要手动开启才能使用.来对比一下两者的优缺点优点缺点video不需要下载额外的资源(如插件什么的)不同浏览器video标签的外观都不一样. 如果要统一的话需要自己写UI来实现Flash兼容性好, 只需要有 Flash player 播放器插件都可以进行播放1. 需要下载额外的 swf 播放文件才可以播放, 浏览器必须要有Flash player插件(回想以前网页老是让你下载Flash的场景)2. Flash player 版本的碎片化3. UI定制需要 as(带有学习成本)当下主流的方案Flash 和 HTML5 两个方案相结合, 组成一个完整的方案. 当下就有几个成熟稳定的库, 如Flowplayer和VideoJs等.视频优化需要的解决问题由于各浏览器UI不同, 设计师会要求我们按照设计图做播放器.在一些视频网站中, 可能产品经理就会让我们实现, 让用户一进来就最先看到视频.浏览器会将所有的多媒体文件放在最后面加载, 无论标签位置放置在什么位置. 解决的方案就是将&lt;link&gt;代替&lt;script&gt;标签引用.常用的前端缓存技术SessionStorage 临时性存储, 数据仅仅在当前的页面生效, 关闭页面后数据就自动清除了. 同时刷新页面不属于”离开页面”的范围, 数据仍然会存在. 现在微信公众号开发常用这种方法来记录用户信息.Cookie, 兼容性最好的本地存储. 缺点是有大小的限制, 而且每次发送请求时, 请求头会带着Cookie一起发送过去.(这里有个问题, 如果在cookie中存储了1M的数据, 那么在请求的时候, 1M的数据也会跟着请求发送到服务端. 这就很大的影响带宽了) 现在基本大多数登录的合法性验证都是用cookie验证的.LocalStorage 特点是持久储存, 操作方法和 SessionStorage 乐视, 也都是操作key-value的形式. 几乎所有现代浏览器都已经支持了. 值得注意的是, LocalStorage 虽然可以永久储存, 但是无法跨浏览器的获取数据的, 还需要注意储存上限.高性能DOM说到高性能的DOM, 就不得不提回流与重绘这个概念. 为此我又专门的写了一篇回流与重绘. 有兴趣的同学可以去看一下.总结上文都只是在基础上的优化. 还有更多项目内工程化的优化就再等咱有时间再更新相关的内容吧~参考资料前端性能优化-通用的缓存SDK: https://www.imooc.com/learn/866]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解之排序二叉树]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是一种具有层级特性的的数据结构. 这些知识虽说在日常工作中不常使用, 但还是有必要让我们去学习一下, 研究其原理是如何运作. 下面将分享自己的一些理解和学习笔记, 来谈一谈什么是排序二叉树.二叉树的定义树(Tree), 是(n&gt;=0)个节点的有限集. 其中 n=0 时, 我们称之为空树. 在一棵非空树中, 只有一个根节点. 在二叉树中, 每个节点最多有两个子节点. 一般称为左节点和右节点(左、右子树).排序二叉树排序二叉树, 又称为二叉查找树. 它有着自己显著的特点:首先一个节点左孩子的值, 一定小于它本身节点的值.一个节点右孩子的值, 一定大于它本身节点的值.左、右孩子(子树)也分别是排序二叉树.构建排序二叉树二叉树大多也是递归定义的. 下面根据排序二叉树的特性来创建一个二叉树.1234567891011121314151617181920212223242526272829303132333435363738394041424344function BinaryTree(key) &#123; var root = null; var Node = function(key) &#123; this.key = key; this.left = null; this.right = null; &#125;; var insertNode = function(node, newNode) &#123; // 对比新旧节点 if (newNode.key &lt; node.key) &#123; // 左节点是否存在 if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; // 右节点是否存在 if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; // 暴露方法, 插入节点 this.insert = function(key) &#123; var newNode = new Node(key); // 根节点是不是空的 if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;;&#125;var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13];var binaryTree = new BinaryTree();nodes.forEach(function(key) &#123; binaryTree.insert(key);&#125;);遍历二叉树我们已经构建好了一个排序二叉树, 现在想要获取二叉树每一个节点的信息, 因此我们需要遍历节点, 对它做一些操作.中序遍历二叉树有三种遍历的方法, 分别是中序遍历, 前序遍历, 后序遍历. 其中中序遍历的顺序是: 左子树 -&gt; 根元素 -&gt; 右子树.对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列. 百闻不如一见, 我们先看看图中的路线图, 整理一下思路先.这里我们需要加入中序遍历的接口, 因此我们在原先代码上继续扩展并运行.控制台会依次输出”1 3 4 6 7 8 10 13 14”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 function BinaryTree(key) &#123; var root = null; var Node = function (key) &#123; this.key = key; this.left = null; this.right = null; &#125; var insertNode = function (node, newNode) &#123; // 对比新旧节点 if (newNode.key &lt; node.key) &#123; // 左节点是否存在 if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;+ // 中序遍历+ var inOrderTraverseNode = function (node, callback) &#123;+ // 递归遍历, 当到最后叶子节点时, 下面没有节点就会直接返回+ if (node !== null) &#123;+ inOrderTraverseNode(node.left, callback);+ callback(node.key);+ inOrderTraverseNode(node.right, callback);+ &#125;+ &#125; // 插入节点 this.insert = function (key) &#123; var newNode = new Node(key) if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;+ /**+ * 中序遍历+ * @param &#123;Function&#125; callback - 决定如何处理节点+ */+ this.inOrderTraverse = function (callback) &#123;+ inOrderTraverseNode(root, callback);+ &#125;+ &#125; // 初始化调用 var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13] var binaryTree = new BinaryTree(); nodes.forEach(function (key) &#123; binaryTree.insert(key) &#125;)+ // 调用成功后输出当前节点+ var callback = function (key) &#123;+ console.log(key)+ &#125; // 中序调用+ binaryTree.inOrderTraverse(callback);前序遍历虽然前面已经有了中序遍历可以遍历节点, 为啥还要浪费精力学前序呢? 诶~这是因为每一种遍历都有自己应用优势.前序遍历最大的作用, 就是如果我们想把已经有了的二叉树重新复制一遍, 使用前序遍历得到的效率相比重新构造一次来说, 两者的差距能差好几倍.前序遍历的顺序与中序遍历有些不同, 前序是以: 根元素 - 左节点 - 右节点的顺序来遍历.这里将遍历的路线图简化了下, 红色输出, 黄色返回上一级, 而绿色则是右子树遍历. 可以看到这是很典型的递归思想. 紧接着我们继续在代码上进行扩展.12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code... // 前序排序 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key) preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) &#125; &#125; /** * 中序遍历 * 暴露中序遍历的方法 * * @param &#123;Function&#125; callback - 决定如何处理节点 */ this.preOrderTraverse = function (callback) &#123; inOrderTraverseNode(root, callback); &#125; binaryTree.preOrderTraverse(callback); // callback会依次打印 8 3 1 6 4 7 10 14 13&#125;后序遍历看到这里, 大家可能已经意识到了. 不同的遍历方法实际上是对当前的节点访问的顺序不一样. 后序遍历的访问的次序就是: 左节点 - 右节点 - 根元素. 它的特点是, 当下面的左右孩子都遍历完了后才会触发回调函数(callback). 因此适用于破坏性操作的情况, 比如删除所有的节点12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code... // 后序排序 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) callback(node.key) &#125; &#125; /** * 后序遍历 * 暴露后序遍历的方法 * * @param &#123;Function&#125; callback - 决定如何处理节点 */ this.postOrderTraverseNode = function (callback) &#123; inOrderTraverseNode(root, callback); &#125; binaryTree.postOrderTraverse(callback); // callback会依次打印 1 4 7 6 3 13 14 10 8&#125;二叉树节点查找找出排序二叉树的最大节点和最小节点实际上也很简单. 前文提过, 根据排序二叉树的特性, 节点左孩子的值, 一定比节点本身小. 节点右孩子的值一定比节点本身大. 因此我们可以根据这个规则来进行查找:123456789101112131415161718192021222324252627282930313233343536373839function BinaryTree(key) &#123; // other code ... var minNode = function (node) &#123; if (node) &#123; // 循环逐级向下查找, 直到没有左孩子(最小节点) while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; // 循环结束后直接反馈 node值 return node.key; &#125; return null; &#125; var maxNode = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.right) &#123; node = node.right; &#125; return node.key; &#125; return null; &#125; // 最小节点 this.min = function () &#123; return minNode(root) &#125; // 最大节点 this.max = function () &#123; return maxNode(root) &#125;&#125;console.log("min node is:" + binaryTree.min()) // 输出1console.log("min node is:" + binaryTree.max()) // 输出 14查找节点是否存在:12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code var searchNode = function (node, key) &#123; if (!node) return false // 依旧是递归思想， key值比node.key值小, 就去查询左子树 if (key &lt; node.key) &#123; return searchNode(node.left, key) &#125; else if (key &gt; node.key) &#123; return searchNode(node.right, key) &#125; else &#123; return true &#125; &#125; this.search = function (key) &#123; return searchNode(root, key) &#125;&#125;console.log(binaryTree.search(7) ? "key 7 is found" : "key 7 is not found")// key 7 is foundconsole.log(binaryTree.search(9) ? "key 9 is found" : "key 9 is not found")// key 9 is not found总结最后将上面的知识总结一下. 首先知道了树的实际上是一种具有层级特性的数据结构, 其中排序二叉树又是一种特殊的树. 它的具有以下几种性质:如果左(孩子)子树不为空, 那么左子树一定比父节点(根节点)的值小.如果右(孩子)子树不为空, 那么右子树一定比父节点(根节点)的值大.其中左、右子树也分别是排序二叉树.紧接着创建了二叉树节点后, 我们需要去遍历这些节点. 遍历的方法又分前序遍历, 中序遍历, 后序遍历. 三者的区别仅在遍历的顺序不同, 但却有着不同优势.前序遍历是唯一一个从根元素开始遍历的, 其顺序为 根 - 左 - 右, 由于它是从根左右开始, 非常适合像复制节点这样的工作.中序遍历的顺序是 左 - 根 - 右, 返回的是一个从小到大(从大到小)排序的好序列.后序遍历的顺序是 左 - 右 - 根, 其特点是执行操作时，肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点.后面还讲到了二叉树节点查找, 利用递归找到二叉树中最小(大)的节点值等.数据结构的学习之路还很长, 以后再一点一点慢慢的深入吧~]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>排序二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Vue项目的构建速度]]></title>
    <url>%2Fblog%2F2018%2F01%2F06%2F%E4%BC%98%E5%8C%96Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[随着项目依赖的增加, 在配合开发的时候听到后端同学的抱怨 build 时间长, 及其影响开发效率和心情. 然后翻阅了相关的资料开启Vue优化之路~项目依赖管理首先检查一下依赖, 去掉对项目没用的依赖, 然后注意开发依赖跟生产依赖不能弄混. 如scss, scss-loader要放在开发依赖中, 因为编译后就不需要了的.. 这一点我以前也有文章提过两者的区别, 有兴趣的同学可以去看看.优化配置修改config/index.js下的文件1234567// 开发环境dev下, 设置为`eval`能提高最快速度, 但是缺点是不能正确显示行号, Debug会有点影响devtool: 'eval'// 关闭生产环境的sourceMap, 不懂是啥的话可以看下面的文章// 阮一峰 - JavaScript Source Map 详解// http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.htmlproductionSourceMap: false在src/mian.js关闭生产环境下的调试信息12345// 关闭生产环境下的调试信息const isDebugMode = process.env.NODE_ENV !== "production";Vue.config.debug = isDebugMode;Vue.config.devtools = isDebugMode;Vue.config.productionTip = isDebugMode;启动 DllPlugin在build文件夹中新增webpac.dll.config.js的js文件. 我们将第三方库抽取出来, 打包dll代码.12345678910111213141516171819202122232425262728293031323334353637const path = require("path");const webpack = require("webpack");// 抽取第三方库const vendors = [ "vue/dist/vue.common.js", "vue-router", "babel-polyfill", "axios", "element-ui", "mint-ui" ]module.exports = &#123; entry: &#123; vendor: vendors &#125;, output: &#123; path: path.join(__dirname, "../static/js"), filename: "[name].dll.js", library: "[name]_[hash]" // vendor.dll.js中暴露出的全局变量名 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, ".", "[name]-manifest.json"), // 此处需要和 output.library 的值一致 name: "[name]_[hash]", context: __dirname &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;;然后我们写一个快捷的调用方式, 在package.json的script上添加一行代码:123456&#123; "scripts": &#123; // other code... "dll": "webpack --config ./build/webpack.dll.config.js" &#125;&#125;这样就可以直接在命令行使用npm run dll, 生成vendor-manifest.json和vendor.dll.js, 前者是库文件的node_modle路径和webpack打包id的映射. 后者是我们打包后的代码库.随后这里我们再安装html-webpack-include-assets-plugin和copy-webpack-plugin这两个插件.1npm insatll --save-dev html-webpack-include-assets-plugin copy-webpack-plugincopy-webpack-plugin是因为项目的需要，我们需要copy到指定的目录下.html-webpack-include-assets-plugin是将vendor.dll.js插入到index.html里.这里值得一提的是, 虽然我们可以直接在根目录的index.html里插入script, 但实际上并不妥当的. 当你npm run dev后, 你会发现在控制台那一行红色的报错, 告诉着你东西找不到, 虽然不影响开发, 但你会看得很难受.紧接着我们在webpack.prod.conf.js上引用我们添加的依赖, 再添加以下代码1234567891011121314151617181920212223// config 是 config/index.js 里的配置// utils.assetsPath 也是 build/utils.js的配置// 这里这样写是为了跟项目统一plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require('./vendor-manifest.json') &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]), // 将 vendor.dll.js 插入HTML里 new HtmlWebpackIncludeAssetsPlugin(&#123; assets: [utils.assetsPath('js/vendor.dll.js')], files: ['index.html'], append: false &#125;),]在命令行进行打包npm run build, 可以看到构建的速度大大的提高啦, 我们的优化也告一段落了~后记最后再优化时说说踩的坑, 给后来人一些提示.Uncaught ReferenceError: vendor_library is not defined - 检查HTML里是否插入vendor.dll.js, 文件是否加载成功, 或者检查是否有路径问题.一些打包后hash不变仍然会被清除重新打包 … 这是因为vue-cli默认配置会直接清空dist文件夹里的所有文件, 你提前放一些js文件进去也是没有用的.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对MVC与MVVM的理解]]></title>
    <url>%2Fblog%2F2018%2F01%2F05%2F%E6%B5%85%E8%B0%88%E5%AF%B9MVC%E4%B8%8EMVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开发中我们常听说MVC, MVP, MVVM这些好像很高端的名词, 那么你了解他实际上是什么东西吗? 下面谈谈对它们的理解.1. MVC其实上面所提的三者都是一种软件架构模式(或者说是一种概念), 其中MVC的历史最为长远.MVC模式可以分成以下三种, 就是模型(module), 界面(View), 控制器(controller). 三者之间的关系.MVC的好处在于视图控制模型分离降低耦合性提高代码重用性和可维护性因为是单向模块化, 不同层各施其职，互不干涉有优点再说说缺点:清晰的构架以代码的复杂性为代价, 对小项目优可能反而降低开发效率.Controller层代码难以复用的, 到后面会变得臃肿.运行效率相对较低, 太过于复杂反而不太适合中小型项目MVVMMVVM(Module-View-ViewModule)的出现主要是为了解决在开发过程中Controller越来越庞大的问题, 它将Controller替换成了ViewModule, 同时改变了通讯模式, 这是MVVM相对于MVC改进的核心思想.其中MVVM的显著特点就是双向绑定. view的变动会自动更新到Model中. 其中当下很流行的Vue框架就是采用了这个模式. 下图的就能很清晰的看的懂ViewModel是如何做的.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git emoji使用指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F31%2FGit-emoji%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[emoji源于日语词汇“絵文字”, 想必大家对它都挺熟悉的吧, 其拟人化的生动形象，已经成为当下流行的表情之一. 接下来讲一下如何规范的在git中使用emoji提高我们项目的可读性吧~使用方式在git commit上加入emoji的二进制符号, 格式为1:emoji1: :emoji2: 本次提交的主要内容如初次提交:1git commit -m " Initialize Repo" 相关规范emoji 表情在提交代码的时候也不能乱用，否则容易造成误解. 因此开源项目gitmoji专门规定了在 github 提交代码时应当遵循的 emoji 规范： emoji emoji代码 说明 (喝彩) tada 初始提交 (调色板) art 改进代码的结构/格式 (闪电) zap 提高性能 (火焰) fire 删除代码或文件 (bug) bug 修复一个错误 (紧急救护车) ambulance 关键修补程序 (闪亮) sparkles 引用新功能 (备忘录) memo 编写文档 (火箭) rocket 部署新功能 (重构) recycle 代码重构 (口红) lipstick 更新UI和样式文件 (复选框) white_check_mark 添加测试 (苹果) apple 修复MacOS上的问题 (企鹅) penguin 修复Linux上的问题 (旗子) checkered_flag 修复Windows上的问题 (机器人) robot 解决Android上的问题 (绿苹果) green_apple 解决iOS上的问题 (书签) bookmark 发布/版本标签 (警告灯) rotating_light 移除 linter 警告 (施工) construction 工作正在进行中 (绿心) green_heart 修复CI构建 (下降) arrow_down 降级依赖关系 (上升) arrow_up 升级依赖关系 (图钉) pushpin 将依赖关系固定到特定的版本 (工人) construction_worker 添加CI构建系统 (上升趋势) chart_with_upwards_trend 添加分析或跟踪代码 (减号) heavy_minus_sign 删除依赖项 (鲸鱼) whale 关于Docker的工作 (加号) heavy_plus_sign 添加一个依赖项 (扳手) wrench 更改配置文件 (铅笔) pencil2 修正错别字 (hankey) hankey 编写需要改进的不好的代码 (回退) rewind 恢复更改 (国际化) globe_with_meridians 国际化和本地化 (合并) twisted_rightwards_arrows 合并分支 (打包) package 更新编译的文件或包 (外星人) alien 由于外部API更改而更新代码 (移动搬家) truck 移动或重命名文件 (页面) page_facing_up 添加或更新许可证 (爆炸性) boom 介绍突破性变化 (便当) bento 添加或更新资产 (好的手势) ok_hand 由于代码审阅更改而更新代码 (无障碍) wheelchair 改善无障碍 (灯泡) bulb 记录源代码 (文字框) speech_balloon 更新文字和文字 (存档箱) card_file_box 执行与数据库相关的更改 (声响) loud_sound 添加日志 (静音) mute 删除日志 (用户) children_crossing 改善用户体验/可用性 (建筑) building_construction 进行架构更改 参考资料: Git emoji: https://gitmoji.carloscuesta.meGithub emoji列表: https://segmentfault.com/a/1190000009649780]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新手不知道的JavaScript技巧 - 条件语句的简写技巧]]></title>
    <url>%2Fblog%2F2017%2F12%2F26%2F%E6%96%B0%E6%89%8B%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[可能入坑不久的同学还会用着if (value !== null || Value !== undefined)这样的判断语句, 而实际上只要理解判定的规则, 善用规则, 就能大大的提高代码的可读性. 接下来让我们深入学习一下.开始大多编程语言中最为常用的一个语句就是if语句, 这种条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句. 它的语法如下:123if (Expression) &#123; statement&#125;其中Expression(表达式/条件)可以是任意表达式或者值.首先它会解析表达式的值如果表达式是无法解析的, 会报ReferenceError的错误并停止. 如果不是则继续.判断值的引用类型, 如果是布尔值, 字符串和符号则继续. null和undefined永远都返回 false.将值传入toBoolean(exprValue)根据下面的规则转换为布尔值.valueBoolean未定义(Undefined)false空值(null)false布尔值(Boolean)返回参数本身数字(Number)如果参数是+0, -0或NaN，则返回false; 否则返回true字符串(String)如果参数是空字符串(长度为零)，则返回false; 否则返回trueSymbol返回 trueObject返回 true这里我们得出undefined, null, NaN, 空字符串, 和数字 0 都是过不了条件语块的规则, 因此我们可以利用这一点来对代码进行简写.1234567891011121314151617181920212223var userName = 'hello';var flag = false;// bad codeif (value != undefined) &#123; ...&#125;// bad codeif (value !== undefined || value !== null || value !== false) &#123; ...&#125;// good codeif (userName) &#123; something...&#125;// flag锁, 利用取反转换布尔值if (!flag) &#123; flag = true; something...&#125;相同的, 也没有必要去使用==规范不推荐的方式去隐式转换类型, 这种规则同样适用于三目运算符, switch等条件运算中去… 这样看起来是不是自己的代码整洁多了呢~后记才疏学浅, 如果有什么说的不对或者需要改进的地方, 可以给我留言大家一起交流. 原创不易, 如果文章对你有帮助的话就随手点个赞鼓励一下呗~参考资料ECMA-262 官方文档http://www.ecma-international.org/ecma-262/6.0/#sec-if-statement]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript原理分析</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥WebSockets]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2F%E5%88%9D%E7%AA%A5Web-Sockets%2F</url>
    <content type="text"><![CDATA[要说最令人津津乐道的新浏览器的API, 就数Web Sockets了. 接下来了解一下这个备受争议的API吧~什么是Web Socket?Web Socket是HTML5出来的一个持久化新协议. 它的目标是在一个单独的持久链接上提供全双工, 让客户端和服务器之间的数据交换变得更加简单.Web Socket是基于HTTP协议来建立连接. 由于使用了自定义的协议, 因此它的URL模式策略也与标准的HTTP不同, 未加密的http://对应着ws://, 而加密的连接的https://也变成https://.那使用Web Socket的好处是什么?能够在客户端和服务器之间发送非常少的数据, 而不用担心HTTP那样字节级的开销. 由于传递的数据很小, 表面看起来会很适用于移动端.主动性大家都知道, 标准HTTP请求是具有被动性的, 如ajax轮询:客户端: “lalala, 帮我看一下我快递有变动吗?”服务端: “没呢, 没变化”客户端: “那现在呢?”服务端: “也还没..”客户端: “那现在呢?”服务端: “还没…”客户端: “那现在呢?”服务端: “好啦好啦, 物流发生变化了, 你看到这里这里了”客户端: “那开始派送了吗?”服务端: “还没…”这样的缺点是什么… ajax轮询需要服务器有很快的处理速度和资源, 而频繁过多的请求可能会报503 Server Unavailable的错误了.而升级为Websocket后, 这时候服务器会主动把东西反馈给你, 如:客户端: “哥们, 咱建立Websocket协议, 需要chat，Websocket协议版本：17（HTTP Request）”服务端：”ok，确认，已升级为Websocket协议(HTTP Protocols Switched)”客户端: “那有啥事的话跟我讲噢”服务端: “balbalbal”服务端: “balbalbal”服务端: “hhhhhhhhhh”服务端: “笑死啦2333333”就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你, 这里场景就适用于聊天室之类的）没有同源限制，客户端可以与任意服务器通信(不用担心跨域)现状与短处既然它存在这种优势为什么如今还是使用的不多呢?HTML5新API嘛… 说到HTML5就不得不考虑到兼容性的问题, WebSocket在各浏览器的兼容性不一致这是问题其一.前文有提过. 相对于PC端, websocket的客户端和服务器之间发送非常少的数据, 表面看起来的确移动端会更有优势. 但是目前以国内的环境来说, 反而不好用. 当网络不稳定的时候开销尤其大.看到这里或许会有人问, 啊? 你之前不是说只需要1次HTTP请求就可以做信息传送了蛮?? 是的, 没错. 大家可能会玩过像阴阳师这样的游戏? 网络一闪, 就会让你重新登录.而长轮询断一次只会卡一秒, 而websocket断了则要重新从认证开始, 那当网络不稳定时, 那开销可想而知.其次就是性能上并没有绝对的优势, 所以当前主流还是标准的HTTP比较多, 而websocket, 据我所知当下适用的场景也只有手游上的使用了.后记websocket的路还很长, 虽然现在使用的不多, 但以后还是可以保留小小的期待. 上文提及资料有部分是来源于网上. 有部分是去咨询了相关的dalao. 才疏学浅若有违权, 或者说的不对的地方望各位指出.参考资料:WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎https://www.zhihu.com/question/20215561/answer/40316953]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>WebSocket</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于点击下拉菜单字体模糊及可能造成boder上下一像素宽度不一的坑]]></title>
    <url>%2Fblog%2F2017%2F12%2F23%2F%E5%85%B3%E4%BA%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E6%A8%A1%E7%B3%8A%E5%8F%8A%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90boder%E4%B8%8A%E4%B8%8B%E4%B8%80%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6%E4%B8%8D%E4%B8%80%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[关于点击下拉菜单会造成文字模糊及boder 1px上下和左右宽度不一致的问题.起始朋友叫帮忙看代码~ 问题是这样的, 当点击下拉菜单时, 整个页面的组件都变模糊一下. 然后border上下的边框能隐约看到会大概溢出那么一点(但是没到一个像素).因为使用了element组件, 大概能想到中间加有transition, 对问题进行排查后发现transform这个属性会对后代元素能产生影响, 将属性删除, 问题解决. 具体影响的原理, 现在占个坑, 以后再深入挖掘…Bug相关的图]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transition</tag>
        <tag>transform</tag>
        <tag>布局bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git pull远程仓库代码冲突]]></title>
    <url>%2Fblog%2F2017%2F12%2F18%2Fgit-pull%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[常用git与远程仓库进行交互, 难免会遇到冲突的问题. 现在来了解一下, 当出现这种情况时, 该要如何处理.起始代码冲突, 无非就是同时有两个人在改动同一个文件所造成的冲突. 当你使用git pull后, git会提示你:123456$ git pullerror: Your local changes to the following files would be overwritten by merge: src/components/page/file.vuePlease commit your changes or stash them before you merge.AbortingUpdating 8e191be..c301cdc这时候你可以使用git stash将本地修改存储起来. 使用git status查看, 是不是干净啦~123456$ git stashSaved working directory and index state WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/testHEAD is now at 8e191be Merge branch 'master' of https://github.com/anran758/test$ git status# On branch masternothing to commit, working directory clean这时再使用将远程仓库的代码pull下来123456 $ git pullUpdating 8e191be..c301cdcFast-forward src/base/fonts/iconfont.eot | Bin 7320 -&gt; 7548 bytes src/components/page/file.vue | 10 +- create mode 100644 static/font_503074_8sfhbdjlucjtt9/iconfont.eot现在要查看现有的储藏, 可以使用git stash list12$ git stash liststash@&#123;0&#125;: WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/test这时我们还原储藏的内容, 使用命令git stash pop &#39;stash@{0}&#39;. 注意这里的要使用引号&#39;stash@{0}&#39;, 因为shell正在使用扩展里的内容, 否则会报一个unknown option: -encodedCommand1234567891011$ git stash pop 'stash@&#123;0&#125;'Auto-merging src/components/page/file.vueOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: src/components/page/film.vueno changes added to commit (use "git add" and/or "git commit -a")之后就可以使用git diff或者利用图形工具, 如sourceTree(可视化git), vscode编辑器上对比代码, 手动解决冲突即可.]]></content>
      <tags>
        <tag>git</tag>
        <tag>代码冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是.gitkeep? 如何在windows下使用命令行创建.gitkeep文件]]></title>
    <url>%2Fblog%2F2017%2F12%2F16%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA-gitkeep%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在一些脚手架上构建项目中, 你或许会留意到某个目录中会有个名为.gitkeep的空文件. 那么这个文件是用来做什么的呢?缘由什么是.gitkeep? 其实是这样的, 当提交的代码时目录中有空文件夹时git会自动忽略掉. 而有时候你就是想留着这个, 以后有用处不想被忽略怎么办呢? 因此, .gitkeep就应运而生了….gitkeep是一个约定俗成的文件名并没有什么特殊规则, 它就相当于一个占位, 让git开始跟踪这个目录.其实任何文件都可以, 只不过大家都遵循这个命名, 会跟具有语义化. 如同字面意思一样…git + keep, 让git保持这个文件夹, 是不是很简单易懂呀?创建文件“哥, 能发个’.gitkeep’给我蛮? 项目中的弄丢了..”“啊? 直接创建一个不就完啦?”“创建不了呀!!系统不准, 会报错提示必须输入文件名”“噢~是有这个限制的, 你用命令行吧”“搜了圈, 好像没有找到在windows创建的方法诶, ““? ? ?”没错, 上面这场景就是让我写这篇博客的主要起因…其实windows下环境创建.开头的文件只能通过命令行的方法, 而且方式也很简单. 只需要输入一行命令即可..1type NUL &gt; .gitkeep这段代码的意思就是创建一个空文件重定向到名为.gitkeep的文件中.gitignore与gitkeep在脚手架构建的项目中, 你也总能在根目录看到名为.giitignore的文件, 那么它和gitkeep又有什么关联呢? 前文有提过, .gitkeep只是约定俗成的一个名称, 而.gitignore是一个特殊文件, 如果你有什么不想提交上去的东西, 如配置了表单密码的配置文件呀什么的, 你可以写进这个文件中, git会自动的忽略掉它.忽略文件的原则是：忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。总结其实像.gitignore带有其他特殊文件还有其他, 如.nojekyll来告诉Github关闭 GitHub Pages 的 Jekyll 相关功能等, 由于实际工作中用的烧, 这里不详谈, 放着让大家去挖掘吧~]]></content>
      <tags>
        <tag>cmd</tag>
        <tag>Githubg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中Axios报错Promise未定义及IE10报语法错误的解决方案]]></title>
    <url>%2Fblog%2F2017%2F12%2F15%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%ADAxios%E6%8A%A5%E9%94%99Pomise%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%8F%8AIE10%E6%8A%A5%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[关于IE11及以下版本无法使用Promise还有IE10下报错的问题Promise未定义 ?在使用Axios开发时, IE11及以下版本报错会报Promise未定义的错误. 这是因为axios本质上是封装了ES6语法的promise,而promise在IE上并不兼容.然而说到js兼容, 这时候我们又能联想到babel.. 没错, babel中有一个工具叫做babel-Polyfill, 它会仿效一个完整的ES2015+环境，并意图运行于一个应用中而不是一个库/工具. 其实食用的方式也很简单.我们将babel-polyfill装进我们项目依赖中. 这里值得注意的是, 安装的时候需要安装到dependency(生产依赖)中, 而不是devDependency(开发依赖)(tips.关于两者的区别, 我以前的文章有专门讲过, 感兴趣的可以看一下)1npm install --save babel-polyfill首先在mian.js的顶部引入import &quot;babel-polyfill&quot;;确保能够最先加载, 随后我们在build目录下webpack.config.js修改配置, 将app使用babel-polyfill进行编译. 这时候我们再重新编译, 就会发现promise未定义的错误就以及消失了12345module.exports = &#123; entry: &#123; app: ["babel-polyfill", './src/main.js'] &#125;&#125;你以为文章到这里就结束了吗…. 随即我们切换到IE10下进行测试. 你会发现, 又冒出了一个报错.. Emmm, 解决一个又来一个, 惊不惊喜意不意外?语法错误当你在IE10下看到提示语法错误的时, 这时候你就得去检查检查package.json下 webpack-dev-server版本是否高于2.6.1. 出现这个报错主要是因为项目中使用了const等语法, 然而IE11以下并不认得ES6语法语法.这个问题只有在开发模式才会出现, 只要es6转码后，打包放到服务器上，就没有问题了.如果你想在开发阶段在IE10下测试你的代码, 你可以选择降低版本到2.6.1上, 问题就解决了.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>IE兼容性错误</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端所能做的SEO]]></title>
    <url>%2Fblog%2F2017%2F12%2F05%2F%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%89%80%E8%83%BD%E5%81%9A%E7%9A%84SEO%2F</url>
    <content type="text"><![CDATA[SEO, 就是搜索引擎优化(Search Engine Optimization)的缩写, SEO优化是专门利用搜索引擎的搜索规则来提高网站在搜索引擎内的自然排名的一种方式. 能对搜索引擎的小蜘蛛更加友好. 那么前端能做哪些SEO的优化呢?SEO基础三要素我们进入某个网页打开调试工具, 在&lt;head&gt;标签里我们能的看到&lt;title&gt;标签, keywords和description的&lt;meta&gt;标签. 就是最基础的SEO三要素.其中&lt;title&gt;标签代表着页面的标题, &lt;meta keywords&gt;是网站的关键字, &lt;meta Description&gt;则是网页的描述, 即对这些关联字进行了扩展.昂, 现在我们知道了这三要素可以SEO优化, 那我们就疯狂的在关键字里加一堆上去, 越多越好?当然, 并不是这样的.这些都有限制的, 内容不可过长, 也不能过分的堆砌关键字, 每个页面的description也应该不同. 比如下方张老师的博客为例.网站构造布局优化对网站布局进行SEO优化, 控制首页链接数量, 扁平化的目录层次(最多三层目录层次), 然后对导航SEO优化.编写语义化代码我们常说, 要养成编写语义化代码的习惯. 那什么是语义化呢? 就是既要人看得懂, 也要机器能理解你的代码.其实我们常用的HTML标签很多都是带语义化的. 如:H1 ~ H6都是用于表示标题UL标签多用于无序列表Ol标签用于有序列表DL标签用于定义数据列表Em, strong表示强调等站内优化&lt;a&gt; - 标签优化, 外链上加上rel=”nofollow”, 让小蜘蛛别往外面爬&lt;h1&gt; - 正文标题使用h1&lt;img&gt; - 标签使用alt说明, alt对图片起着一个注释的作用&lt;strong&gt;``&lt;em&gt;与&lt;b&gt;``&lt;i&gt;标签&lt;strong&gt;是权重标签的代表, 在搜索引擎中能够得到高度的重视, 他能突出关键词, &lt;b&gt;与&lt;strong&gt;的效果是一样的, 但是在SEO中并不会起到很好的效果, 因此不推荐使用.&lt;em&gt;表示斜体, 权重标签的重要度仅次于&lt;strong&gt;.一些布局小技巧重要内容HTML代码放在最前面, 小蜘蛛抓取HTML内容是按照文档流从上往下抓取的. 利用这个特点, 我们可以将重要的HTML放在上面, 然后可以通过CSS来进行布局.重要的内容尽量不要用JS输出, 小蜘蛛看不懂JavaScript~尽少使用iframe框架. 小蜘蛛是不会读取里面的网页的谨慎使用display: none; 小蜘蛛会过滤掉display: none里的内容不断的精简代码, 能使用一个标签就不要用两个标签扩展阅读Chrome - 搜索引擎优化 (SEO) 入门指南总结SEO其实面对的是搜索引擎, 然后搜索引擎再将搜索的结果, 根据权重展现给用户. 文中讲的只是一些基础的知识, 除此之外还有robots.txt, 站外友链等, 这里就不详谈了. 平时前端er日常工作中应该培养好的编程习惯, 了解了SEO的规则, 可以隐性给自己页面提升质量呢~]]></content>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 遍历绑定toggle icon, 动态切换action]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2FVue-v-for-%E9%81%8D%E5%8E%86%E7%BB%91%E5%AE%9Atoggle-icon-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2action%2F</url>
    <content type="text"><![CDATA[在Vue中实现动态绑定toggle action在遍历li标签时, 动态绑定点击事件, 当点击其中一个item时调用函数. 函数内判断是否处于action状态, 是则清除class, 从实现toggle的效果~ 按照这个思路也可以扩展为下拉菜单.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, index) in itemList&quot; @click=&quot;openItem(index)&quot; :key=&quot;item.id&quot; &gt; &#123;&#123; item.desc &#125;&#125; &lt;span class=&quot;icon&quot; :class=&quot;&#123;&apos;action&apos;: actionItem === index&#125;&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; itemList: [ &#123;desc: &apos;item1&apos;&#125;, &#123;desc: &apos;item2&apos;&#125;, &#123;desc: &apos;item3&apos;&#125; ], actionItem: null &#125; &#125;, methods: &#123; openItem (index) &#123; if (this.actionItem === index) &#123; this.actionItem = null &#125; else &#123; this.actionItem = index &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.list &#123; width: 500px; padding: 0; margin: 0 auto; text-align: left;&#125;.list li &#123; position: relative; margin: 14px 0; padding: 10px; border-bottom: 1px solid #ccc; list-style: none; cursor: pointer;&#125;.list .icon &#123; position: absolute; right: 10px; width: 0; height: 0px; border: 10px solid; border-color: #aaa transparent transparent transparent;&#125;.list .action &#123; border-color: rgb(254,0,0); border-radius: 50%;&#125;&lt;/style&gt;初次点击, action触发, 再次点击清除action]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包中的 install --save 和 install --save-dev之间到底有区别]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2F%E8%B0%88%E8%B0%88npm%E5%8C%85%E9%87%8C%E7%9A%84%20install%20--save%20%E5%92%8C%20install%20--save-dev%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当我们使用npm进行开发时经常能遇到需要安装依赖包, 那么npm install --save和npm install --save-dev之间到底有什么区别呢? 现在来探究一番.install –save-dev实际上--save-dev是开发时候所依赖的东西，如我们想添加自动添加前缀, 那么就安装autoprefixer到开发依赖去. 也就是编译打包后autoprefixer已经帮我们添加了相应的浏览器前缀, 那么我们之后就不需要依赖他了. 所以1npm install babel --save-dev在这里我们可以看到已经放进package.json中的devDependencies(开发依赖)中去了.install –save--save就是你发布之后还依赖的东西。 如果编译打包后还需要依赖的库, 如vue, 所以就放进了dependencies中(生产依赖).两者需要安装的依赖其实都可以在package.json中手动输入相应的库和版本号, 然后使用npm install就能进行安装package.json中的所有依赖了~]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JavaScript删除全部的微博]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2F%E4%BD%BF%E7%94%A8JavaScript%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E7%9A%84%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[生活中常常会遇到一些繁琐重复而又没有意义的东西, 所以常有人说, 作为一个程序员, 应该避免做重复没意义的事, 我们学习编程最终的目的之一无非也是偷懒….. 能让自动的就坚决不手动. 当然, 除了在学习中自己造一些有意义的轮子除外. 今天就利用一些自己所学的知识去解决生活上的一些麻烦. 比如..自动删光微博黑历史~开始打开chrome浏览器(其他非IE现代浏览器都可以), 进入我的主页, 然后按下F12进入控制台.原理分析首先这次只是单纯的想通过JavaScript批量删除全部微博代替手动而已, 那么就简单了. 我们只需要模仿点击删除的动作.找到删除微博的key, 选中DOM元素, 这里我们可以看到菜单a标签中有一个属性action-type=&quot;fl_menu, 在控制台进使用document.querySelectorAll进行测试输出, 可以看到是一个NodeList的类数组, 分别对应着页面每一个fl_menu.点击menu弹出下拉菜单, 继续用同样的方法分析节点, 找出一个表示用于删除的属性. 一般来说, 一个合格的程序员都懂得编写语义化的代码, 这里先推测action-type=&quot;feed_list_delete这个属性是专属删除微博的属性, 使用document.querySelector将代码在控制台上测试输出. 获取到页面中第一个delete DOM, 模拟点击后弹出一个确定框, 再次使用相同的方法确定即可.代码实现一般网站都会限制用户频繁操作, 这里我们使用setTimeout, 测试一个weibo能够容忍的一个操作频率(可能还跟网速有关).12345678910111213141516171819202122232425window.onload = (function() &#123; // 经测试, 750ms是一个较快较稳定的频率, 效率过快会弹警告. var timer = setTimeout(Delete, 750); var item = 0; function Delete() &#123; /* 这里需要停止定时器等待加载, 请求XHR进行加载剩余微博. * 这里是微博的一个限制, 当页面中不存在相应的DOM, 就进行页面刷新. */ if (item &gt; 15) &#123; item = 0; clearTimeout(timer); return timer = setTimeout(Delete, 15000); &#125; // 模拟点击 document.querySelector('a[action-type="fl_menu"]').click(); document.querySelector('a[action-type="feed_list_delete"]').click(); document.querySelector('a[action-type="ok"]').click(); ++item; console.log(`已成功删除了$&#123;item&#125;项`); timer = setTimeout(Delete, 750); &#125;&#125;)();总结这样我们想要的效果就实现了.省去了一条一条删的人力, 又能运用到自己所学的知识. 其实代码代码也很简单, 无非是用到了setTimeout重复去递归调用而已. 要注意的是querySelector, 和querySelector都是IE9+的API, 在这里没有去考虑对IE的兼容, 并且也没有必要.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript深入理解-裁剪图片效果(选取框)]]></title>
    <url>%2Fblog%2F2017%2F11%2F17%2FJavascript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在生活中我们时常能看到这种图片裁剪的效果, 那么他实际上底层的原理是怎么实现的呢? 让我们深入的解剖一下.原理分析首先我们先将视图一分为三, 理解为三个层级叠加在一起的仰视图.最上面是可拖动的选择窗口中间待剪辑的可视窗口底层是一张opacity: .5的背景图片基础结构我们这里主要讲JavaScript, HTML与css就简要的过一下.首先HTML基本结构是两张相同的结构, 两张图片分别是调整过透明度的底图和一张被裁剪过了的中间层.mainBox包裹着选择的小方块square,相对定位于image在最上面一层.123456789101112131415161718&lt;!-- index.html --&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image1"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image2"&gt; &lt;div id="mainBox" class="main"&gt; &lt;div class="square left-up"&gt;&lt;/div&gt; &lt;div class="square up"&gt;&lt;/div&gt; &lt;div class="square right-up"&gt;&lt;/div&gt; &lt;div class="square right"&gt;&lt;/div&gt; &lt;div class="square right-down"&gt;&lt;/div&gt; &lt;div class="square down"&gt;&lt;/div&gt; &lt;div class="square left-down"&gt;&lt;/div&gt; &lt;div class="square left"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;123456789101112131415161718192021222324/* main.css */body &#123;background: #333;&#125;#box &#123;position: absolute;top: 100px; left: 200px; width: 460px; height: 360px;&#125;#box img &#123;width: 460px;&#125;#box #image1 &#123;opacity: .5;position: absolute; top: 0;left: 0;&#125;#box #image2 &#123;position: absolute; top: 0;left: 0; clip: rect(0, 200px, 200px, 0) &#125;#box .main &#123;position: absolute;border: 1px solid #fff; width: 200px; height: 200px;box-sizing: border-box;&#125;#box .main .square &#123;position: absolute; width: 8px;height: 8px; background: #fff&#125;#box .main .left-up&#123;left: -4px;top: -4px;cursor: nw-resize;&#125;#box .main .up&#123;left: 50%;top: -4px;margin-left: -4px;cursor: n-resize&#125;#box .main .right-up&#123;right: -4px;top: -4px;cursor: ne-resize&#125;#box .main .right&#123;right: -4px;top: 50%;margin-top: -4px;cursor: e-resize&#125;#box .main .right-down&#123;right: -4px;bottom: -4px;cursor: se-resize&#125;#box .main .down&#123;left: 50%;bottom: -4px;margin-left: -4px;cursor: s-resize&#125;#box .main .left-down&#123;left: -4px;bottom: -4px;cursor: sw-resize&#125;#box .main .left&#123;top: 50%;left: -4px;margin-top: -4px;cursor: w-resize&#125;#box &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125;JavaScript实现ESMAScript并没有提供可拖动的API, 那我们先来思考一下, 该如何实现拖动的功能~ 最上层有9个小方块(Square), 分别代表着不同方向的边界, 拖动这个边界, 无非需要实现这下面的底层步骤.鼠标落下(MouseDown) =&gt; 鼠标拖动 =&gt; 松开鼠标(MouseUp).先创建一个clipImage函数作为入口函数, 主要获取目标元素和生成DOM节点(后面讲), 绑定事件.先给小方块绑定一个鼠标落下事件(mousedown), 当触发事件(MouseEvent)时, 监听器调用onMousedown函数.onMousedown函数中, 接受四个参数e事件, box目标元素, ctrl小方块的方向, type属性, 主要是用来记录数据并暴露给全局变量进行通讯.12345678910111213141516171819202122232425262728293031;(function() &#123; // Util工具函数 var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; // "全局变量", 记录状态 var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var right = util.$('#box .main .right'); // Add mouse down event up.addEventListener('mousedown', function(e) &#123; onMousedown(e, box, up, 'up'); &#125;); function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 将接受到的信息暴露出去. _MainBox = box; _MainCtrl = ctrl; _MainType = type; &#125;&#125;)();紧接着来计算拖动的距离, 在onMouseDown函数上将moving拖动标记设为1(true也行).判断拖动的标记是否启动, 创建getPosition函数获取元素相对于页面左/上边的偏移量用于计算拖动的偏移量. 如下图.12345678910111213141516171819202122232425262728293031323334353637383940414243444546//初始化var moving = 0;function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; _MainBox = box; _MainCtrl = ctrl; _MainType = type; // 移动计算偏移量并设置到box上 moving = 1;&#125;// 获取元素相对于文档的距离function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;;&#125;// 监听鼠标相对于页面的坐标document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var addWidth, addHeight; var width = _MainBox.offsetWidth; // 相对于屏幕左/上的距离 var boxX = getPosition(_MainBox).left; switch(_MainType) &#123; case "right": addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; break; &#125; &#125;&#125;;紧接着我们会发现虽然实现了拖动的效果, 但是松开鼠标box宽度还是会随着鼠标变化. 这是因为还没有重置标记. 随即监听鼠标松开事件(MouseUp). 单边拖动就完成啦~12345// 鼠标松开document.onmouseup = function() &#123; // reset moving = 0;&#125;;整理归纳我们将switch里的代码整理出来. 装进函数里去调用. 相续的将各个方向也加上, 原理也是同理. 值得注意的是将右面和下面要加上box的宽高才能计算出来. 剩下四个边角, 如左上什么的其实就是同时调用正方位的两个函数实现的实现起来. 然后拖动功能就大功告成啦~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215;(function() &#123; var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var up = util.$('#box .main .up'); var down = util.$('#box .main .down'); var right = util.$('#box .main .right'); var rightUp = util.$('#box .main .right-up'); var rightDown = util.$('#box .main .right-down'); var left = util.$('#box .main .left'); var leftUp = util.$('#box .main .left-up'); var leftDown = util.$('#box .main .left-down'); // Add mouse down event right.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, right, 'right'); &#125;); up.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, up, 'up'); &#125;); down.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, down, 'down'); &#125;); left.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, left, 'left'); &#125;); leftUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftUp, 'leftUp'); &#125;); leftDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftDown, 'leftDown'); &#125;); rightUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightUp, 'rightUp'); &#125;); rightDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightDown, 'rightDown'); &#125;); &#125; /** * [onMousedown description] Mouse down event * @param &#123;[type]&#125; e [Event] * @param &#123;[type]&#125; box [target vessel] * @param &#123;[type]&#125; ctrl [Square DOM node] * @param &#123;[type]&#125; type [Square direction] */ function onMousedown(e, box, ctrl, type) &#123; _MainBox = box; _MainCtrl = ctrl; _MainType = type; moving = 1; &#125; // 获取元素相对于左边的距离 function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;; &#125; // 鼠标移动 document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var height = _MainBox.offsetHeight; // 相对于屏幕左/上的距离 var boxY = getPosition(_MainBox).top; switch(_MainType) &#123; case "right": right(e); break; case "up": up(e); break; case "down": down(e); break; case "left": left(e); break; case "leftUp": leftUp(e); break; case "leftDown": leftDown(e); break; case "rightUp": rightUp(e); break; case "rightDown": rightDown(e); break; &#125; &#125; &#125;; // 鼠标松开 document.onmouseup = function() &#123; moving = 0; &#125;; function right(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; &#125; function up(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; &#125; function down(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; &#125; function left(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = boxX - e.clientX; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = boxY - e.clientY; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function rightUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125; function rightDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125;&#125;)();&lt;– 努力填坑中~ –&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过sourcetree实现远程仓库与本地仓库关联]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2F%E9%80%9A%E8%BF%87sourcetree%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率.&emsp;&emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联.步骤&emsp;首先把本地仓库初始化.&emsp;再添加到sourcetree上&emsp;进入github.com -&gt; your profile -&gt; repositories(仓库) -&gt; New&emsp;填写仓库信息, 复制仓库链接&emsp;设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定&emsp;然后就可以提交到github了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>sourcetree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Normalize与reset]]></title>
    <url>%2Fblog%2F2017%2F10%2F15%2F%E6%B5%85%E8%B0%88Normalize%E4%B8%8Ereset%2F</url>
    <content type="text"><![CDATA[前言: 在一次开发的时候, 发现团队中的小伙伴对normalize与reset都持有不同分歧. 趁着这事来谈谈, normalize与reset都有什么区别, 该如何取舍.resetreset, 顾名思义就是重置的意思. 最早的一份CSS reset来自Tantek的undohtml.css, Tantek根据自己的需要，对浏览器的默认样式进行了一些重置。早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题, reset 的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”.此后国内出现* {margin: 0, padding: 0}这种暴力清除全部样式的reset出现.normalizeNormalize, 从字面上也理解也就是使其正常化. 这是css reset的一个代替方案.Normalize相对「平和」, 注重通用的方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。创造normalize.css的目的主要是:保护有用的浏览器默认样式而不是完全去掉它们一般化的样式：为大部分HTML元素提供修复浏览器自身的bug并保证各浏览器的一致性优化CSS可用性：用一些小技巧解释代码：用注释和详细的文档来相比两者的利弊那么相对来说, 两者之间又有什么区别呢? 这里引用一下知乎用户的回答.CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理，简单粗暴地一视同仁是不好的。body 那一圈确实挤压了页面的生存空间，那就改掉。士农工商，谁有谁的作用，给他们制定个规范，确保他们在任何浏览器里都干好自己的活儿。然而在实际项目中, 为了还原设计图我们并不需要这种自带特性, 因此可以根据项目的需求将我们常用的标签进格式化, 但也不是跟传统的reset那样粗暴.因为传统的reset的很多清除默认样式是无意义的, 是浪费性能的. 就比如&lt;li&gt;, 人家生来就没有margin padding, 干嘛非要给人家加个margin: 0上去呀??? h1~h6标签虽然有margin没有padding呀! 也不要一棒子全打死啦! 其实这是不严谨的态度.以下的代码可以作为针对项目需求的进行调整. 这样看下去是不是舒服简洁多了呢? 也减少了很多无意义的性能损耗何乐而不为呢.1234567891011121314151617181920212223242526 body, dl, dd, h1, h2, h3, h4, h5, h6, p, form, ol, ul &#123; margin: 0;&#125;ol, ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none;&#125;body &#123; font: 14px/1.6 Monda,PingFang SC,Microsoft YaHei,sans-serif;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: block;&#125;.clearfix:after &#123; clear: both;&#125;参考资料:Normalize.css 与传统的 CSS Reset 有哪些区别？normalize、reset与base关于CSS Reset 那些事（一）之 历史演变与Normalize.css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-常用速查的正则表达式]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2FJavaScript-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[自己收集了一套针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效.Tips：在本文找想要的正则时，可以尝试使用浏览器的快速查询功能。Ctrl + F输入关键字能提高查询的效率哟~常见的表单验证1234567891011121314151617// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符var passwordReg = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/;// 匹配邮箱地址var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/// 中国六位数的邮政编码var postalCode = /^\d&#123;6&#125;$/// 匹配15~18位身份证var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/网络相关12345678//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$///Reg Hex颜色正则var cPattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/// URL正则var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;联系方式1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/// 国内常见var phone = /^1[3|5|8|9]\d&#123;9&#125;$/// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/匹配特定数字1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\d*$/// 匹配负整数var reg = /^-[1-9]\d*$/// 匹配整数var reg = /^-?[1-9]\d*$/// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\d*|0$/// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\d*|0$/// 匹配正浮点数var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/ // 匹配负浮点数var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/// 匹配浮点数var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/字符串相关1234567891011121314151617181920212223// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/// 匹配由数字、26个英文字母或者下划线组成的字符串var reg = /^\w+$/// 匹配空白行的正则表达式var reg = /\n\s*\r/// 匹配首尾空白字符的正则表达式var reg = /^\s*|\s*$/// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\x00-\xff]/`以后将正则表达式的更新都在我的新repo - Front-End-Lab 中. 求关注求支持呀~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
