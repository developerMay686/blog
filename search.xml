<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优化Vue项目的构建速度]]></title>
    <url>%2Fblog%2F2018%2F01%2F06%2F%E4%BC%98%E5%8C%96Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[随着项目依赖的增加, 在配合开发的时候听到后端同学的抱怨 build 时间长, 及其影响开发效率和心情. 然后翻阅了相关的资料开启Vue优化之路~ ##项目依赖管理 首先检查一下依赖, 去掉对项目没用的依赖, 然后注意开发依赖跟生产依赖不能弄混. 如scss, scss-loader要放在开发依赖中, 因为编译后就不需要了的.. 这一点我以前也有文章提过两者的区别, 有兴趣的同学可以去看看. ##优化配置 修改config/index.js下的文件 1234567// 开发环境dev下, 设置为`eval`能提高最快速度, 但是缺点是不能正确显示行号, Debug会有点影响devtool: 'eval'// 关闭生产环境的sourceMap, 不懂是啥的话可以看下面的文章// 阮一峰 - JavaScript Source Map 详解// http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.htmlproductionSourceMap: false 在src/mian.js关闭生产环境下的调试信息 12345// 关闭生产环境下的调试信息const isDebugMode = process.env.NODE_ENV !== "production";Vue.config.debug = isDebugMode;Vue.config.devtools = isDebugMode;Vue.config.productionTip = isDebugMode; 启动 DllPlugin在build文件夹中新增webpac.dll.config.js的js文件. 我们将第三方库抽取出来, 打包dll代码. 12345678910111213141516171819202122232425262728293031323334353637const path = require("path");const webpack = require("webpack");// 抽取第三方库const vendors = [ "vue/dist/vue.common.js", "vue-router", "babel-polyfill", "axios", "element-ui", "mint-ui" ]module.exports = &#123; entry: &#123; vendor: vendors &#125;, output: &#123; path: path.join(__dirname, "../static/js"), filename: "[name].dll.js", library: "[name]_[hash]" // vendor.dll.js中暴露出的全局变量名 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, ".", "[name]-manifest.json"), // 此处需要和 output.library 的值一致 name: "[name]_[hash]", context: __dirname &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 然后我们写一个快捷的调用方式, 在package.json的script上添加一行代码:123456&#123; "scripts": &#123; // other code... "dll": "webpack --config ./build/webpack.dll.config.js" &#125;&#125; 这样就可以直接在命令行使用npm run dll, 生成vendor-manifest.json和vendor.dll.js, 前者是库文件的node_modle路径和webpack打包id的映射. 后者是我们打包后的代码库. 随后这里我们再安装html-webpack-include-assets-plugin和copy-webpack-plugin这两个插件.1npm insatll --save-dev html-webpack-include-assets-plugin copy-webpack-plugin copy-webpack-plugin是因为项目的需要，我们需要copy到指定的目录下.html-webpack-include-assets-plugin是将vendor.dll.js插入到index.html里. 这里值得一提的是, 虽然我们可以直接在根目录的index.html里插入script, 但实际上并不妥当的. 当你npm run dev后, 你会发现在控制台那一行红色的报错, 告诉着你东西找不到, 虽然不影响开发, 但你会看得很难受. 紧接着我们在webpack.prod.conf.js上引用我们添加的依赖, 再添加以下代码1234567891011121314151617181920212223// config 是 config/index.js 里的配置// utils.assetsPath 也是 build/utils.js的配置// 这里这样写是为了跟项目统一plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require('./vendor-manifest.json') &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]), // 将 vendor.dll.js 插入HTML里 new HtmlWebpackIncludeAssetsPlugin(&#123; assets: [utils.assetsPath('js/vendor.dll.js')], files: ['index.html'], append: false &#125;),] 在命令行进行打包npm run build, 可以看到构建的速度大大的提高啦, 我们的优化也告一段落了~ 后记最后再优化时说说踩的坑, 给后来人一些提示. Uncaught ReferenceError: vendor_library is not defined - 检查HTML里是否插入vendor.dll.js, 文件是否加载成功, 或者检查是否有路径问题. 一些打包后hash不变仍然会被清除重新打包 … 这是因为vue-cli默认配置会直接清空dist文件夹里的所有文件, 你提前放一些js文件进去也是没有用的.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对MVC与MVVM的理解]]></title>
    <url>%2Fblog%2F2018%2F01%2F05%2F%E6%B5%85%E8%B0%88%E5%AF%B9MVC%E4%B8%8EMVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开发中我们常听说MVC, MVP, MVVM这些好像很高端的名词, 那么你了解他实际上是什么东西吗? 下面谈谈对它们的理解. 1. MVC其实上面所提的三者都是一种软件架构模式(或者说是一种概念), 其中MVC的历史最为长远. MVC模式可以分成以下三种, 就是模型(module), 界面(View), 控制器(controller). 三者之间的关系. MVC的好处在于 视图控制模型分离降低耦合性 提高代码重用性和可维护性 因为是单向模块化, 不同层各施其职，互不干涉 有优点再说说缺点: 清晰的构架以代码的复杂性为代价, 对小项目优可能反而降低开发效率. Controller层代码难以复用的, 到后面会变得臃肿. 运行效率相对较低, 太过于复杂反而不太适合中小型项目 MVVMMVVM(Module-View-ViewModule)的出现主要是为了解决在开发过程中Controller越来越庞大的问题, 它将Controller替换成了ViewModule, 同时改变了通讯模式, 这是MVVM相对于MVC改进的核心思想. 其中MVVM的显著特点就是双向绑定. view的变动会自动更新到Model中. 其中当下很流行的Vue框架就是采用了这个模式. 下图的就能很清晰的看的懂ViewModel是如何做的.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git emoji使用指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F31%2FGit-emoji%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[emoji源于日语词汇“絵文字”, 想必大家对它都挺熟悉的吧, 其拟人化的生动形象，已经成为当下流行的表情之一. 接下来讲一下如何规范的在git中使用emoji提高我们项目的可读性吧~ 使用方式在git commit上加入emoji的二进制符号, 格式为1:emoji1: :emoji2: 本次提交的主要内容 如初次提交:1git commit -m " Initialize Repo" 相关规范emoji 表情在提交代码的时候也不能乱用，否则容易造成误解. 因此开源项目gitmoji专门规定了在 github 提交代码时应当遵循的 emoji 规范： emoji emoji代码 说明 (喝彩) : tada: 初始提交 (调色板) &lt;img class=&quot;github-emoji&quot; title=&quot;art&quot; alt=&quot;art&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3a8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 改进代码的结构/格式 (闪电) &lt;img class=&quot;github-emoji&quot; title=&quot;zap&quot; alt=&quot;zap&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/26a1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 提高性能 (火焰) &lt;img class=&quot;github-emoji&quot; title=&quot;fire&quot; alt=&quot;fire&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 删除代码或文件 (bug) &lt;img class=&quot;github-emoji&quot; title=&quot;bug&quot; alt=&quot;bug&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f41b.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复一个错误 (紧急救护车) &lt;img class=&quot;github-emoji&quot; title=&quot;ambulance&quot; alt=&quot;ambulance&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f691.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 关键修补程序 (闪亮) &lt;img class=&quot;github-emoji&quot; title=&quot;sparkles&quot; alt=&quot;sparkles&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2728.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 引用新功能 (备忘录) &lt;img class=&quot;github-emoji&quot; title=&quot;memo&quot; alt=&quot;memo&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4dd.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 编写文档 (火箭) &lt;img class=&quot;github-emoji&quot; title=&quot;rocket&quot; alt=&quot;rocket&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f680.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 部署新功能 (重构) &lt;img class=&quot;github-emoji&quot; title=&quot;recycle&quot; alt=&quot;recycle&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/267b.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 代码重构 (口红) &lt;img class=&quot;github-emoji&quot; title=&quot;lipstick&quot; alt=&quot;lipstick&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f484.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更新UI和样式文件 (复选框) &lt;img class=&quot;github-emoji&quot; title=&quot;white_check_mark&quot; alt=&quot;white_check_mark&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加测试 (苹果) &lt;img class=&quot;github-emoji&quot; title=&quot;apple&quot; alt=&quot;apple&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f34e.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复MacOS上的问题 (企鹅) &lt;img class=&quot;github-emoji&quot; title=&quot;penguin&quot; alt=&quot;penguin&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f427.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复Linux上的问题 (旗子) &lt;img class=&quot;github-emoji&quot; title=&quot;checkered_flag&quot; alt=&quot;checkered_flag&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3c1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复Windows上的问题 (机器人) &lt;img class=&quot;github-emoji&quot; title=&quot;robot&quot; alt=&quot;robot&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f916.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 解决Android上的问题 (绿苹果) &lt;img class=&quot;github-emoji&quot; title=&quot;green_apple&quot; alt=&quot;green_apple&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f34f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 解决iOS上的问题 (书签) &lt;img class=&quot;github-emoji&quot; title=&quot;bookmark&quot; alt=&quot;bookmark&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f516.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 发布/版本标签 (警告灯) &lt;img class=&quot;github-emoji&quot; title=&quot;rotating_light&quot; alt=&quot;rotating_light&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 移除 linter 警告 (施工) &lt;img class=&quot;github-emoji&quot; title=&quot;construction&quot; alt=&quot;construction&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a7.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 工作正在进行中 (绿心) &lt;img class=&quot;github-emoji&quot; title=&quot;green_heart&quot; alt=&quot;green_heart&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复CI构建 (下降) &lt;img class=&quot;github-emoji&quot; title=&quot;arrow_down&quot; alt=&quot;arrow_down&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2b07.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 降级依赖关系 (上升) &lt;img class=&quot;github-emoji&quot; title=&quot;arrow_up&quot; alt=&quot;arrow_up&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2b06.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 升级依赖关系 (图钉) &lt;img class=&quot;github-emoji&quot; title=&quot;pushpin&quot; alt=&quot;pushpin&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4cc.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 将依赖关系固定到特定的版本 (工人) &lt;img class=&quot;github-emoji&quot; title=&quot;construction_worker&quot; alt=&quot;construction_worker&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f477.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加CI构建系统 (上升趋势) &lt;img class=&quot;github-emoji&quot; title=&quot;chart_with_upwards_trend&quot; alt=&quot;chart_with_upwards_trend&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加分析或跟踪代码 (减号) &lt;img class=&quot;github-emoji&quot; title=&quot;heavy_minus_sign&quot; alt=&quot;heavy_minus_sign&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2796.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 删除依赖项 (鲸鱼) &lt;img class=&quot;github-emoji&quot; title=&quot;whale&quot; alt=&quot;whale&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f433.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 关于Docker的工作 (加号) &lt;img class=&quot;github-emoji&quot; title=&quot;heavy_plus_sign&quot; alt=&quot;heavy_plus_sign&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2795.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加一个依赖项 (扳手) &lt;img class=&quot;github-emoji&quot; title=&quot;wrench&quot; alt=&quot;wrench&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f527.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更改配置文件 (铅笔) &lt;img class=&quot;github-emoji&quot; title=&quot;pencil2&quot; alt=&quot;pencil2&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/270f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修正错别字 (hankey) &lt;img class=&quot;github-emoji&quot; title=&quot;hankey&quot; alt=&quot;hankey&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 编写需要改进的不好的代码 (回退) &lt;img class=&quot;github-emoji&quot; title=&quot;rewind&quot; alt=&quot;rewind&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/23ea.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 恢复更改 (国际化) &lt;img class=&quot;github-emoji&quot; title=&quot;globe_with_meridians&quot; alt=&quot;globe_with_meridians&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f310.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 国际化和本地化 (合并) &lt;img class=&quot;github-emoji&quot; title=&quot;twisted_rightwards_arrows&quot; alt=&quot;twisted_rightwards_arrows&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f500.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 合并分支 (打包) &lt;img class=&quot;github-emoji&quot; title=&quot;package&quot; alt=&quot;package&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4e6.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更新编译的文件或包 (外星人) &lt;img class=&quot;github-emoji&quot; title=&quot;alien&quot; alt=&quot;alien&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f47d.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 由于外部API更改而更新代码 (移动搬家) &lt;img class=&quot;github-emoji&quot; title=&quot;truck&quot; alt=&quot;truck&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f69a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 移动或重命名文件 (页面) &lt;img class=&quot;github-emoji&quot; title=&quot;page_facing_up&quot; alt=&quot;page_facing_up&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c4.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加或更新许可证 (爆炸性) &lt;img class=&quot;github-emoji&quot; title=&quot;boom&quot; alt=&quot;boom&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a5.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 介绍突破性变化 (便当) &lt;img class=&quot;github-emoji&quot; title=&quot;bento&quot; alt=&quot;bento&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f371.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加或更新资产 (好的手势) &lt;img class=&quot;github-emoji&quot; title=&quot;ok_hand&quot; alt=&quot;ok_hand&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f44c.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 由于代码审阅更改而更新代码 (无障碍) &lt;img class=&quot;github-emoji&quot; title=&quot;wheelchair&quot; alt=&quot;wheelchair&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/267f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 改善无障碍 (灯泡) &lt;img class=&quot;github-emoji&quot; title=&quot;bulb&quot; alt=&quot;bulb&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 记录源代码 (文字框) &lt;img class=&quot;github-emoji&quot; title=&quot;speech_balloon&quot; alt=&quot;speech_balloon&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4ac.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更新文字和文字 (存档箱) &lt;img class=&quot;github-emoji&quot; title=&quot;card_file_box&quot; alt=&quot;card_file_box&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f5c3.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 执行与数据库相关的更改 (声响) &lt;img class=&quot;github-emoji&quot; title=&quot;loud_sound&quot; alt=&quot;loud_sound&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f50a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加日志 (静音) &lt;img class=&quot;github-emoji&quot; title=&quot;mute&quot; alt=&quot;mute&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f507.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 删除日志 (用户) &lt;img class=&quot;github-emoji&quot; title=&quot;children_crossing&quot; alt=&quot;children_crossing&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6b8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 改善用户体验/可用性 (建筑) &lt;img class=&quot;github-emoji&quot; title=&quot;building_construction&quot; alt=&quot;building_construction&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3d7.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 进行架构更改 参考资料 Git emoji: https://gitmoji.carloscuesta.meGithub emoji列表: https://segmentfault.com/a/1190000009649780]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新手不知道的JavaScript技巧 - 条件语句的简写技巧]]></title>
    <url>%2Fblog%2F2017%2F12%2F26%2F%E6%96%B0%E6%89%8B%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[可能入坑不久的同学还会用着if (value !== null || Value !== undefined)这样的判断语句, 而实际上只要理解判定的规则, 善用规则, 就能大大的提高代码的可读性. 接下来让我们深入学习一下. 开始大多编程语言中最为常用的一个语句就是if语句, 这种条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句. 它的语法如下: 123if (Expression) &#123; statement&#125; 其中Expression(表达式/条件)可以是任意表达式或者值. 首先它会解析表达式的值 如果表达式是无法解析的, 会报ReferenceError的错误并停止. 如果不是则继续. 判断值的引用类型, 如果是布尔值, 字符串和符号则继续. null和undefined永远都返回 false. 将值传入toBoolean(exprValue)根据下面的规则转换为布尔值. value Boolean 未定义(Undefined) false 空值(null) false 布尔值(Boolean) 返回参数本身 数字(Number) 如果参数是+0, -0或NaN，则返回false; 否则返回true 字符串(String) 如果参数是空字符串(长度为零)，则返回false; 否则返回true Symbol 返回 true Object 返回 true 这里我们得出undefined, null, NaN, 空字符串, 和数字 0 都是过不了条件语块的规则, 因此我们可以利用这一点来对代码进行简写. 1234567891011121314151617181920212223var userName = 'hello';var flag = false;// bad codeif (value != undefined) &#123; ...&#125;// bad codeif (value !== undefined || value !== null || value !== false) &#123; ...&#125;// good codeif (userName) &#123; something...&#125;// flag锁, 利用取反转换布尔值if (!flag) &#123; flag = true; something...&#125; 相同的, 也没有必要去使用==规范不推荐的方式去隐式转换类型, 这种规则同样适用于三目运算符, switch等条件运算中去… 这样看起来是不是自己的代码整洁多了呢~ 后记才疏学浅, 如果有什么说的不对或者需要改进的地方, 可以给我留言大家一起交流. 原创不易, 如果文章对你有帮助的话就随手点个赞鼓励一下呗~ 参考资料ECMA-262 官方文档http://www.ecma-international.org/ecma-262/6.0/#sec-if-statement]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript原理分析</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥WebSockets]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2F%E5%88%9D%E7%AA%A5Web-Sockets%2F</url>
    <content type="text"><![CDATA[要说最令人津津乐道的新浏览器的API, 就数Web Sockets了. 接下来了解一下这个备受争议的API吧~ 什么是Web Socket?Web Socket是HTML5出来的一个持久化新协议. 它的目标是在一个单独的持久链接上提供全双工, 让客户端和服务器之间的数据交换变得更加简单. Web Socket是基于HTTP协议来建立连接. 由于使用了自定义的协议, 因此它的URL模式策略也与标准的HTTP不同, 未加密的http://对应着ws://, 而加密的连接的https://也变成https://. 那使用Web Socket的好处是什么? 能够在客户端和服务器之间发送非常少的数据, 而不用担心HTTP那样字节级的开销. 由于传递的数据很小, 表面看起来会很适用于移动端. 主动性大家都知道, 标准HTTP请求是具有被动性的, 如ajax轮询:客户端: “lalala, 帮我看一下我快递有变动吗?”服务端: “没呢, 没变化”客户端: “那现在呢?”服务端: “也还没..”客户端: “那现在呢?”服务端: “还没…”客户端: “那现在呢?”服务端: “好啦好啦, 物流发生变化了, 你看到这里这里了”客户端: “那开始派送了吗?”服务端: “还没…”这样的缺点是什么… ajax轮询需要服务器有很快的处理速度和资源, 而频繁过多的请求可能会报503 Server Unavailable的错误了. 而升级为Websocket后, 这时候服务器会主动把东西反馈给你, 如:客户端: “哥们, 咱建立Websocket协议, 需要chat，Websocket协议版本：17（HTTP Request）”服务端：”ok，确认，已升级为Websocket协议(HTTP Protocols Switched)”客户端: “那有啥事的话跟我讲噢”服务端: “balbalbal”服务端: “balbalbal”服务端: “hhhhhhhhhh”服务端: “笑死啦2333333”就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你, 这里场景就适用于聊天室之类的） 没有同源限制，客户端可以与任意服务器通信(不用担心跨域) 现状与短处既然它存在这种优势为什么如今还是使用的不多呢?HTML5新API嘛… 说到HTML5就不得不考虑到兼容性的问题, WebSocket在各浏览器的兼容性不一致这是问题其一. 前文有提过. 相对于PC端, websocket的客户端和服务器之间发送非常少的数据, 表面看起来的确移动端会更有优势. 但是目前以国内的环境来说, 反而不好用. 当网络不稳定的时候开销尤其大. 看到这里或许会有人问, 啊? 你之前不是说只需要1次HTTP请求就可以做信息传送了蛮?? 是的, 没错. 大家可能会玩过像阴阳师这样的游戏? 网络一闪, 就会让你重新登录.而长轮询断一次只会卡一秒, 而websocket断了则要重新从认证开始, 那当网络不稳定时, 那开销可想而知. 其次就是性能上并没有绝对的优势, 所以当前主流还是标准的HTTP比较多, 而websocket, 据我所知当下适用的场景也只有手游上的使用了. 后记websocket的路还很长, 虽然现在使用的不多, 但以后还是可以保留小小的期待. 上文提及资料有部分是来源于网上. 有部分是去咨询了相关的dalao. 才疏学浅若有违权, 或者说的不对的地方望各位指出. 参考资料:WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎https://www.zhihu.com/question/20215561/answer/40316953]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>WebSocket</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于点击下拉菜单字体模糊及可能造成boder上下一像素宽度不一的坑]]></title>
    <url>%2Fblog%2F2017%2F12%2F23%2F%E5%85%B3%E4%BA%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E6%A8%A1%E7%B3%8A%E5%8F%8A%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90boder%E4%B8%8A%E4%B8%8B%E4%B8%80%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6%E4%B8%8D%E4%B8%80%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[关于点击下拉菜单会造成文字模糊及boder 1px上下和左右宽度不一致的问题. 起始朋友叫帮忙看代码~ 问题是这样的, 当点击下拉菜单时, 整个页面的组件都变模糊一下. 然后border上下的边框能隐约看到会大概溢出那么一点(但是没到一个像素). 因为使用了element组件, 大概能想到中间加有transition, 对问题进行排查后发现transform这个属性会对后代元素能产生影响, 将属性删除, 问题解决. 具体影响的原理, 现在占个坑, 以后再深入挖掘… Bug相关的图]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transition</tag>
        <tag>transform</tag>
        <tag>布局bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git pull远程仓库代码冲突]]></title>
    <url>%2Fblog%2F2017%2F12%2F18%2Fgit-pull%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[常用git与远程仓库进行交互, 难免会遇到冲突的问题. 现在来了解一下, 当出现这种情况时, 该要如何处理. 起始代码冲突, 无非就是同时有两个人在改动同一个文件所造成的冲突. 当你使用git pull后, git会提示你:123456$ git pullerror: Your local changes to the following files would be overwritten by merge: src/components/page/file.vuePlease commit your changes or stash them before you merge.AbortingUpdating 8e191be..c301cdc 这时候你可以使用git stash将本地修改存储起来. 使用git status查看, 是不是干净啦~123456$ git stashSaved working directory and index state WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/testHEAD is now at 8e191be Merge branch 'master' of https://github.com/anran758/test$ git status# On branch masternothing to commit, working directory clean 这时再使用将远程仓库的代码pull下来123456 $ git pullUpdating 8e191be..c301cdcFast-forward src/base/fonts/iconfont.eot | Bin 7320 -&gt; 7548 bytes src/components/page/file.vue | 10 +- create mode 100644 static/font_503074_8sfhbdjlucjtt9/iconfont.eot 现在要查看现有的储藏, 可以使用git stash list12$ git stash liststash@&#123;0&#125;: WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/test 这时我们还原储藏的内容, 使用命令git stash pop &#39;stash@{0}&#39;. 注意这里的要使用引号&#39;stash@{0}&#39;, 因为shell正在使用扩展里的内容, 否则会报一个unknown option: -encodedCommand1234567891011$ git stash pop 'stash@&#123;0&#125;'Auto-merging src/components/page/file.vueOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: src/components/page/film.vueno changes added to commit (use "git add" and/or "git commit -a") 之后就可以使用git diff或者利用图形工具, 如sourceTree(可视化git), vscode编辑器上对比代码, 手动解决冲突即可.]]></content>
      <tags>
        <tag>git</tag>
        <tag>代码冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是.gitkeep? 如何在windows下使用命令行创建.gitkeep文件]]></title>
    <url>%2Fblog%2F2017%2F12%2F16%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA-gitkeep%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在一些脚手架上构建项目中, 你或许会留意到某个目录中会有个名为.gitkeep的空文件. 那么这个文件是用来做什么的呢? 缘由什么是.gitkeep? 其实是这样的, 当提交的代码时目录中有空文件夹时git会自动忽略掉. 而有时候你就是想留着这个, 以后有用处不想被忽略怎么办呢? 因此, .gitkeep就应运而生了… .gitkeep是一个约定俗成的文件名并没有什么特殊规则, 它就相当于一个占位, 让git开始跟踪这个目录.其实任何文件都可以, 只不过大家都遵循这个命名, 会跟具有语义化. 如同字面意思一样…git + keep, 让git保持这个文件夹, 是不是很简单易懂呀? 创建文件 “哥, 能发个’.gitkeep’给我蛮? 项目中的弄丢了..” “啊? 直接创建一个不就完啦?” “创建不了呀!!系统不准, 会报错提示必须输入文件名” “噢~是有这个限制的, 你用命令行吧” “搜了圈, 好像没有找到在windows创建的方法诶, “ “? ? ?” 没错, 上面这场景就是让我写这篇博客的主要起因…其实windows下环境创建.开头的文件只能通过命令行的方法, 而且方式也很简单. 只需要输入一行命令即可..1type NUL &gt; .gitkeep 这段代码的意思就是创建一个空文件重定向到名为.gitkeep的文件中. gitignore与gitkeep在脚手架构建的项目中, 你也总能在根目录看到名为.giitignore的文件, 那么它和gitkeep又有什么关联呢? 前文有提过, .gitkeep只是约定俗成的一个名称, 而.gitignore是一个特殊文件, 如果你有什么不想提交上去的东西, 如配置了表单密码的配置文件呀什么的, 你可以写进这个文件中, git会自动的忽略掉它. 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 总结其实像.gitignore带有其他特殊文件还有其他, 如.nojekyll来告诉Github关闭 GitHub Pages 的 Jekyll 相关功能等, 由于实际工作中用的烧, 这里不详谈, 放着让大家去挖掘吧~]]></content>
      <tags>
        <tag>cmd</tag>
        <tag>Githubg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中Axios报错Promise未定义及IE10报语法错误的解决方案]]></title>
    <url>%2Fblog%2F2017%2F12%2F15%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%ADAxios%E6%8A%A5%E9%94%99Pomise%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%8F%8AIE10%E6%8A%A5%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[关于IE11及以下版本无法使用Promise还有IE10下报错的问题 Promise未定义 ?在使用Axios开发时, IE11及以下版本报错会报Promise未定义的错误. 这是因为axios本质上是封装了ES6语法的promise,而promise在IE上并不兼容. 然而说到js兼容, 这时候我们又能联想到babel.. 没错, babel中有一个工具叫做babel-Polyfill, 它会仿效一个完整的ES2015+环境，并意图运行于一个应用中而不是一个库/工具. 其实食用的方式也很简单. 我们将babel-polyfill装进我们项目依赖中. 这里值得注意的是, 安装的时候需要安装到dependency(生产依赖)中, 而不是devDependency(开发依赖)(tips.关于两者的区别, 我以前的文章有专门讲过, 感兴趣的可以看一下) 1npm install --save babel-polyfill 首先在mian.js的顶部引入import &quot;babel-polyfill&quot;;确保能够最先加载, 随后我们在build目录下webpack.config.js修改配置, 将app使用babel-polyfill进行编译. 这时候我们再重新编译, 就会发现promise未定义的错误就以及消失了12345module.exports = &#123; entry: &#123; app: ["babel-polyfill", './src/main.js'] &#125;&#125; 你以为文章到这里就结束了吗…. 随即我们切换到IE10下进行测试. 你会发现, 又冒出了一个报错.. Emmm, 解决一个又来一个, 惊不惊喜意不意外? 语法错误当你在IE10下看到提示语法错误的时, 这时候你就得去检查检查package.json下 webpack-dev-server版本是否高于2.6.1. 出现这个报错主要是因为项目中使用了const等语法, 然而IE11以下并不认得ES6语法语法.这个问题只有在开发模式才会出现, 只要es6转码后，打包放到服务器上，就没有问题了. 如果你想在开发阶段在IE10下测试你的代码, 你可以选择降低版本到2.6.1上, 问题就解决了.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>IE兼容性错误</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端所能做的SEO]]></title>
    <url>%2Fblog%2F2017%2F12%2F05%2F%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%89%80%E8%83%BD%E5%81%9A%E7%9A%84SEO%2F</url>
    <content type="text"><![CDATA[SEO, 就是搜索引擎优化(Search Engine Optimization)的缩写, SEO优化是专门利用搜索引擎的搜索规则来提高网站在搜索引擎内的自然排名的一种方式. 能对搜索引擎的小蜘蛛更加友好. 那么前端能做哪些SEO的优化呢? SEO基础三要素我们进入某个网页打开调试工具, 在&lt;head&gt;标签里我们能的看到&lt;title&gt;标签, keywords和description的&lt;meta&gt;标签. 就是最基础的SEO三要素. 其中&lt;title&gt;标签代表着页面的标题, &lt;meta keywords&gt;是网站的关键字, &lt;meta Description&gt;则是网页的描述, 即对这些关联字进行了扩展.昂, 现在我们知道了这三要素可以SEO优化, 那我们就疯狂的在关键字里加一堆上去, 越多越好?当然, 并不是这样的.这些都有限制的, 内容不可过长, 也不能过分的堆砌关键字, 每个页面的description也应该不同. 比如下方张老师的博客为例. 网站构造布局优化对网站布局进行SEO优化, 控制首页链接数量, 扁平化的目录层次(最多三层目录层次), 然后对导航SEO优化. 编写语义化代码我们常说, 要养成编写语义化代码的习惯. 那什么是语义化呢? 就是既要人看得懂, 也要机器能理解你的代码.其实我们常用的HTML标签很多都是带语义化的. 如: H1 ~ H6都是用于表示标题 UL标签多用于无序列表 Ol标签用于有序列表 DL标签用于定义数据列表 Em, strong表示强调等 站内优化 &lt;a&gt; - 标签优化, 外链上加上rel=”nofollow”, 让小蜘蛛别往外面爬 &lt;h1&gt; - 正文标题使用h1 &lt;img&gt; - 标签使用alt说明, alt对图片起着一个注释的作用 &lt;strong&gt;``&lt;em&gt;与&lt;b&gt;``&lt;i&gt;标签&lt;strong&gt;是权重标签的代表, 在搜索引擎中能够得到高度的重视, 他能突出关键词, &lt;b&gt;与&lt;strong&gt;的效果是一样的, 但是在SEO中并不会起到很好的效果, 因此不推荐使用.&lt;em&gt;表示斜体, 权重标签的重要度仅次于&lt;strong&gt;. 一些布局小技巧 重要内容HTML代码放在最前面, 小蜘蛛抓取HTML内容是按照文档流从上往下抓取的. 利用这个特点, 我们可以将重要的HTML放在上面, 然后可以通过CSS来进行布局. 重要的内容尽量不要用JS输出, 小蜘蛛看不懂JavaScript~ 尽少使用iframe框架. 小蜘蛛是不会读取里面的网页的 谨慎使用display: none; 小蜘蛛会过滤掉display: none里的内容 不断的精简代码, 能使用一个标签就不要用两个标签 总结SEO其实面对的是搜索引擎, 然后搜索引擎再将搜索的结果, 根据权重展现给用户. 文中讲的只是一些基础的知识, 除此之外还有robots.txt, 站外友链等, 这里就不详谈了. 平时前端er日常工作中应该培养好的编程习惯, 了解了SEO的规则, 可以隐性给自己页面提升质量呢~]]></content>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue "v-for"遍历绑定toggle icon, 动态切换action]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2FVue-v-for-%E9%81%8D%E5%8E%86%E7%BB%91%E5%AE%9Atoggle-icon-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2action%2F</url>
    <content type="text"><![CDATA[在Vue中实现动态绑定toggle action 在遍历li标签时, 动态绑定点击事件, 当点击其中一个item时调用函数. 函数内判断是否处于action状态, 是则清除class, 从实现toggle的效果~ 按照这个思路也可以扩展为下拉菜单. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, index) in itemList&quot; @click=&quot;openItem(index)&quot; :key=&quot;item.id&quot; &gt; &#123;&#123; item.desc &#125;&#125; &lt;span class=&quot;icon&quot; :class=&quot;&#123;&apos;action&apos;: actionItem === index&#125;&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; itemList: [ &#123;desc: &apos;item1&apos;&#125;, &#123;desc: &apos;item2&apos;&#125;, &#123;desc: &apos;item3&apos;&#125; ], actionItem: null &#125; &#125;, methods: &#123; openItem (index) &#123; if (this.actionItem === index) &#123; this.actionItem = null &#125; else &#123; this.actionItem = index &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.list &#123; width: 500px; padding: 0; margin: 0 auto; text-align: left;&#125;.list li &#123; position: relative; margin: 14px 0; padding: 10px; border-bottom: 1px solid #ccc; list-style: none; cursor: pointer;&#125;.list .icon &#123; position: absolute; right: 10px; width: 0; height: 0px; border: 10px solid; border-color: #aaa transparent transparent transparent;&#125;.list .action &#123; border-color: rgb(254,0,0); border-radius: 50%;&#125;&lt;/style&gt; 初次点击, action触发, 再次点击清除action]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包中的 install --save 和 install --save-dev之间到底有区别]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2F%E8%B0%88%E8%B0%88npm%E5%8C%85%E9%87%8C%E7%9A%84%20install%20--save%20%E5%92%8C%20install%20--save-dev%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当我们使用npm进行开发时经常能遇到需要安装依赖包, 那么npm install --save和npm install --save-dev之间到底有什么区别呢? 现在来探究一番. install –save-dev实际上--save-dev是开发时候所依赖的东西，如我们想添加自动添加前缀, 那么就安装autoprefixer到开发依赖去. 也就是编译打包后autoprefixer已经帮我们添加了相应的浏览器前缀, 那么我们之后就不需要依赖他了. 所以1npm install babel --save-dev 在这里我们可以看到已经放进package.json中的devDependencies(开发依赖)中去了. install –save--save就是你发布之后还依赖的东西。 如果编译打包后还需要依赖的库, 如vue, 所以就放进了dependencies中(生产依赖). 两者需要安装的依赖其实都可以在package.json中手动输入相应的库和版本号, 然后使用npm install就能进行安装package.json中的所有依赖了~]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在浏览器地址输入URL回车后，中间发生了什么？]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2F%E5%9C%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近在面试的时候遇到了一道比较经典的面试题, 在Chrome浏览器地址栏输入url, 回车之后会发生什么事?题目很经典, 自己也懂些大概. 不过抱着探究原理的精神. 也查询了相关的知识, 今天就来探讨一下, 浏览器的处理过程是怎么样的~ Start当我们在地址栏输入网址时, 其实就是要向服务器请求我们想要的资源. 1. 解析Url首先开始解析Url, 分析输入的Url还是搜索关键字 2. DNS查询2.1. 浏览器缓存 然后浏览器开始检测域名是否还存在缓存中, 如果缓存没有就gethostbyname库函数进行查询. 2.2 Hosts文件 gethostbyname函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里. 2.3 本地DNS服务器 hosts 中也没有找到的话, 将会向DNS 服务器发送一条DNS查询请求. 2.4 路由缓存 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用JavaScript删除全部的微博]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2F%E4%BD%BF%E7%94%A8JavaScript%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E7%9A%84%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[生活中常常会遇到一些繁琐重复而又没有意义的东西, 所以常有人说, 作为一个程序员, 应该避免做重复没意义的事, 我们学习编程最终的目的之一无非也是偷懒….. 能让自动的就坚决不手动. 当然, 除了在学习中自己造一些有意义的轮子除外. 今天就利用一些自己所学的知识去解决生活上的一些麻烦. 比如..自动删光微博黑历史~ 开始打开chrome浏览器(其他非IE现代浏览器都可以), 进入我的主页, 然后按下F12进入控制台. 原理分析首先这次只是单纯的想通过JavaScript批量删除全部微博代替手动而已, 那么就简单了. 我们只需要模仿点击删除的动作. 找到删除微博的key, 选中DOM元素, 这里我们可以看到菜单a标签中有一个属性action-type=&quot;fl_menu, 在控制台进使用document.querySelectorAll进行测试输出, 可以看到是一个NodeList的类数组, 分别对应着页面每一个fl_menu. 点击menu弹出下拉菜单, 继续用同样的方法分析节点, 找出一个表示用于删除的属性. 一般来说, 一个合格的程序员都懂得编写语义化的代码, 这里先推测action-type=&quot;feed_list_delete这个属性是专属删除微博的属性, 使用document.querySelector将代码在控制台上测试输出. 获取到页面中第一个delete DOM, 模拟点击后弹出一个确定框, 再次使用相同的方法确定即可. 代码实现一般网站都会限制用户频繁操作, 这里我们使用setTimeout, 测试一个weibo能够容忍的一个操作频率(可能还跟网速有关).12345678910111213141516171819202122232425window.onload = (function() &#123; // 经测试, 750ms是一个较快较稳定的频率, 效率过快会弹警告. var timer = setTimeout(Delete, 750); var item = 0; function Delete() &#123; /* 这里需要停止定时器等待加载, 请求XHR进行加载剩余微博. * 这里是微博的一个限制, 当页面中不存在相应的DOM, 就进行页面刷新. */ if (item &gt; 15) &#123; item = 0; clearTimeout(timer); return timer = setTimeout(Delete, 15000); &#125; // 模拟点击 document.querySelector('a[action-type="fl_menu"]').click(); document.querySelector('a[action-type="feed_list_delete"]').click(); document.querySelector('a[action-type="ok"]').click(); ++item; console.log(`已成功删除了$&#123;item&#125;项`); timer = setTimeout(Delete, 750); &#125;&#125;)(); 总结这样我们想要的效果就实现了.省去了一条一条删的人力, 又能运用到自己所学的知识. 其实代码代码也很简单, 无非是用到了setTimeout重复去递归调用而已. 要注意的是querySelector, 和querySelector都是IE9+的API, 在这里没有去考虑对IE的兼容, 并且也没有必要.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript深入理解-裁剪图片效果(选取框)]]></title>
    <url>%2Fblog%2F2017%2F11%2F17%2FJavascript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在生活中我们时常能看到这种图片裁剪的效果, 那么他实际上底层的原理是怎么实现的呢? 让我们深入的解剖一下. 原理分析 首先我们先将视图一分为三, 理解为三个层级叠加在一起的仰视图. 最上面是可拖动的选择窗口 中间待剪辑的可视窗口 底层是一张opacity: .5的背景图片 基础结构我们这里主要讲JavaScript, HTML与css就简要的过一下. 首先HTML基本结构是两张相同的结构, 两张图片分别是调整过透明度的底图和一张被裁剪过了的中间层.mainBox包裹着选择的小方块square,相对定位于image在最上面一层.123456789101112131415161718&lt;!-- index.html --&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image1"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image2"&gt; &lt;div id="mainBox" class="main"&gt; &lt;div class="square left-up"&gt;&lt;/div&gt; &lt;div class="square up"&gt;&lt;/div&gt; &lt;div class="square right-up"&gt;&lt;/div&gt; &lt;div class="square right"&gt;&lt;/div&gt; &lt;div class="square right-down"&gt;&lt;/div&gt; &lt;div class="square down"&gt;&lt;/div&gt; &lt;div class="square left-down"&gt;&lt;/div&gt; &lt;div class="square left"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324/* main.css */body &#123;background: #333;&#125;#box &#123;position: absolute;top: 100px; left: 200px; width: 460px; height: 360px;&#125;#box img &#123;width: 460px;&#125;#box #image1 &#123;opacity: .5;position: absolute; top: 0;left: 0;&#125;#box #image2 &#123;position: absolute; top: 0;left: 0; clip: rect(0, 200px, 200px, 0) &#125;#box .main &#123;position: absolute;border: 1px solid #fff; width: 200px; height: 200px;box-sizing: border-box;&#125;#box .main .square &#123;position: absolute; width: 8px;height: 8px; background: #fff&#125;#box .main .left-up&#123;left: -4px;top: -4px;cursor: nw-resize;&#125;#box .main .up&#123;left: 50%;top: -4px;margin-left: -4px;cursor: n-resize&#125;#box .main .right-up&#123;right: -4px;top: -4px;cursor: ne-resize&#125;#box .main .right&#123;right: -4px;top: 50%;margin-top: -4px;cursor: e-resize&#125;#box .main .right-down&#123;right: -4px;bottom: -4px;cursor: se-resize&#125;#box .main .down&#123;left: 50%;bottom: -4px;margin-left: -4px;cursor: s-resize&#125;#box .main .left-down&#123;left: -4px;bottom: -4px;cursor: sw-resize&#125;#box .main .left&#123;top: 50%;left: -4px;margin-top: -4px;cursor: w-resize&#125;#box &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; JavaScript实现ESMAScript并没有提供可拖动的API, 那我们先来思考一下, 该如何实现拖动的功能~ 最上层有9个小方块(Square), 分别代表着不同方向的边界, 拖动这个边界, 无非需要实现这下面的底层步骤. 鼠标落下(MouseDown) =&gt; 鼠标拖动 =&gt; 松开鼠标(MouseUp). 先创建一个clipImage函数作为入口函数, 主要获取目标元素和生成DOM节点(后面讲), 绑定事件.先给小方块绑定一个鼠标落下事件(mousedown), 当触发事件(MouseEvent)时, 监听器调用onMousedown函数.onMousedown函数中, 接受四个参数e事件, box目标元素, ctrl小方块的方向, type属性, 主要是用来记录数据并暴露给全局变量进行通讯. 12345678910111213141516171819202122232425262728293031;(function() &#123; // Util工具函数 var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; // "全局变量", 记录状态 var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var right = util.$('#box .main .right'); // Add mouse down event up.addEventListener('mousedown', function(e) &#123; onMousedown(e, box, up, 'up'); &#125;); function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 将接受到的信息暴露出去. _MainBox = box; _MainCtrl = ctrl; _MainType = type; &#125;&#125;)(); 紧接着来计算拖动的距离, 在onMouseDown函数上将moving拖动标记设为1(true也行). 判断拖动的标记是否启动, 创建getPosition函数获取元素相对于页面左/上边的偏移量用于计算拖动的偏移量. 如下图. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//初始化var moving = 0;function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; _MainBox = box; _MainCtrl = ctrl; _MainType = type; // 移动计算偏移量并设置到box上 moving = 1;&#125;// 获取元素相对于文档的距离function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;;&#125;// 监听鼠标相对于页面的坐标document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var addWidth, addHeight; var width = _MainBox.offsetWidth; // 相对于屏幕左/上的距离 var boxX = getPosition(_MainBox).left; switch(_MainType) &#123; case "right": addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; break; &#125; &#125;&#125;; 紧接着我们会发现虽然实现了拖动的效果, 但是松开鼠标box宽度还是会随着鼠标变化. 这是因为还没有重置标记. 随即监听鼠标松开事件(MouseUp). 单边拖动就完成啦~12345// 鼠标松开document.onmouseup = function() &#123; // reset moving = 0;&#125;; 整理归纳我们将switch里的代码整理出来. 装进函数里去调用. 相续的将各个方向也加上, 原理也是同理. 值得注意的是将右面和下面要加上box的宽高才能计算出来. 剩下四个边角, 如左上什么的其实就是同时调用正方位的两个函数实现的实现起来. 然后拖动功能就大功告成啦~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215;(function() &#123; var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var up = util.$('#box .main .up'); var down = util.$('#box .main .down'); var right = util.$('#box .main .right'); var rightUp = util.$('#box .main .right-up'); var rightDown = util.$('#box .main .right-down'); var left = util.$('#box .main .left'); var leftUp = util.$('#box .main .left-up'); var leftDown = util.$('#box .main .left-down'); // Add mouse down event right.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, right, 'right'); &#125;); up.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, up, 'up'); &#125;); down.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, down, 'down'); &#125;); left.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, left, 'left'); &#125;); leftUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftUp, 'leftUp'); &#125;); leftDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftDown, 'leftDown'); &#125;); rightUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightUp, 'rightUp'); &#125;); rightDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightDown, 'rightDown'); &#125;); &#125; /** * [onMousedown description] Mouse down event * @param &#123;[type]&#125; e [Event] * @param &#123;[type]&#125; box [target vessel] * @param &#123;[type]&#125; ctrl [Square DOM node] * @param &#123;[type]&#125; type [Square direction] */ function onMousedown(e, box, ctrl, type) &#123; _MainBox = box; _MainCtrl = ctrl; _MainType = type; moving = 1; &#125; // 获取元素相对于左边的距离 function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;; &#125; // 鼠标移动 document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var height = _MainBox.offsetHeight; // 相对于屏幕左/上的距离 var boxY = getPosition(_MainBox).top; switch(_MainType) &#123; case "right": right(e); break; case "up": up(e); break; case "down": down(e); break; case "left": left(e); break; case "leftUp": leftUp(e); break; case "leftDown": leftDown(e); break; case "rightUp": rightUp(e); break; case "rightDown": rightDown(e); break; &#125; &#125; &#125;; // 鼠标松开 document.onmouseup = function() &#123; moving = 0; &#125;; function right(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; &#125; function up(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; &#125; function down(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; &#125; function left(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = boxX - e.clientX; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = boxY - e.clientY; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function rightUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125; function rightDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125;&#125;)(); &lt;– 努力填坑中~ –&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之三 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F11%2F06%2FBasic%20Algorithm%20Scripting%20-%203%2F</url>
    <content type="text"><![CDATA[今天让继续来学习数组方法的用法~ Sum All Numbers in a Range 题目描述 &emsp;&emsp;传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。最小的数字并非总在最前面。比如传递[1, 4]会返回10, 即1 + 2 + 3 + 4. 非数组方法1234567891011121314 function sumAll(arr) &#123; var max = Math.max.apply(null, arr); var min = Math.min.apply(null,arr); var num = max - min; var total = min; while(num) &#123; num--; total += ++min; &#125; return total;&#125;sumAll([1, 1]); &lt;– 未待续~ 有空再深挖 –&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过sourcetree实现远程仓库与本地仓库关联]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2F%E9%80%9A%E8%BF%87sourcetree%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率. &emsp;&emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联. 步骤&emsp;首先把本地仓库初始化. &emsp;再添加到sourcetree上 &emsp;进入github.com -&gt; your profile -&gt; repositories(仓库) -&gt; New &emsp;填写仓库信息, 复制仓库链接 &emsp;设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定 &emsp;然后就可以提交到github了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>sourcetree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Normalize与reset]]></title>
    <url>%2Fblog%2F2017%2F10%2F15%2F%E6%B5%85%E8%B0%88Normalize%E4%B8%8Ereset%2F</url>
    <content type="text"><![CDATA[前言: 在一次开发的时候, 发现团队中的小伙伴对normalize与reset都持有不同分歧. 趁着这事来谈谈, normalize与reset都有什么区别, 该如何取舍. resetreset, 顾名思义就是重置的意思. 最早的一份CSS reset来自Tantek的undohtml.css, Tantek根据自己的需要，对浏览器的默认样式进行了一些重置。 早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题, reset 的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”. 此后国内出现* {margin: 0, padding: 0}这种暴力清除全部样式的reset出现. normalizeNormalize, 从字面上也理解也就是使其正常化. 这是css reset的一个代替方案.Normalize相对「平和」, 注重通用的方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。 创造normalize.css的目的主要是: 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 相比两者的利弊那么相对来说, 两者之间又有什么区别呢? 这里引用一下知乎用户的回答. CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧 Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理，简单粗暴地一视同仁是不好的。body 那一圈确实挤压了页面的生存空间，那就改掉。士农工商，谁有谁的作用，给他们制定个规范，确保他们在任何浏览器里都干好自己的活儿。 然而在实际项目中, 为了还原设计图我们并不需要这种自带特性, 因此可以根据项目的需求将我们常用的标签进格式化, 但也不是跟传统的reset那样粗暴. 因为传统的reset的很多清除默认样式是无意义的, 是浪费性能的. 就比如&lt;li&gt;, 人家生来就没有margin padding, 干嘛非要给人家加个margin: 0上去呀??? h1~h6标签虽然有margin没有padding呀! 也不要一棒子全打死啦! 其实这是不严谨的态度. 以下的代码可以作为针对项目需求的进行调整. 这样看下去是不是舒服简洁多了呢? 也减少了很多无意义的性能损耗何乐而不为呢.1234567891011121314151617181920212223242526 body, dl, dd, h1, h2, h3, h4, h5, h6, p, form, ol, ul &#123; margin: 0;&#125;ol, ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none;&#125;body &#123; font: 14px/1.6 Monda,PingFang SC,Microsoft YaHei,sans-serif;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: block;&#125;.clearfix:after &#123; clear: both;&#125; 参考资料: Normalize.css 与传统的 CSS Reset 有哪些区别？normalize、reset与base关于CSS Reset 那些事（一）之 历史演变与Normalize.css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之二 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F19%2FBasic%20Algorithm%20Scripting%20-%202%2F</url>
    <content type="text"><![CDATA[数组方法的深入学习 Chunky Monkey(分割数组)猴子吃香蕉, 分割数组,把一个数组arr按照指定的数组大小size分割成若干个数组块。例如: &#8195;&#8195;hunk([1,2,3,4],2) =&gt; [[1,2],[3,4]]; &#8195;&#8195;chunk([1,2,3,4,5],2) =&gt; [[1,2],[3,4],[5]]; 思路 &#8195;这道题重点主要是每size个值分割一个数组,这里我们可以使用以下几种方法来解题. while + splice for + slice while + slice 第一种12345678910111213141516// while + splicefunction chunk(arr, size) &#123; // 定义一个新数组和用来临时存放分割的空数组. var a = [], t = [], i = 0, len = arr.length; while (i &lt; len)&#123; t = arr.splice(0, size); a.push(t); i += size; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); &#8195;在这里值得注意的是,len保存arr.length的快照是必须的..因为splice会修改原来原来的数组. 第二种12345678910111213141516171819// for + splicefunction chunk(arr, size) &#123; var a = [], t = [], len = arr.length; // 数组中的个数小于size或者size是小于等于0的也就没有必要分割了 if (len &lt;= size || size &lt;= 0) &#123; return arr; &#125; else &#123; // 它的重点主要是数组中的值的数量 for (var i = 0;i &lt; len; i += size) &#123; // 查询指定数 t = arr.slice(i, i + size); a.push(t); &#125; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); 第三种1234567891011121314// while + slicefunction chunk(arr, size) &#123; var a = [], t = [], i = 0, len = arr.length; while (i &lt; len) &#123; // 查询的值 t = arr.slice(i, i += size); a.push(t); &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); Falsy Bouncer(过滤数组假值)删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。 思路 &#8195;这道题比较有意思..一开始我走进了一个误区,想着单纯return x !== false &amp;&amp; ...这样简单的返回就可以了,后来发现在处理NaN时会很麻烦..isNaN()还会把英文字符串也给过滤掉,再加上多个&amp;&amp;使得代码会变得繁乱,可读性不高.&#8195;然后查阅了一番资料后,才注意到平时被忽略Boolean()的一些特性对于处理这种类型的问题简直不能太合适. 12345678910function bouncer(arr) &#123; // 请把你的代码写在这里 var a = arr.filter(function(x) &#123; return Boolean(x); &#125;); return a;&#125;bouncer([7, "ate", "", false, 9]); &#8195;摘至MDN.Boolean 的描述: 如果Boolean构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的Boolean对象的值为false. 其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为true的Boolean对象. Seek and Destroy (摧毁指定数组)实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 实现原理 &#8195;filter() 为数组中的每个元素调用一次 callback函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组.&#8195;filter()从头至尾遍历数组,若回调函数返回的是true(通过测试),就存入新数组中.若返回的是false,则过滤掉. 12345678910111213141516function destroyer(arr) &#123; // 先将第一个参数隔开,定义一个储存着待移除的空数组 var args = arguments[0], removeArgs = []; // 要被删除的参数装进'removeArgs'里 for (var i = 1; i &lt; arguments.length; i++) &#123; removeArgs.push(arguments[i]); &#125; // 遍历'args',若'removeArgs'中不存在'value',应该返回-1.反之返回false被过滤掉. return args.filter(function(value) &#123; return removeArgs.indexOf(value) === -1; &#125;);&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); Where do I belong (数组排序并找出元素索引)先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 &#8195;举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。 &#8195; 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。 思路 &#8195;这个没啥好说的了..将第二个参数push进数组中,再进行排序.排序后通过indexOf()来实现功能.不过需要注意的是sort默认是按照’Unicode’编码进行排序的. Caesars Cipher (凯撒密码)风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 思路 &#8195;本次练习用到String.charCodeAt()和String.fromCharCode(),首先来查询字符串的Unicode字符.&#8195;根据Unicode表我们得知: 小于65和大于90对应的就是数字和小写字符a-z 大于等于65和小于等于77对应的就是大写字符A-M (13位) 大于等于78和小于等于90对应的就是大写字符N-Z&#8195;ROT13的功能就是移位,如果序号小于78(A-M字母)，使用String.fromCharCode()转换成该序号加13的字符,反之减13. 1234567891011121314151617181920212223function rot13(str) &#123; // LBH QVQ VG! var newStr = []; for (var i = 0;i &lt; str.length;i ++) &#123; // 查询每个字符串的Unicode编号 var temp = str.charCodeAt(i); // 非大写字母,空格,数字等都不转换 if (temp &lt; 65 || temp &gt; 91) &#123; newStr.push(str.charAt(i)); continue; // 大于77(N-Z),就转换成该序号 - 13的字符串. &#125; else if (temp &gt; 77) &#123; newStr.push(String.fromCharCode(temp - 13)); // 小于78(A-M),就转换成该序号 + 13的字符串 &#125; else &#123; newStr.push(String.fromCharCode(temp + 13)); &#125; &#125; return newStr.join('');&#125;rot13("SERR PBQR PNZC"); // 你可以修改这一行来测试你的代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之一 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2FBasic%20Algorithm%20Scripting%20-%201%2F</url>
    <content type="text"><![CDATA[一些基础的算法练习 Palindromes(回文处理)Palindromes称之为回文。在中文文当中是指倒着念和顺着念都是相同的，前后对称. 正则表达式 replace() 1234567function palindrome(str) &#123; var string = str.replace(/[\W_]/g,'').toLowerCase(); var replaceStr = string.split('').reverse().join(''); return replaceStr === string;&#125;palindrome("eye"); // true 思路 &#8195;首先对字符串进行处理..去掉字符串多余的标点符号和空格，然后把字符串转化成小写.&#8195;split把字符串拆分为一个字符串组成的数组.reverse反转数组顺序,join拼接字符串. Title Case a Sentence(首个单词字母大写)句中单词首字母大写,确保字符串的每个单词首字母都大写，其余部分小写。 1234567function titleCase(str) &#123; return str.toLowerCase().replace(/( |^)[a-z]/g, function(L) &#123; return L.toUpperCase(); &#125;);&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot 思路 &#8195;首先把字符串转换为小写,再用正则匹配带空格或者就字母开头的首个字母replace替换成大写字母. Return Largest Numbers in Arrays(返回数组最大的数字)找出多个数组中的最大数,并返回一个新数组 12345678910111213function largestOfFour(arr) &#123; // 请把你的代码写在这里 var count = []; for (var i = 0; i &lt; arr.length; i ++) &#123; var a = arr[i].sort(function (a,b) &#123; return b-a; &#125;); count.push(a[0]); &#125; return count;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); // [5,27,39,1001] 思路 &#8195;新定义一个数组,遍历传进来的数组进行从大到小排序,将排序后最大的数push进新的数组count最后再返回. Confirm the Ending(检查字符串结尾)检查字符串结尾,判断一个字符串(str)是否以指定的字符串(target)结尾。如果是，返回true;如果不是，返回false。 123456789101112function confirmEnding(str, target) &#123; var l = str.length - target.length; if (str.substr(l) === target) &#123; return true; &#125; else &#123; return false; &#125;&#125;confirmEnding("Connor", "n"); // falseconfirmEnding("Bastian", "n"); // trueconfirmEnding("He has to give me a new name", "me"); // true 思路 &#8195;乍一看好像挺麻烦的样子,容我们深入一看却发现好像并没有想象中的麻烦..&#8195;这里用上了String.prototype.substr()而参数start是一个字符的索引,把字符串str.length - target.length就可以对比结尾字符串是否一样了. Repeat a string repeat a string(重复输出字符串)重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。 &#8195;对于这种题目可以使用两种方法解决: 递归 while循环 12345678910111213// 第一种使用递归function repeat(str, num) &#123; // 请把你的代码写在这里 if (num &lt; 0)&#123; return ""; &#125; else if (num === 1) &#123; return str; &#125; else &#123; return str + repeat(str, num - 1); &#125;&#125;repeat("abc", 3); // "abcabcabc" 1234567891011// 第二种使用whilefunction repeat(str, num) &#123; var s = ''; while(num &gt; 0)&#123; s += str; num --; &#125; return s;&#125;repeat("abc", 3); 思路 &#8195;递归一般放进if()判断语句中,是一种通过重复地调用函数本身,逐次减少num的值来实现效果.第二种使用了while语句,每调用一次就递减1,直至num &gt; 0. Truncate a string(截断字符串)截断字符串,如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。插入到字符串尾部的三个点号也会计入字符串的长度。如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213function truncate(str, num) &#123; // 首先判断num的值是不是大于字符串的长度,若是,那就没有必要省略了. if(num &gt;= str.length) &#123; return str; &#125; else if (num &lt;= 3) &#123; return str.slice(0,num) + "..."; &#125; else &#123; return str.slice(0,num-3) + "..."; &#125;&#125;truncate("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length); 思路 &#8195;slice截取字符串.substr(),indexOf()和lastIndexOf()办法同理.https://www.w3cplus.com/javascript/confirm-the-ending.html 大漠老师有一篇文章对此使用有着更详细的说明.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
