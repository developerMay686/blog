<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[性能优化 - 回流与重绘]]></title>
    <url>%2Fblog%2F2018%2F01%2F15%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[回流与重绘已经是个老生常谈的问题啦, 但提到性能优化上却又必不可免的提到它. 今天来谈一谈什么是回流与重绘, 我们该如何去测试, 如何针对性的去优化.概述在HTML中, 每一个标签都有自己的盒子模型. 浏览器在解析HTML的过程中会通过一个叫frame的对象对盒子进行操作. 它主要有三个动作:构建frame, 以建立DOM树.reflow, 布局引擎为frame计算图形, 以确定对象位置, 浏览器根据各种样式来计算结果放在它该出现的位置.repaint, 当计算好盒子模型的位置, 大小以及其他属性后, 浏览器就根据各自的特性进行绘制一遍, 显现出来给用户看.回流的代价回流(reflow)就是布局引擎为 frame 计算图形的过程. 但是这里需要我们注意的是, 回流并不仅仅只是在渲染页面的时候会触发, 实际上当你修改某个 css 属性或者操作 DOM 时, 就有可能会触发回流和重绘.也就是说, 我们操作 DOM 实际上是有代价的. 因为 DOM 的改变会导致浏览器重新计算的它的位置和渲染的样式. 我们来做一个假设, 当用户作出某个操作时(比如下拉滚动条), 你的页面中有几十个 DOM 节点同时发生回流绘制, 那这中间消耗的可是浏览器的资源, 可想而知这样页面的性能自然弱了下来.如何触发YaHoo!性能小组总结了一些导致reflow发生的一些因素:调整窗口大小改变字体增加或者移除样式表内容变化，比如用户在 input 框中输入文字, CSS3 动画等激活CSS伪类，比如:hover操作class属性脚本操作DOM计算offsetWidth和offsetHeight属性设置 style 属性的值而repaint只要视觉效果改变了, 就一定会触发repaint. 比如color或者background. 这个很好理解, 如同字面意思一样. 重绘嘛, 就是字体颜色发生了变化浏览器需要重新绘制一遍. 这里值得一提的是, 触发reflow一定会触发repaint, 而触发repaint却不一定会触发reflow.如何调试接下来我们找个页面测试一下, 看看该如何去调试回流与重绘的.先来介绍一下我使用的工具. 我们打开天猫官网, 打开Chrome开发者工具, 找到 More tools =&gt; Rendering 面板， 可以看到以下几个选项:Paint flashing - 高亮(绿色)显示重绘的页面区域Layer boders - 我们知道页面是由多个”图层”组合的, 最终显示给用户看的就是多图层叠加在一起的效果, 区别无非是层级的问题(css的absolute和z-index就可以很好的说明这一点). 勾选这个选项可以显示图层边款, 我们再根据分析哪些不是我们想要的.FPS meter - 玩游戏的同学大概会比较了解这个, 也就是显示绘制每秒帧数，帧速率分布和GPU内存. 这个更多的是用来分析页面交互和动画性能.Scrolling performance issues - 滚动性能问题. 它会高亮显示可能减慢滚动速度的元素(蓝绿色), 其中包括触摸和滚轮事件处理程序以及其他主线程滚动情况.(有兴趣的同学可以在淘宝的官网勾上这个选项, 看下都有啥).这里主要讲Paint flashing. 我们勾上按钮后, 首先能看到天猫的Logo是一个GIF的动态图, 不断闪烁的绿色高亮提醒着我们, 浏览器正在努力的绘制的图形. 这点很好理解, 因为它是动态的, 浏览器需要绘制 gif 的每一帧展示给用户看. 首屏的轮播图也同理, 内容的不断变化触发着回流与重绘.紧接着我们往下滚, 发现左下角的工具栏会随着滚动而发生重绘. 很显然, 这种是使用了fixed定位. 我们知道fixed是相对浏览器窗口进行定位的. 我们滚动一点, 它会重新计算位置, 导致触发回流. 所幸的是fixed定位只会对自己渲染, 而不会影响身边的DOM.接着我们继续测试. 咦? 这几个商品模块好像不太对劲呀? 怎么停止滚动了, 还是会发生不断的重绘? 打开审查元素一看, 模块中有一个 gif 的背景图片. 我们将属性关闭, 发现几个模块的重绘都消失了, 果然是这东西作祟呀. 紧接着我们来检查一下这 gif 是有什么特殊的作用. 将表面的DOM删掉, 还原background属性 —— 噢~原来是一个加载的loading…. 父元素加一个loading动图, 在子元素还没加载出来时显示loading. 加载后由于层级的关系自然就覆盖了上去, 用户自然就看不到了.这种看似巧妙简便的方法实则是在用户看不到的地方在浪费无意义的性能消耗而已. 因此我还特意的去测试了淘宝和京东的情况, 发现这种写法只有天猫才有. 不知道写页面的同学是偷懒还是什么其他的原因, 这里我们可不要养成这种习惯~很多时候坑就是自己挖的最后又自己踩了上去.如何优化到这里我们已经了解了渲染规则后, 那么就可以针对性的进行控制优化 —— 在我们 coding 的时候合理的去避开回流的影响来减少页面的开销.display:none这个属性已经被玩烂了, 该属性的作用就如同它名字一样直观. display就是用来控制显示的状态嘛… 因此很多人喜欢拿它来做隐藏某一个元素的方法. 而背后却忽略了(或者说不知道)它本身所带的回流性能开销(因为会影响节点的位置从而触发回流和重绘).值得庆幸的是, 已经有前行者帮我们踩过很多坑, 我们只需站在巨人的肩上, 借鉴一下前人的经验:如果想设定元素的样式，通过改变元素的class类名 (尽可能在 DOM 树的最里层)避免设置多项内联样式应用元素的动画，使用position属性的fixed值或absolute值(前文说过, 它只会影响自己)权衡平滑和速度避免使用table布局避免使用 CSS 的JavaScript表达式 (仅 IE 浏览器)除此之外, 使用JavaScript想要动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能.总结最后总结一下所学的概念, 回流(reflow), 就是布局引擎为frame计算图形, 确定节点位置的一个步骤. 其中触发回流的原因主要是节点(DOM)大小或者位置的改变才会触发回流. 而重绘, 就是表面的视觉效果改变了, 就会触发重绘. 其中触发了回流紧接着也会触发重绘, 而触发重绘不一定会触发回流(ahh..有点像绕口令).参考资料形象化的reflow: http://www.aoao.org.cn/blog/2008/05/reflow/影响 reflow 的因素及其优化: http://www.planabc.net/2009/04/13/reflow/Gecko Reflow Visualization - mozilla.org: https://www.youtube.com/watch?v=ZTnIxIA5KGw回流与重绘: CSS性能让JavaScript变慢?]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
        <tag>HTML</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化 - 基础的性能优化]]></title>
    <url>%2Fblog%2F2018%2F01%2F13%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[其实很多性能方面的问题, 很多都是从基础就开始影响. 既然如此我们也从最底层逐步分析, 切入每一点小细节~图片优化web早期, 人们有很多想要实现的设计效果出于css或兼容性的限制, 不得不由图片来去实现这种效果. 以现在时代的眼光来说, 无疑是很不优雅的. 撇开图片本身所占用的空间大小外, 本身代码结构就不够语义化. 那么现在这个CSS3都已经普及的年代, 来试着让HTML, CSS属性或SVG用寥寥数行的代码来代替图片来实现效果吧~ 比如一个圆角, 一个渐变的海浪线等.图片格式每一种图片格式都有着自己的特点和优势, 下面来了解一下现在常见的图片格式来”对症下药”.主流的图片格式jpg 全名是JPEG. JPEG图片以24位颜色存储单个位图.png 可移植网络图形格式. 使用png格式的图片更多的是看中它有透明图层, 因为它是256色, 每一色都可以作为透明像素. 但相对的代价就是体积较大(这个可想而知嘛, 图片里面的信息装的多了, 体积自然就大了).GIF 这个稍微有点网络常识的对会知道, 常用于做动画.SVG 可缩放矢量图形. 它能很好的处理图形大小的改变, 放大缩小都不会失真, 适合静态图片展示，高保真文档查看和打印的应用场景. 如今主流浏览器都对它有着很好兼容性支持.没有被Web标准采纳的格式, 但还是值得关注图片格式APNG APNG 是出自 Mozilla 公司下的两位程序员之手, APNG 的出现是为了代替 GIF. 它相较GIF来说有着更好的图片质量, 还支持着透明图层, 同时图片的大小都比 GIF 格式要小.可惜由于出现的较晚, 没有被Web标准给采纳. 截止到笔者写这篇文章的时间(2018.1), Edge这个不合群的家伙在最新版本 Edge 17 仍然还没有支持这个格式, 而chrome 59才开始支持. 因此兼容性不高, 平时也很少能看到这种格式的出现.Webp是出自Google之手, WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。同上面的 APNG 一样, 同样没有被Web标准所采纳. 不过在 caniuse 上能发现, 如今国内大半的用户已经支持了 WebP , 这个未来还是可以小小的期待一下.正确的使用图片格式话归正题, 下面针对不同的使用场景, 来选择正确的图片格式.首先是jpg, 一般不需要透明图层的图片一律使用jpg, 它相对png来说两者的体积之差能有几倍之差.如果需要比较通用的动画的话, GIF是唯一的选择. 如果是相对简单的GIF动画的话, 也可以考虑使用CSS3来实现.如果需要清晰显示颜色丰富的图片或者需要用到透明图层的话, png是一个比较好的选择页面中图片加载方式细心的你或许会发现, 有时在网络慢的情况下, 能看到图片一点一点从上到下的加载. 或者是先模糊, 再清晰的加载方式.实际上这是图片的压缩算法呈现的效果, 逐行显示是离散余弦变化. 而模糊到清晰的是小波算法. 浏览器先读取图片的压缩算法, 再根据算法来选择不同的渲染算法. 下面是某图站的一张大的壁纸加载过程(没有找到小波算法的图, 以后留意到了再回来补)参考资料APNG 那些事常见的图片优化方案CSS-Sprite在页面中, 我们经常能看到一些icon图标. 这些icon实际上占用并不大, 但奈不住多呀. 100个icon的话就要发送一百个HTTP请求. CSS Sprite(精灵). 利用CSS的background-position和background-image属性, 只需要引用一张图片即可. 这极大的节省了HTTP请求量.iconfonticonfont 和上面所提的css-sprite方法类似, 不同的是这个方法是通过引入字体图标的形式. 好处是设置字体图标的颜色或者可以通过设置font-size来改变尺寸, 并且不容易失真.当然, 现在都是使用自动化工具, 都不需要自己手动去调整&lt;picture&gt;标签HTML5新出了一个&lt;picture&gt;标签, 它是一个容器, 用来为其内部特定的&lt;img&gt;提供多样的&lt;source&gt;元素. 浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源. 也就是所谓的响应式图片. 由于兼容性所限, 因此当下并没有广泛使用.media属性允许你提供一个用于给用户代理作为选择&lt;source&gt;元素的依据的媒体查询。如果这个媒体查询匹配结果为false，那么这个&lt;source&gt;元素会被跳过, 使用如下.12345&lt;picture&gt; &lt;source srcset="mdn-logo-smaller.png" media="(max-width: 768px)"&gt; &lt;source srcset="mdn-logo-big.png" media="(min-width: 1000px)"&gt; &lt;img src="mdn-logo-narrow.png" alt="MDN"&gt;&lt;/picture&gt;构建自动化工具实现优化这个一句话说不完, 以后单独拎出来说这东西吧.视频优化当下视频播放器分为两大流派, 一个是HTML5新进入的video标签, 使用方式简洁. 也是现在主流播放方案. 另一个是Flash播放器, 也是过去常用的播放方案. 虽然技术成熟, 插件多, 但也是逐步的将被淘汰. chrome浏览器默认禁止Flash播放器的使用, 就连Edge都要手动开启才能使用.来对比一下两者的优缺点优点缺点video不需要下载额外的资源(如插件什么的)不同浏览器video标签的外观都不一样. 如果要统一的话需要自己写UI来实现Flash兼容性好, 只需要有 Flash player 播放器插件都可以进行播放1. 需要下载额外的 swf 播放文件才可以播放, 浏览器必须要有Flash player插件(回想以前网页老是让你下载Flash的场景)2. Flash player 版本的碎片化3. UI定制需要 as(带有学习成本)当下主流的方案Flash 和 HTML5 两个方案相结合, 组成一个完整的方案. 当下就有几个成熟稳定的库, 如Flowplayer和VideoJs等.视频优化需要的解决问题由于各浏览器UI不同, 设计师会要求我们按照设计图做播放器.在一些视频网站中, 可能产品经理就会让我们实现, 让用户一进来就最先看到视频.浏览器会将所有的多媒体文件放在最后面加载, 无论标签位置放置在什么位置. 解决的方案就是将&lt;link&gt;代替&lt;script&gt;标签引用.常用的前端缓存技术SessionStorage 临时性存储, 数据仅仅在当前的页面生效, 关闭页面后数据就自动清除了. 同时刷新页面不属于”离开页面”的范围, 数据仍然会存在. 现在微信公众号开发常用这种方法来记录用户信息.Cookie, 兼容性最好的本地存储. 缺点是有大小的限制, 而且每次发送请求时, 请求头会带着Cookie一起发送过去.(这里有个问题, 如果在cookie中存储了1M的数据, 那么在请求的时候, 1M的数据也会跟着请求发送到服务端. 这就很大的影响带宽了) 现在基本大多数登录的合法性验证都是用cookie验证的.LocalStorage 特点是持久储存, 操作方法和 SessionStorage 乐视, 也都是操作key-value的形式. 几乎所有现代浏览器都已经支持了. 值得注意的是, LocalStorage 虽然可以永久储存, 但是无法跨浏览器的获取数据的, 还需要注意储存上限.高性能DOM说到高性能的DOM, 就不得不提回流与重绘这个概念. 为此我又专门的写了一篇回流与重绘. 有兴趣的同学可以去看一下.总结上文都只是在基础上的优化. 还有更多项目内工程化的优化就再等咱有时间再更新相关的内容吧~参考资料前端性能优化-通用的缓存SDK: https://www.imooc.com/learn/866]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解之排序二叉树]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是一种具有层级特性的的数据结构. 这些知识虽说在日常工作中不常使用, 但还是有必要让我们去学习一下, 研究其原理是如何运作. 下面将分享自己的一些理解和学习笔记, 来谈一谈什么是排序二叉树.二叉树的定义树(Tree), 是(n&gt;=0)个节点的有限集. 其中 n=0 时, 我们称之为空树. 在一棵非空树中, 只有一个根节点. 在二叉树中, 每个节点最多有两个子节点. 一般称为左节点和右节点(左、右子树).排序二叉树排序二叉树, 又称为二叉查找树. 它有着自己显著的特点:首先一个节点左孩子的值, 一定小于它本身节点的值.一个节点右孩子的值, 一定大于它本身节点的值.左、右孩子(子树)也分别是排序二叉树.构建排序二叉树二叉树大多也是递归定义的. 下面根据排序二叉树的特性来创建一个二叉树.1234567891011121314151617181920212223242526272829303132333435363738394041424344function BinaryTree(key) &#123; var root = null; var Node = function(key) &#123; this.key = key; this.left = null; this.right = null; &#125;; var insertNode = function(node, newNode) &#123; // 对比新旧节点 if (newNode.key &lt; node.key) &#123; // 左节点是否存在 if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; // 右节点是否存在 if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; // 暴露方法, 插入节点 this.insert = function(key) &#123; var newNode = new Node(key); // 根节点是不是空的 if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;;&#125;var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13];var binaryTree = new BinaryTree();nodes.forEach(function(key) &#123; binaryTree.insert(key);&#125;);遍历二叉树我们已经构建好了一个排序二叉树, 现在想要获取二叉树每一个节点的信息, 因此我们需要遍历节点, 对它做一些操作.中序遍历二叉树有三种遍历的方法, 分别是中序遍历, 前序遍历, 后序遍历. 其中中序遍历的顺序是: 左子树 -&gt; 根元素 -&gt; 右子树.对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列. 百闻不如一见, 我们先看看图中的路线图, 整理一下思路先.这里我们需要加入中序遍历的接口, 因此我们在原先代码上继续扩展并运行.控制台会依次输出”1 3 4 6 7 8 10 13 14”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 function BinaryTree(key) &#123; var root = null; var Node = function (key) &#123; this.key = key; this.left = null; this.right = null; &#125; var insertNode = function (node, newNode) &#123; // 对比新旧节点 if (newNode.key &lt; node.key) &#123; // 左节点是否存在 if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;+ // 中序遍历+ var inOrderTraverseNode = function (node, callback) &#123;+ // 递归遍历, 当到最后叶子节点时, 下面没有节点就会直接返回+ if (node !== null) &#123;+ inOrderTraverseNode(node.left, callback);+ callback(node.key);+ inOrderTraverseNode(node.right, callback);+ &#125;+ &#125; // 插入节点 this.insert = function (key) &#123; var newNode = new Node(key) if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;+ /**+ * 中序遍历+ * @param &#123;Function&#125; callback - 决定如何处理节点+ */+ this.inOrderTraverse = function (callback) &#123;+ inOrderTraverseNode(root, callback);+ &#125;+ &#125; // 初始化调用 var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13] var binaryTree = new BinaryTree(); nodes.forEach(function (key) &#123; binaryTree.insert(key) &#125;)+ // 调用成功后输出当前节点+ var callback = function (key) &#123;+ console.log(key)+ &#125; // 中序调用+ binaryTree.inOrderTraverse(callback);前序遍历虽然前面已经有了中序遍历可以遍历节点, 为啥还要浪费精力学前序呢? 诶~这是因为每一种遍历都有自己应用优势.前序遍历最大的作用, 就是如果我们想把已经有了的二叉树重新复制一遍, 使用前序遍历得到的效率相比重新构造一次来说, 两者的差距能差好几倍.前序遍历的顺序与中序遍历有些不同, 前序是以: 根元素 - 左节点 - 右节点的顺序来遍历.这里将遍历的路线图简化了下, 红色输出, 黄色返回上一级, 而绿色则是右子树遍历. 可以看到这是很典型的递归思想. 紧接着我们继续在代码上进行扩展.12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code... // 前序排序 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key) preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) &#125; &#125; /** * 中序遍历 * 暴露中序遍历的方法 * * @param &#123;Function&#125; callback - 决定如何处理节点 */ this.preOrderTraverse = function (callback) &#123; inOrderTraverseNode(root, callback); &#125; binaryTree.preOrderTraverse(callback); // callback会依次打印 8 3 1 6 4 7 10 14 13&#125;后序遍历看到这里, 大家可能已经意识到了. 不同的遍历方法实际上是对当前的节点访问的顺序不一样. 后序遍历的访问的次序就是: 左节点 - 右节点 - 根元素. 它的特点是, 当下面的左右孩子都遍历完了后才会触发回调函数(callback). 因此适用于破坏性操作的情况, 比如删除所有的节点12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code... // 后序排序 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) callback(node.key) &#125; &#125; /** * 后序遍历 * 暴露后序遍历的方法 * * @param &#123;Function&#125; callback - 决定如何处理节点 */ this.postOrderTraverseNode = function (callback) &#123; inOrderTraverseNode(root, callback); &#125; binaryTree.postOrderTraverse(callback); // callback会依次打印 1 4 7 6 3 13 14 10 8&#125;二叉树节点查找找出排序二叉树的最大节点和最小节点实际上也很简单. 前文提过, 根据排序二叉树的特性, 节点左孩子的值, 一定比节点本身小. 节点右孩子的值一定比节点本身大. 因此我们可以根据这个规则来进行查找:123456789101112131415161718192021222324252627282930313233343536373839function BinaryTree(key) &#123; // other code ... var minNode = function (node) &#123; if (node) &#123; // 循环逐级向下查找, 直到没有左孩子(最小节点) while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; // 循环结束后直接反馈 node值 return node.key; &#125; return null; &#125; var maxNode = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.right) &#123; node = node.right; &#125; return node.key; &#125; return null; &#125; // 最小节点 this.min = function () &#123; return minNode(root) &#125; // 最大节点 this.max = function () &#123; return maxNode(root) &#125;&#125;console.log("min node is:" + binaryTree.min()) // 输出1console.log("min node is:" + binaryTree.max()) // 输出 14查找节点是否存在:12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code var searchNode = function (node, key) &#123; if (!node) return false // 依旧是递归思想， key值比node.key值小, 就去查询左子树 if (key &lt; node.key) &#123; return searchNode(node.left, key) &#125; else if (key &gt; node.key) &#123; return searchNode(node.right, key) &#125; else &#123; return true &#125; &#125; this.search = function (key) &#123; return searchNode(root, key) &#125;&#125;console.log(binaryTree.search(7) ? "key 7 is found" : "key 7 is not found")// key 7 is foundconsole.log(binaryTree.search(9) ? "key 9 is found" : "key 9 is not found")// key 9 is not found总结最后将上面的知识总结一下. 首先知道了树的实际上是一种具有层级特性的数据结构, 其中排序二叉树又是一种特殊的树. 它的具有以下几种性质:如果左(孩子)子树不为空, 那么左子树一定比父节点(根节点)的值小.如果右(孩子)子树不为空, 那么右子树一定比父节点(根节点)的值大.其中左、右子树也分别是排序二叉树.紧接着创建了二叉树节点后, 我们需要去遍历这些节点. 遍历的方法又分前序遍历, 中序遍历, 后序遍历. 三者的区别仅在遍历的顺序不同, 但却有着不同优势.前序遍历是唯一一个从根元素开始遍历的, 其顺序为 根 - 左 - 右, 由于它是从根左右开始, 非常适合像复制节点这样的工作.中序遍历的顺序是 左 - 根 - 右, 返回的是一个从小到大(从大到小)排序的好序列.后序遍历的顺序是 左 - 右 - 根, 其特点是执行操作时，肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点.后面还讲到了二叉树节点查找, 利用递归找到二叉树中最小(大)的节点值等.数据结构的学习之路还很长, 以后再一点一点慢慢的深入吧~]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>排序二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Vue项目的构建速度]]></title>
    <url>%2Fblog%2F2018%2F01%2F06%2F%E4%BC%98%E5%8C%96Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[随着项目依赖的增加, 在配合开发的时候听到后端同学的抱怨 build 时间长, 及其影响开发效率和心情. 然后翻阅了相关的资料开启Vue优化之路~项目依赖管理首先检查一下依赖, 去掉对项目没用的依赖, 然后注意开发依赖跟生产依赖不能弄混. 如scss, scss-loader要放在开发依赖中, 因为编译后就不需要了的.. 这一点我以前也有文章提过两者的区别, 有兴趣的同学可以去看看.优化配置修改config/index.js下的文件1234567// 开发环境dev下, 设置为`eval`能提高最快速度, 但是缺点是不能正确显示行号, Debug会有点影响devtool: 'eval'// 关闭生产环境的sourceMap, 不懂是啥的话可以看下面的文章// 阮一峰 - JavaScript Source Map 详解// http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.htmlproductionSourceMap: false在src/mian.js关闭生产环境下的调试信息12345// 关闭生产环境下的调试信息const isDebugMode = process.env.NODE_ENV !== "production";Vue.config.debug = isDebugMode;Vue.config.devtools = isDebugMode;Vue.config.productionTip = isDebugMode;启动 DllPlugin在build文件夹中新增webpac.dll.config.js的js文件. 我们将第三方库抽取出来, 打包dll代码.12345678910111213141516171819202122232425262728293031323334353637const path = require("path");const webpack = require("webpack");// 抽取第三方库const vendors = [ "vue/dist/vue.common.js", "vue-router", "babel-polyfill", "axios", "element-ui", "mint-ui" ]module.exports = &#123; entry: &#123; vendor: vendors &#125;, output: &#123; path: path.join(__dirname, "../static/js"), filename: "[name].dll.js", library: "[name]_[hash]" // vendor.dll.js中暴露出的全局变量名 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, ".", "[name]-manifest.json"), // 此处需要和 output.library 的值一致 name: "[name]_[hash]", context: __dirname &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;;然后我们写一个快捷的调用方式, 在package.json的script上添加一行代码:123456&#123; "scripts": &#123; // other code... "dll": "webpack --config ./build/webpack.dll.config.js" &#125;&#125;这样就可以直接在命令行使用npm run dll, 生成vendor-manifest.json和vendor.dll.js, 前者是库文件的node_modle路径和webpack打包id的映射. 后者是我们打包后的代码库.随后这里我们再安装html-webpack-include-assets-plugin和copy-webpack-plugin这两个插件.1npm insatll --save-dev html-webpack-include-assets-plugin copy-webpack-plugincopy-webpack-plugin是因为项目的需要，我们需要copy到指定的目录下.html-webpack-include-assets-plugin是将vendor.dll.js插入到index.html里.这里值得一提的是, 虽然我们可以直接在根目录的index.html里插入script, 但实际上并不妥当的. 当你npm run dev后, 你会发现在控制台那一行红色的报错, 告诉着你东西找不到, 虽然不影响开发, 但你会看得很难受.紧接着我们在webpack.prod.conf.js上引用我们添加的依赖, 再添加以下代码1234567891011121314151617181920212223// config 是 config/index.js 里的配置// utils.assetsPath 也是 build/utils.js的配置// 这里这样写是为了跟项目统一plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require('./vendor-manifest.json') &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]), // 将 vendor.dll.js 插入HTML里 new HtmlWebpackIncludeAssetsPlugin(&#123; assets: [utils.assetsPath('js/vendor.dll.js')], files: ['index.html'], append: false &#125;),]在命令行进行打包npm run build, 可以看到构建的速度大大的提高啦, 我们的优化也告一段落了~后记最后再优化时说说踩的坑, 给后来人一些提示.Uncaught ReferenceError: vendor_library is not defined - 检查HTML里是否插入vendor.dll.js, 文件是否加载成功, 或者检查是否有路径问题.一些打包后hash不变仍然会被清除重新打包 … 这是因为vue-cli默认配置会直接清空dist文件夹里的所有文件, 你提前放一些js文件进去也是没有用的.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对MVC与MVVM的理解]]></title>
    <url>%2Fblog%2F2018%2F01%2F05%2F%E6%B5%85%E8%B0%88%E5%AF%B9MVC%E4%B8%8EMVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开发中我们常听说MVC, MVP, MVVM这些好像很高端的名词, 那么你了解他实际上是什么东西吗? 下面谈谈对它们的理解.1. MVC其实上面所提的三者都是一种软件架构模式(或者说是一种概念), 其中MVC的历史最为长远.MVC模式可以分成以下三种, 就是模型(module), 界面(View), 控制器(controller). 三者之间的关系.MVC的好处在于视图控制模型分离降低耦合性提高代码重用性和可维护性因为是单向模块化, 不同层各施其职，互不干涉有优点再说说缺点:清晰的构架以代码的复杂性为代价, 对小项目优可能反而降低开发效率.Controller层代码难以复用的, 到后面会变得臃肿.运行效率相对较低, 太过于复杂反而不太适合中小型项目MVVMMVVM(Module-View-ViewModule)的出现主要是为了解决在开发过程中Controller越来越庞大的问题, 它将Controller替换成了ViewModule, 同时改变了通讯模式, 这是MVVM相对于MVC改进的核心思想.其中MVVM的显著特点就是双向绑定. view的变动会自动更新到Model中. 其中当下很流行的Vue框架就是采用了这个模式. 下图的就能很清晰的看的懂ViewModel是如何做的.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git emoji使用指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F31%2FGit-emoji%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[emoji源于日语词汇“絵文字”, 想必大家对它都挺熟悉的吧, 其拟人化的生动形象，已经成为当下流行的表情之一. 接下来讲一下如何规范的在git中使用emoji提高我们项目的可读性吧~使用方式在git commit上加入emoji的二进制符号, 格式为1:emoji1: :emoji2: 本次提交的主要内容如初次提交:1git commit -m " Initialize Repo" 相关规范emoji 表情在提交代码的时候也不能乱用，否则容易造成误解. 因此开源项目gitmoji专门规定了在 github 提交代码时应当遵循的 emoji 规范： emoji emoji代码 说明 (喝彩) : tada: 初始提交 (调色板) &lt;img class=&quot;github-emoji&quot; title=&quot;art&quot; alt=&quot;art&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3a8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 改进代码的结构/格式 (闪电) &lt;img class=&quot;github-emoji&quot; title=&quot;zap&quot; alt=&quot;zap&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/26a1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 提高性能 (火焰) &lt;img class=&quot;github-emoji&quot; title=&quot;fire&quot; alt=&quot;fire&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 删除代码或文件 (bug) &lt;img class=&quot;github-emoji&quot; title=&quot;bug&quot; alt=&quot;bug&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f41b.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复一个错误 (紧急救护车) &lt;img class=&quot;github-emoji&quot; title=&quot;ambulance&quot; alt=&quot;ambulance&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f691.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 关键修补程序 (闪亮) &lt;img class=&quot;github-emoji&quot; title=&quot;sparkles&quot; alt=&quot;sparkles&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2728.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 引用新功能 (备忘录) &lt;img class=&quot;github-emoji&quot; title=&quot;memo&quot; alt=&quot;memo&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4dd.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 编写文档 (火箭) &lt;img class=&quot;github-emoji&quot; title=&quot;rocket&quot; alt=&quot;rocket&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f680.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 部署新功能 (重构) &lt;img class=&quot;github-emoji&quot; title=&quot;recycle&quot; alt=&quot;recycle&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/267b.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 代码重构 (口红) &lt;img class=&quot;github-emoji&quot; title=&quot;lipstick&quot; alt=&quot;lipstick&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f484.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更新UI和样式文件 (复选框) &lt;img class=&quot;github-emoji&quot; title=&quot;white_check_mark&quot; alt=&quot;white_check_mark&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加测试 (苹果) &lt;img class=&quot;github-emoji&quot; title=&quot;apple&quot; alt=&quot;apple&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f34e.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复MacOS上的问题 (企鹅) &lt;img class=&quot;github-emoji&quot; title=&quot;penguin&quot; alt=&quot;penguin&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f427.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复Linux上的问题 (旗子) &lt;img class=&quot;github-emoji&quot; title=&quot;checkered_flag&quot; alt=&quot;checkered_flag&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3c1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复Windows上的问题 (机器人) &lt;img class=&quot;github-emoji&quot; title=&quot;robot&quot; alt=&quot;robot&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f916.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 解决Android上的问题 (绿苹果) &lt;img class=&quot;github-emoji&quot; title=&quot;green_apple&quot; alt=&quot;green_apple&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f34f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 解决iOS上的问题 (书签) &lt;img class=&quot;github-emoji&quot; title=&quot;bookmark&quot; alt=&quot;bookmark&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f516.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 发布/版本标签 (警告灯) &lt;img class=&quot;github-emoji&quot; title=&quot;rotating_light&quot; alt=&quot;rotating_light&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 移除 linter 警告 (施工) &lt;img class=&quot;github-emoji&quot; title=&quot;construction&quot; alt=&quot;construction&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a7.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 工作正在进行中 (绿心) &lt;img class=&quot;github-emoji&quot; title=&quot;green_heart&quot; alt=&quot;green_heart&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修复CI构建 (下降) &lt;img class=&quot;github-emoji&quot; title=&quot;arrow_down&quot; alt=&quot;arrow_down&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2b07.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 降级依赖关系 (上升) &lt;img class=&quot;github-emoji&quot; title=&quot;arrow_up&quot; alt=&quot;arrow_up&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2b06.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 升级依赖关系 (图钉) &lt;img class=&quot;github-emoji&quot; title=&quot;pushpin&quot; alt=&quot;pushpin&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4cc.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 将依赖关系固定到特定的版本 (工人) &lt;img class=&quot;github-emoji&quot; title=&quot;construction_worker&quot; alt=&quot;construction_worker&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f477.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加CI构建系统 (上升趋势) &lt;img class=&quot;github-emoji&quot; title=&quot;chart_with_upwards_trend&quot; alt=&quot;chart_with_upwards_trend&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加分析或跟踪代码 (减号) &lt;img class=&quot;github-emoji&quot; title=&quot;heavy_minus_sign&quot; alt=&quot;heavy_minus_sign&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2796.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 删除依赖项 (鲸鱼) &lt;img class=&quot;github-emoji&quot; title=&quot;whale&quot; alt=&quot;whale&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f433.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 关于Docker的工作 (加号) &lt;img class=&quot;github-emoji&quot; title=&quot;heavy_plus_sign&quot; alt=&quot;heavy_plus_sign&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2795.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加一个依赖项 (扳手) &lt;img class=&quot;github-emoji&quot; title=&quot;wrench&quot; alt=&quot;wrench&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f527.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更改配置文件 (铅笔) &lt;img class=&quot;github-emoji&quot; title=&quot;pencil2&quot; alt=&quot;pencil2&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/270f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 修正错别字 (hankey) &lt;img class=&quot;github-emoji&quot; title=&quot;hankey&quot; alt=&quot;hankey&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 编写需要改进的不好的代码 (回退) &lt;img class=&quot;github-emoji&quot; title=&quot;rewind&quot; alt=&quot;rewind&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/23ea.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 恢复更改 (国际化) &lt;img class=&quot;github-emoji&quot; title=&quot;globe_with_meridians&quot; alt=&quot;globe_with_meridians&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f310.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 国际化和本地化 (合并) &lt;img class=&quot;github-emoji&quot; title=&quot;twisted_rightwards_arrows&quot; alt=&quot;twisted_rightwards_arrows&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f500.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 合并分支 (打包) &lt;img class=&quot;github-emoji&quot; title=&quot;package&quot; alt=&quot;package&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4e6.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更新编译的文件或包 (外星人) &lt;img class=&quot;github-emoji&quot; title=&quot;alien&quot; alt=&quot;alien&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f47d.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 由于外部API更改而更新代码 (移动搬家) &lt;img class=&quot;github-emoji&quot; title=&quot;truck&quot; alt=&quot;truck&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f69a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 移动或重命名文件 (页面) &lt;img class=&quot;github-emoji&quot; title=&quot;page_facing_up&quot; alt=&quot;page_facing_up&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c4.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加或更新许可证 (爆炸性) &lt;img class=&quot;github-emoji&quot; title=&quot;boom&quot; alt=&quot;boom&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a5.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 介绍突破性变化 (便当) &lt;img class=&quot;github-emoji&quot; title=&quot;bento&quot; alt=&quot;bento&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f371.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加或更新资产 (好的手势) &lt;img class=&quot;github-emoji&quot; title=&quot;ok_hand&quot; alt=&quot;ok_hand&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f44c.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 由于代码审阅更改而更新代码 (无障碍) &lt;img class=&quot;github-emoji&quot; title=&quot;wheelchair&quot; alt=&quot;wheelchair&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/267f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 改善无障碍 (灯泡) &lt;img class=&quot;github-emoji&quot; title=&quot;bulb&quot; alt=&quot;bulb&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 记录源代码 (文字框) &lt;img class=&quot;github-emoji&quot; title=&quot;speech_balloon&quot; alt=&quot;speech_balloon&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4ac.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 更新文字和文字 (存档箱) &lt;img class=&quot;github-emoji&quot; title=&quot;card_file_box&quot; alt=&quot;card_file_box&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f5c3.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 执行与数据库相关的更改 (声响) &lt;img class=&quot;github-emoji&quot; title=&quot;loud_sound&quot; alt=&quot;loud_sound&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f50a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 添加日志 (静音) &lt;img class=&quot;github-emoji&quot; title=&quot;mute&quot; alt=&quot;mute&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f507.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 删除日志 (用户) &lt;img class=&quot;github-emoji&quot; title=&quot;children_crossing&quot; alt=&quot;children_crossing&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6b8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 改善用户体验/可用性 (建筑) &lt;img class=&quot;github-emoji&quot; title=&quot;building_construction&quot; alt=&quot;building_construction&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3d7.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt; 进行架构更改 参考资料 Git emoji: https://gitmoji.carloscuesta.meGithub emoji列表: https://segmentfault.com/a/1190000009649780]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新手不知道的JavaScript技巧 - 条件语句的简写技巧]]></title>
    <url>%2Fblog%2F2017%2F12%2F26%2F%E6%96%B0%E6%89%8B%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[可能入坑不久的同学还会用着if (value !== null || Value !== undefined)这样的判断语句, 而实际上只要理解判定的规则, 善用规则, 就能大大的提高代码的可读性. 接下来让我们深入学习一下.开始大多编程语言中最为常用的一个语句就是if语句, 这种条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句. 它的语法如下:123if (Expression) &#123; statement&#125;其中Expression(表达式/条件)可以是任意表达式或者值.首先它会解析表达式的值如果表达式是无法解析的, 会报ReferenceError的错误并停止. 如果不是则继续.判断值的引用类型, 如果是布尔值, 字符串和符号则继续. null和undefined永远都返回 false.将值传入toBoolean(exprValue)根据下面的规则转换为布尔值.valueBoolean未定义(Undefined)false空值(null)false布尔值(Boolean)返回参数本身数字(Number)如果参数是+0, -0或NaN，则返回false; 否则返回true字符串(String)如果参数是空字符串(长度为零)，则返回false; 否则返回trueSymbol返回 trueObject返回 true这里我们得出undefined, null, NaN, 空字符串, 和数字 0 都是过不了条件语块的规则, 因此我们可以利用这一点来对代码进行简写.1234567891011121314151617181920212223var userName = 'hello';var flag = false;// bad codeif (value != undefined) &#123; ...&#125;// bad codeif (value !== undefined || value !== null || value !== false) &#123; ...&#125;// good codeif (userName) &#123; something...&#125;// flag锁, 利用取反转换布尔值if (!flag) &#123; flag = true; something...&#125;相同的, 也没有必要去使用==规范不推荐的方式去隐式转换类型, 这种规则同样适用于三目运算符, switch等条件运算中去… 这样看起来是不是自己的代码整洁多了呢~后记才疏学浅, 如果有什么说的不对或者需要改进的地方, 可以给我留言大家一起交流. 原创不易, 如果文章对你有帮助的话就随手点个赞鼓励一下呗~参考资料ECMA-262 官方文档http://www.ecma-international.org/ecma-262/6.0/#sec-if-statement]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript原理分析</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥WebSockets]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2F%E5%88%9D%E7%AA%A5Web-Sockets%2F</url>
    <content type="text"><![CDATA[要说最令人津津乐道的新浏览器的API, 就数Web Sockets了. 接下来了解一下这个备受争议的API吧~什么是Web Socket?Web Socket是HTML5出来的一个持久化新协议. 它的目标是在一个单独的持久链接上提供全双工, 让客户端和服务器之间的数据交换变得更加简单.Web Socket是基于HTTP协议来建立连接. 由于使用了自定义的协议, 因此它的URL模式策略也与标准的HTTP不同, 未加密的http://对应着ws://, 而加密的连接的https://也变成https://.那使用Web Socket的好处是什么?能够在客户端和服务器之间发送非常少的数据, 而不用担心HTTP那样字节级的开销. 由于传递的数据很小, 表面看起来会很适用于移动端.主动性大家都知道, 标准HTTP请求是具有被动性的, 如ajax轮询:客户端: “lalala, 帮我看一下我快递有变动吗?”服务端: “没呢, 没变化”客户端: “那现在呢?”服务端: “也还没..”客户端: “那现在呢?”服务端: “还没…”客户端: “那现在呢?”服务端: “好啦好啦, 物流发生变化了, 你看到这里这里了”客户端: “那开始派送了吗?”服务端: “还没…”这样的缺点是什么… ajax轮询需要服务器有很快的处理速度和资源, 而频繁过多的请求可能会报503 Server Unavailable的错误了.而升级为Websocket后, 这时候服务器会主动把东西反馈给你, 如:客户端: “哥们, 咱建立Websocket协议, 需要chat，Websocket协议版本：17（HTTP Request）”服务端：”ok，确认，已升级为Websocket协议(HTTP Protocols Switched)”客户端: “那有啥事的话跟我讲噢”服务端: “balbalbal”服务端: “balbalbal”服务端: “hhhhhhhhhh”服务端: “笑死啦2333333”就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你, 这里场景就适用于聊天室之类的）没有同源限制，客户端可以与任意服务器通信(不用担心跨域)现状与短处既然它存在这种优势为什么如今还是使用的不多呢?HTML5新API嘛… 说到HTML5就不得不考虑到兼容性的问题, WebSocket在各浏览器的兼容性不一致这是问题其一.前文有提过. 相对于PC端, websocket的客户端和服务器之间发送非常少的数据, 表面看起来的确移动端会更有优势. 但是目前以国内的环境来说, 反而不好用. 当网络不稳定的时候开销尤其大.看到这里或许会有人问, 啊? 你之前不是说只需要1次HTTP请求就可以做信息传送了蛮?? 是的, 没错. 大家可能会玩过像阴阳师这样的游戏? 网络一闪, 就会让你重新登录.而长轮询断一次只会卡一秒, 而websocket断了则要重新从认证开始, 那当网络不稳定时, 那开销可想而知.其次就是性能上并没有绝对的优势, 所以当前主流还是标准的HTTP比较多, 而websocket, 据我所知当下适用的场景也只有手游上的使用了.后记websocket的路还很长, 虽然现在使用的不多, 但以后还是可以保留小小的期待. 上文提及资料有部分是来源于网上. 有部分是去咨询了相关的dalao. 才疏学浅若有违权, 或者说的不对的地方望各位指出.参考资料:WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎https://www.zhihu.com/question/20215561/answer/40316953]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>WebSocket</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于点击下拉菜单字体模糊及可能造成boder上下一像素宽度不一的坑]]></title>
    <url>%2Fblog%2F2017%2F12%2F23%2F%E5%85%B3%E4%BA%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E6%A8%A1%E7%B3%8A%E5%8F%8A%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90boder%E4%B8%8A%E4%B8%8B%E4%B8%80%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6%E4%B8%8D%E4%B8%80%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[关于点击下拉菜单会造成文字模糊及boder 1px上下和左右宽度不一致的问题.起始朋友叫帮忙看代码~ 问题是这样的, 当点击下拉菜单时, 整个页面的组件都变模糊一下. 然后border上下的边框能隐约看到会大概溢出那么一点(但是没到一个像素).因为使用了element组件, 大概能想到中间加有transition, 对问题进行排查后发现transform这个属性会对后代元素能产生影响, 将属性删除, 问题解决. 具体影响的原理, 现在占个坑, 以后再深入挖掘…Bug相关的图]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transition</tag>
        <tag>transform</tag>
        <tag>布局bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git pull远程仓库代码冲突]]></title>
    <url>%2Fblog%2F2017%2F12%2F18%2Fgit-pull%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[常用git与远程仓库进行交互, 难免会遇到冲突的问题. 现在来了解一下, 当出现这种情况时, 该要如何处理.起始代码冲突, 无非就是同时有两个人在改动同一个文件所造成的冲突. 当你使用git pull后, git会提示你:123456$ git pullerror: Your local changes to the following files would be overwritten by merge: src/components/page/file.vuePlease commit your changes or stash them before you merge.AbortingUpdating 8e191be..c301cdc这时候你可以使用git stash将本地修改存储起来. 使用git status查看, 是不是干净啦~123456$ git stashSaved working directory and index state WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/testHEAD is now at 8e191be Merge branch 'master' of https://github.com/anran758/test$ git status# On branch masternothing to commit, working directory clean这时再使用将远程仓库的代码pull下来123456 $ git pullUpdating 8e191be..c301cdcFast-forward src/base/fonts/iconfont.eot | Bin 7320 -&gt; 7548 bytes src/components/page/file.vue | 10 +- create mode 100644 static/font_503074_8sfhbdjlucjtt9/iconfont.eot现在要查看现有的储藏, 可以使用git stash list12$ git stash liststash@&#123;0&#125;: WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/test这时我们还原储藏的内容, 使用命令git stash pop &#39;stash@{0}&#39;. 注意这里的要使用引号&#39;stash@{0}&#39;, 因为shell正在使用扩展里的内容, 否则会报一个unknown option: -encodedCommand1234567891011$ git stash pop 'stash@&#123;0&#125;'Auto-merging src/components/page/file.vueOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: src/components/page/film.vueno changes added to commit (use "git add" and/or "git commit -a")之后就可以使用git diff或者利用图形工具, 如sourceTree(可视化git), vscode编辑器上对比代码, 手动解决冲突即可.]]></content>
      <tags>
        <tag>git</tag>
        <tag>代码冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是.gitkeep? 如何在windows下使用命令行创建.gitkeep文件]]></title>
    <url>%2Fblog%2F2017%2F12%2F16%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA-gitkeep%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在一些脚手架上构建项目中, 你或许会留意到某个目录中会有个名为.gitkeep的空文件. 那么这个文件是用来做什么的呢?缘由什么是.gitkeep? 其实是这样的, 当提交的代码时目录中有空文件夹时git会自动忽略掉. 而有时候你就是想留着这个, 以后有用处不想被忽略怎么办呢? 因此, .gitkeep就应运而生了….gitkeep是一个约定俗成的文件名并没有什么特殊规则, 它就相当于一个占位, 让git开始跟踪这个目录.其实任何文件都可以, 只不过大家都遵循这个命名, 会跟具有语义化. 如同字面意思一样…git + keep, 让git保持这个文件夹, 是不是很简单易懂呀?创建文件“哥, 能发个’.gitkeep’给我蛮? 项目中的弄丢了..”“啊? 直接创建一个不就完啦?”“创建不了呀!!系统不准, 会报错提示必须输入文件名”“噢~是有这个限制的, 你用命令行吧”“搜了圈, 好像没有找到在windows创建的方法诶, ““? ? ?”没错, 上面这场景就是让我写这篇博客的主要起因…其实windows下环境创建.开头的文件只能通过命令行的方法, 而且方式也很简单. 只需要输入一行命令即可..1type NUL &gt; .gitkeep这段代码的意思就是创建一个空文件重定向到名为.gitkeep的文件中.gitignore与gitkeep在脚手架构建的项目中, 你也总能在根目录看到名为.giitignore的文件, 那么它和gitkeep又有什么关联呢? 前文有提过, .gitkeep只是约定俗成的一个名称, 而.gitignore是一个特殊文件, 如果你有什么不想提交上去的东西, 如配置了表单密码的配置文件呀什么的, 你可以写进这个文件中, git会自动的忽略掉它.忽略文件的原则是：忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。总结其实像.gitignore带有其他特殊文件还有其他, 如.nojekyll来告诉Github关闭 GitHub Pages 的 Jekyll 相关功能等, 由于实际工作中用的烧, 这里不详谈, 放着让大家去挖掘吧~]]></content>
      <tags>
        <tag>cmd</tag>
        <tag>Githubg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中Axios报错Promise未定义及IE10报语法错误的解决方案]]></title>
    <url>%2Fblog%2F2017%2F12%2F15%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%ADAxios%E6%8A%A5%E9%94%99Pomise%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%8F%8AIE10%E6%8A%A5%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[关于IE11及以下版本无法使用Promise还有IE10下报错的问题Promise未定义 ?在使用Axios开发时, IE11及以下版本报错会报Promise未定义的错误. 这是因为axios本质上是封装了ES6语法的promise,而promise在IE上并不兼容.然而说到js兼容, 这时候我们又能联想到babel.. 没错, babel中有一个工具叫做babel-Polyfill, 它会仿效一个完整的ES2015+环境，并意图运行于一个应用中而不是一个库/工具. 其实食用的方式也很简单.我们将babel-polyfill装进我们项目依赖中. 这里值得注意的是, 安装的时候需要安装到dependency(生产依赖)中, 而不是devDependency(开发依赖)(tips.关于两者的区别, 我以前的文章有专门讲过, 感兴趣的可以看一下)1npm install --save babel-polyfill首先在mian.js的顶部引入import &quot;babel-polyfill&quot;;确保能够最先加载, 随后我们在build目录下webpack.config.js修改配置, 将app使用babel-polyfill进行编译. 这时候我们再重新编译, 就会发现promise未定义的错误就以及消失了12345module.exports = &#123; entry: &#123; app: ["babel-polyfill", './src/main.js'] &#125;&#125;你以为文章到这里就结束了吗…. 随即我们切换到IE10下进行测试. 你会发现, 又冒出了一个报错.. Emmm, 解决一个又来一个, 惊不惊喜意不意外?语法错误当你在IE10下看到提示语法错误的时, 这时候你就得去检查检查package.json下 webpack-dev-server版本是否高于2.6.1. 出现这个报错主要是因为项目中使用了const等语法, 然而IE11以下并不认得ES6语法语法.这个问题只有在开发模式才会出现, 只要es6转码后，打包放到服务器上，就没有问题了.如果你想在开发阶段在IE10下测试你的代码, 你可以选择降低版本到2.6.1上, 问题就解决了.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>IE兼容性错误</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端所能做的SEO]]></title>
    <url>%2Fblog%2F2017%2F12%2F05%2F%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%89%80%E8%83%BD%E5%81%9A%E7%9A%84SEO%2F</url>
    <content type="text"><![CDATA[SEO, 就是搜索引擎优化(Search Engine Optimization)的缩写, SEO优化是专门利用搜索引擎的搜索规则来提高网站在搜索引擎内的自然排名的一种方式. 能对搜索引擎的小蜘蛛更加友好. 那么前端能做哪些SEO的优化呢?SEO基础三要素我们进入某个网页打开调试工具, 在&lt;head&gt;标签里我们能的看到&lt;title&gt;标签, keywords和description的&lt;meta&gt;标签. 就是最基础的SEO三要素.其中&lt;title&gt;标签代表着页面的标题, &lt;meta keywords&gt;是网站的关键字, &lt;meta Description&gt;则是网页的描述, 即对这些关联字进行了扩展.昂, 现在我们知道了这三要素可以SEO优化, 那我们就疯狂的在关键字里加一堆上去, 越多越好?当然, 并不是这样的.这些都有限制的, 内容不可过长, 也不能过分的堆砌关键字, 每个页面的description也应该不同. 比如下方张老师的博客为例.网站构造布局优化对网站布局进行SEO优化, 控制首页链接数量, 扁平化的目录层次(最多三层目录层次), 然后对导航SEO优化.编写语义化代码我们常说, 要养成编写语义化代码的习惯. 那什么是语义化呢? 就是既要人看得懂, 也要机器能理解你的代码.其实我们常用的HTML标签很多都是带语义化的. 如:H1 ~ H6都是用于表示标题UL标签多用于无序列表Ol标签用于有序列表DL标签用于定义数据列表Em, strong表示强调等站内优化&lt;a&gt; - 标签优化, 外链上加上rel=”nofollow”, 让小蜘蛛别往外面爬&lt;h1&gt; - 正文标题使用h1&lt;img&gt; - 标签使用alt说明, alt对图片起着一个注释的作用&lt;strong&gt;``&lt;em&gt;与&lt;b&gt;``&lt;i&gt;标签&lt;strong&gt;是权重标签的代表, 在搜索引擎中能够得到高度的重视, 他能突出关键词, &lt;b&gt;与&lt;strong&gt;的效果是一样的, 但是在SEO中并不会起到很好的效果, 因此不推荐使用.&lt;em&gt;表示斜体, 权重标签的重要度仅次于&lt;strong&gt;.一些布局小技巧重要内容HTML代码放在最前面, 小蜘蛛抓取HTML内容是按照文档流从上往下抓取的. 利用这个特点, 我们可以将重要的HTML放在上面, 然后可以通过CSS来进行布局.重要的内容尽量不要用JS输出, 小蜘蛛看不懂JavaScript~尽少使用iframe框架. 小蜘蛛是不会读取里面的网页的谨慎使用display: none; 小蜘蛛会过滤掉display: none里的内容不断的精简代码, 能使用一个标签就不要用两个标签扩展阅读Chrome - 搜索引擎优化 (SEO) 入门指南总结SEO其实面对的是搜索引擎, 然后搜索引擎再将搜索的结果, 根据权重展现给用户. 文中讲的只是一些基础的知识, 除此之外还有robots.txt, 站外友链等, 这里就不详谈了. 平时前端er日常工作中应该培养好的编程习惯, 了解了SEO的规则, 可以隐性给自己页面提升质量呢~]]></content>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 遍历绑定toggle icon, 动态切换action]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2FVue-v-for-%E9%81%8D%E5%8E%86%E7%BB%91%E5%AE%9Atoggle-icon-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2action%2F</url>
    <content type="text"><![CDATA[在Vue中实现动态绑定toggle action在遍历li标签时, 动态绑定点击事件, 当点击其中一个item时调用函数. 函数内判断是否处于action状态, 是则清除class, 从实现toggle的效果~ 按照这个思路也可以扩展为下拉菜单.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, index) in itemList&quot; @click=&quot;openItem(index)&quot; :key=&quot;item.id&quot; &gt; &#123;&#123; item.desc &#125;&#125; &lt;span class=&quot;icon&quot; :class=&quot;&#123;&apos;action&apos;: actionItem === index&#125;&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; itemList: [ &#123;desc: &apos;item1&apos;&#125;, &#123;desc: &apos;item2&apos;&#125;, &#123;desc: &apos;item3&apos;&#125; ], actionItem: null &#125; &#125;, methods: &#123; openItem (index) &#123; if (this.actionItem === index) &#123; this.actionItem = null &#125; else &#123; this.actionItem = index &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.list &#123; width: 500px; padding: 0; margin: 0 auto; text-align: left;&#125;.list li &#123; position: relative; margin: 14px 0; padding: 10px; border-bottom: 1px solid #ccc; list-style: none; cursor: pointer;&#125;.list .icon &#123; position: absolute; right: 10px; width: 0; height: 0px; border: 10px solid; border-color: #aaa transparent transparent transparent;&#125;.list .action &#123; border-color: rgb(254,0,0); border-radius: 50%;&#125;&lt;/style&gt;初次点击, action触发, 再次点击清除action]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包中的 install --save 和 install --save-dev之间到底有区别]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2F%E8%B0%88%E8%B0%88npm%E5%8C%85%E9%87%8C%E7%9A%84%20install%20--save%20%E5%92%8C%20install%20--save-dev%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当我们使用npm进行开发时经常能遇到需要安装依赖包, 那么npm install --save和npm install --save-dev之间到底有什么区别呢? 现在来探究一番.install –save-dev实际上--save-dev是开发时候所依赖的东西，如我们想添加自动添加前缀, 那么就安装autoprefixer到开发依赖去. 也就是编译打包后autoprefixer已经帮我们添加了相应的浏览器前缀, 那么我们之后就不需要依赖他了. 所以1npm install babel --save-dev在这里我们可以看到已经放进package.json中的devDependencies(开发依赖)中去了.install –save--save就是你发布之后还依赖的东西。 如果编译打包后还需要依赖的库, 如vue, 所以就放进了dependencies中(生产依赖).两者需要安装的依赖其实都可以在package.json中手动输入相应的库和版本号, 然后使用npm install就能进行安装package.json中的所有依赖了~]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在浏览器地址输入URL回车后，中间发生了什么？]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2F%E5%9C%A8Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%90%8E%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[最近在面试的时候遇到了一道比较经典的面试题, 在Chrome浏览器地址栏输入url, 回车之后会发生什么事?题目很经典, 自己也懂些大概. 不过抱着探究原理的精神. 也查询了相关的知识, 今天就来探讨一下, 浏览器的处理过程是怎么样的~Start当我们在地址栏输入网址时, 其实就是要向服务器请求我们想要的资源.1. 解析Url首先开始解析Url, 分析输入的Url还是搜索关键字2. DNS查询2.1. 浏览器缓存 然后浏览器开始检测域名是否还存在缓存中, 如果缓存没有就gethostbyname库函数进行查询.2.2 Hosts文件 gethostbyname函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里.2.3 本地DNS服务器 hosts 中也没有找到的话, 将会向DNS 服务器发送一条DNS查询请求.2.4 路由缓存 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用JavaScript删除全部的微博]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2F%E4%BD%BF%E7%94%A8JavaScript%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E7%9A%84%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[生活中常常会遇到一些繁琐重复而又没有意义的东西, 所以常有人说, 作为一个程序员, 应该避免做重复没意义的事, 我们学习编程最终的目的之一无非也是偷懒….. 能让自动的就坚决不手动. 当然, 除了在学习中自己造一些有意义的轮子除外. 今天就利用一些自己所学的知识去解决生活上的一些麻烦. 比如..自动删光微博黑历史~开始打开chrome浏览器(其他非IE现代浏览器都可以), 进入我的主页, 然后按下F12进入控制台.原理分析首先这次只是单纯的想通过JavaScript批量删除全部微博代替手动而已, 那么就简单了. 我们只需要模仿点击删除的动作.找到删除微博的key, 选中DOM元素, 这里我们可以看到菜单a标签中有一个属性action-type=&quot;fl_menu, 在控制台进使用document.querySelectorAll进行测试输出, 可以看到是一个NodeList的类数组, 分别对应着页面每一个fl_menu.点击menu弹出下拉菜单, 继续用同样的方法分析节点, 找出一个表示用于删除的属性. 一般来说, 一个合格的程序员都懂得编写语义化的代码, 这里先推测action-type=&quot;feed_list_delete这个属性是专属删除微博的属性, 使用document.querySelector将代码在控制台上测试输出. 获取到页面中第一个delete DOM, 模拟点击后弹出一个确定框, 再次使用相同的方法确定即可.代码实现一般网站都会限制用户频繁操作, 这里我们使用setTimeout, 测试一个weibo能够容忍的一个操作频率(可能还跟网速有关).12345678910111213141516171819202122232425window.onload = (function() &#123; // 经测试, 750ms是一个较快较稳定的频率, 效率过快会弹警告. var timer = setTimeout(Delete, 750); var item = 0; function Delete() &#123; /* 这里需要停止定时器等待加载, 请求XHR进行加载剩余微博. * 这里是微博的一个限制, 当页面中不存在相应的DOM, 就进行页面刷新. */ if (item &gt; 15) &#123; item = 0; clearTimeout(timer); return timer = setTimeout(Delete, 15000); &#125; // 模拟点击 document.querySelector('a[action-type="fl_menu"]').click(); document.querySelector('a[action-type="feed_list_delete"]').click(); document.querySelector('a[action-type="ok"]').click(); ++item; console.log(`已成功删除了$&#123;item&#125;项`); timer = setTimeout(Delete, 750); &#125;&#125;)();总结这样我们想要的效果就实现了.省去了一条一条删的人力, 又能运用到自己所学的知识. 其实代码代码也很简单, 无非是用到了setTimeout重复去递归调用而已. 要注意的是querySelector, 和querySelector都是IE9+的API, 在这里没有去考虑对IE的兼容, 并且也没有必要.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript深入理解-裁剪图片效果(选取框)]]></title>
    <url>%2Fblog%2F2017%2F11%2F17%2FJavascript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在生活中我们时常能看到这种图片裁剪的效果, 那么他实际上底层的原理是怎么实现的呢? 让我们深入的解剖一下.原理分析首先我们先将视图一分为三, 理解为三个层级叠加在一起的仰视图.最上面是可拖动的选择窗口中间待剪辑的可视窗口底层是一张opacity: .5的背景图片基础结构我们这里主要讲JavaScript, HTML与css就简要的过一下.首先HTML基本结构是两张相同的结构, 两张图片分别是调整过透明度的底图和一张被裁剪过了的中间层.mainBox包裹着选择的小方块square,相对定位于image在最上面一层.123456789101112131415161718&lt;!-- index.html --&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image1"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image2"&gt; &lt;div id="mainBox" class="main"&gt; &lt;div class="square left-up"&gt;&lt;/div&gt; &lt;div class="square up"&gt;&lt;/div&gt; &lt;div class="square right-up"&gt;&lt;/div&gt; &lt;div class="square right"&gt;&lt;/div&gt; &lt;div class="square right-down"&gt;&lt;/div&gt; &lt;div class="square down"&gt;&lt;/div&gt; &lt;div class="square left-down"&gt;&lt;/div&gt; &lt;div class="square left"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;123456789101112131415161718192021222324/* main.css */body &#123;background: #333;&#125;#box &#123;position: absolute;top: 100px; left: 200px; width: 460px; height: 360px;&#125;#box img &#123;width: 460px;&#125;#box #image1 &#123;opacity: .5;position: absolute; top: 0;left: 0;&#125;#box #image2 &#123;position: absolute; top: 0;left: 0; clip: rect(0, 200px, 200px, 0) &#125;#box .main &#123;position: absolute;border: 1px solid #fff; width: 200px; height: 200px;box-sizing: border-box;&#125;#box .main .square &#123;position: absolute; width: 8px;height: 8px; background: #fff&#125;#box .main .left-up&#123;left: -4px;top: -4px;cursor: nw-resize;&#125;#box .main .up&#123;left: 50%;top: -4px;margin-left: -4px;cursor: n-resize&#125;#box .main .right-up&#123;right: -4px;top: -4px;cursor: ne-resize&#125;#box .main .right&#123;right: -4px;top: 50%;margin-top: -4px;cursor: e-resize&#125;#box .main .right-down&#123;right: -4px;bottom: -4px;cursor: se-resize&#125;#box .main .down&#123;left: 50%;bottom: -4px;margin-left: -4px;cursor: s-resize&#125;#box .main .left-down&#123;left: -4px;bottom: -4px;cursor: sw-resize&#125;#box .main .left&#123;top: 50%;left: -4px;margin-top: -4px;cursor: w-resize&#125;#box &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125;JavaScript实现ESMAScript并没有提供可拖动的API, 那我们先来思考一下, 该如何实现拖动的功能~ 最上层有9个小方块(Square), 分别代表着不同方向的边界, 拖动这个边界, 无非需要实现这下面的底层步骤.鼠标落下(MouseDown) =&gt; 鼠标拖动 =&gt; 松开鼠标(MouseUp).先创建一个clipImage函数作为入口函数, 主要获取目标元素和生成DOM节点(后面讲), 绑定事件.先给小方块绑定一个鼠标落下事件(mousedown), 当触发事件(MouseEvent)时, 监听器调用onMousedown函数.onMousedown函数中, 接受四个参数e事件, box目标元素, ctrl小方块的方向, type属性, 主要是用来记录数据并暴露给全局变量进行通讯.12345678910111213141516171819202122232425262728293031;(function() &#123; // Util工具函数 var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; // "全局变量", 记录状态 var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var right = util.$('#box .main .right'); // Add mouse down event up.addEventListener('mousedown', function(e) &#123; onMousedown(e, box, up, 'up'); &#125;); function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 将接受到的信息暴露出去. _MainBox = box; _MainCtrl = ctrl; _MainType = type; &#125;&#125;)();紧接着来计算拖动的距离, 在onMouseDown函数上将moving拖动标记设为1(true也行).判断拖动的标记是否启动, 创建getPosition函数获取元素相对于页面左/上边的偏移量用于计算拖动的偏移量. 如下图.12345678910111213141516171819202122232425262728293031323334353637383940414243444546//初始化var moving = 0;function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; _MainBox = box; _MainCtrl = ctrl; _MainType = type; // 移动计算偏移量并设置到box上 moving = 1;&#125;// 获取元素相对于文档的距离function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;;&#125;// 监听鼠标相对于页面的坐标document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var addWidth, addHeight; var width = _MainBox.offsetWidth; // 相对于屏幕左/上的距离 var boxX = getPosition(_MainBox).left; switch(_MainType) &#123; case "right": addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; break; &#125; &#125;&#125;;紧接着我们会发现虽然实现了拖动的效果, 但是松开鼠标box宽度还是会随着鼠标变化. 这是因为还没有重置标记. 随即监听鼠标松开事件(MouseUp). 单边拖动就完成啦~12345// 鼠标松开document.onmouseup = function() &#123; // reset moving = 0;&#125;;整理归纳我们将switch里的代码整理出来. 装进函数里去调用. 相续的将各个方向也加上, 原理也是同理. 值得注意的是将右面和下面要加上box的宽高才能计算出来. 剩下四个边角, 如左上什么的其实就是同时调用正方位的两个函数实现的实现起来. 然后拖动功能就大功告成啦~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215;(function() &#123; var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var up = util.$('#box .main .up'); var down = util.$('#box .main .down'); var right = util.$('#box .main .right'); var rightUp = util.$('#box .main .right-up'); var rightDown = util.$('#box .main .right-down'); var left = util.$('#box .main .left'); var leftUp = util.$('#box .main .left-up'); var leftDown = util.$('#box .main .left-down'); // Add mouse down event right.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, right, 'right'); &#125;); up.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, up, 'up'); &#125;); down.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, down, 'down'); &#125;); left.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, left, 'left'); &#125;); leftUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftUp, 'leftUp'); &#125;); leftDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftDown, 'leftDown'); &#125;); rightUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightUp, 'rightUp'); &#125;); rightDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightDown, 'rightDown'); &#125;); &#125; /** * [onMousedown description] Mouse down event * @param &#123;[type]&#125; e [Event] * @param &#123;[type]&#125; box [target vessel] * @param &#123;[type]&#125; ctrl [Square DOM node] * @param &#123;[type]&#125; type [Square direction] */ function onMousedown(e, box, ctrl, type) &#123; _MainBox = box; _MainCtrl = ctrl; _MainType = type; moving = 1; &#125; // 获取元素相对于左边的距离 function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;; &#125; // 鼠标移动 document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var height = _MainBox.offsetHeight; // 相对于屏幕左/上的距离 var boxY = getPosition(_MainBox).top; switch(_MainType) &#123; case "right": right(e); break; case "up": up(e); break; case "down": down(e); break; case "left": left(e); break; case "leftUp": leftUp(e); break; case "leftDown": leftDown(e); break; case "rightUp": rightUp(e); break; case "rightDown": rightDown(e); break; &#125; &#125; &#125;; // 鼠标松开 document.onmouseup = function() &#123; moving = 0; &#125;; function right(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; &#125; function up(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; &#125; function down(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; &#125; function left(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = boxX - e.clientX; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = boxY - e.clientY; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function rightUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125; function rightDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125;&#125;)();&lt;– 努力填坑中~ –&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之三 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F11%2F06%2FBasic%20Algorithm%20Scripting%20-%203%2F</url>
    <content type="text"><![CDATA[今天让继续来学习数组方法的用法~Sum All Numbers in a Range题目描述&emsp;&emsp;传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。最小的数字并非总在最前面。比如传递[1, 4]会返回10, 即1 + 2 + 3 + 4.非数组方法1234567891011121314 function sumAll(arr) &#123; var max = Math.max.apply(null, arr); var min = Math.min.apply(null,arr); var num = max - min; var total = min; while(num) &#123; num--; total += ++min; &#125; return total;&#125;sumAll([1, 1]);&lt;– 未待续~ 有空再深挖 –&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过sourcetree实现远程仓库与本地仓库关联]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2F%E9%80%9A%E8%BF%87sourcetree%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率.&emsp;&emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联.步骤&emsp;首先把本地仓库初始化.&emsp;再添加到sourcetree上&emsp;进入github.com -&gt; your profile -&gt; repositories(仓库) -&gt; New&emsp;填写仓库信息, 复制仓库链接&emsp;设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定&emsp;然后就可以提交到github了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>sourcetree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Normalize与reset]]></title>
    <url>%2Fblog%2F2017%2F10%2F15%2F%E6%B5%85%E8%B0%88Normalize%E4%B8%8Ereset%2F</url>
    <content type="text"><![CDATA[前言: 在一次开发的时候, 发现团队中的小伙伴对normalize与reset都持有不同分歧. 趁着这事来谈谈, normalize与reset都有什么区别, 该如何取舍.resetreset, 顾名思义就是重置的意思. 最早的一份CSS reset来自Tantek的undohtml.css, Tantek根据自己的需要，对浏览器的默认样式进行了一些重置。早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题, reset 的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”.此后国内出现* {margin: 0, padding: 0}这种暴力清除全部样式的reset出现.normalizeNormalize, 从字面上也理解也就是使其正常化. 这是css reset的一个代替方案.Normalize相对「平和」, 注重通用的方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。创造normalize.css的目的主要是:保护有用的浏览器默认样式而不是完全去掉它们一般化的样式：为大部分HTML元素提供修复浏览器自身的bug并保证各浏览器的一致性优化CSS可用性：用一些小技巧解释代码：用注释和详细的文档来相比两者的利弊那么相对来说, 两者之间又有什么区别呢? 这里引用一下知乎用户的回答.CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理，简单粗暴地一视同仁是不好的。body 那一圈确实挤压了页面的生存空间，那就改掉。士农工商，谁有谁的作用，给他们制定个规范，确保他们在任何浏览器里都干好自己的活儿。然而在实际项目中, 为了还原设计图我们并不需要这种自带特性, 因此可以根据项目的需求将我们常用的标签进格式化, 但也不是跟传统的reset那样粗暴.因为传统的reset的很多清除默认样式是无意义的, 是浪费性能的. 就比如&lt;li&gt;, 人家生来就没有margin padding, 干嘛非要给人家加个margin: 0上去呀??? h1~h6标签虽然有margin没有padding呀! 也不要一棒子全打死啦! 其实这是不严谨的态度.以下的代码可以作为针对项目需求的进行调整. 这样看下去是不是舒服简洁多了呢? 也减少了很多无意义的性能损耗何乐而不为呢.1234567891011121314151617181920212223242526 body, dl, dd, h1, h2, h3, h4, h5, h6, p, form, ol, ul &#123; margin: 0;&#125;ol, ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none;&#125;body &#123; font: 14px/1.6 Monda,PingFang SC,Microsoft YaHei,sans-serif;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: block;&#125;.clearfix:after &#123; clear: both;&#125;参考资料:Normalize.css 与传统的 CSS Reset 有哪些区别？normalize、reset与base关于CSS Reset 那些事（一）之 历史演变与Normalize.css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之二 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F19%2FBasic%20Algorithm%20Scripting%20-%202%2F</url>
    <content type="text"><![CDATA[数组方法的深入学习Chunky Monkey(分割数组)猴子吃香蕉, 分割数组,把一个数组arr按照指定的数组大小size分割成若干个数组块。例如:&#8195;&#8195;hunk([1,2,3,4],2) =&gt; [[1,2],[3,4]];&#8195;&#8195;chunk([1,2,3,4,5],2) =&gt; [[1,2],[3,4],[5]];思路&#8195;这道题重点主要是每size个值分割一个数组,这里我们可以使用以下几种方法来解题.while + splicefor + slicewhile + slice第一种12345678910111213141516// while + splicefunction chunk(arr, size) &#123; // 定义一个新数组和用来临时存放分割的空数组. var a = [], t = [], i = 0, len = arr.length; while (i &lt; len)&#123; t = arr.splice(0, size); a.push(t); i += size; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3);&#8195;在这里值得注意的是,len保存arr.length的快照是必须的..因为splice会修改原来原来的数组.第二种12345678910111213141516171819// for + splicefunction chunk(arr, size) &#123; var a = [], t = [], len = arr.length; // 数组中的个数小于size或者size是小于等于0的也就没有必要分割了 if (len &lt;= size || size &lt;= 0) &#123; return arr; &#125; else &#123; // 它的重点主要是数组中的值的数量 for (var i = 0;i &lt; len; i += size) &#123; // 查询指定数 t = arr.slice(i, i + size); a.push(t); &#125; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3);第三种1234567891011121314// while + slicefunction chunk(arr, size) &#123; var a = [], t = [], i = 0, len = arr.length; while (i &lt; len) &#123; // 查询的值 t = arr.slice(i, i += size); a.push(t); &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3);Falsy Bouncer(过滤数组假值)删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。思路&#8195;这道题比较有意思..一开始我走进了一个误区,想着单纯return x !== false &amp;&amp; ...这样简单的返回就可以了,后来发现在处理NaN时会很麻烦..isNaN()还会把英文字符串也给过滤掉,再加上多个&amp;&amp;使得代码会变得繁乱,可读性不高.&#8195;然后查阅了一番资料后,才注意到平时被忽略Boolean()的一些特性对于处理这种类型的问题简直不能太合适.12345678910function bouncer(arr) &#123; // 请把你的代码写在这里 var a = arr.filter(function(x) &#123; return Boolean(x); &#125;); return a;&#125;bouncer([7, "ate", "", false, 9]);&#8195;摘至MDN.Boolean 的描述:如果Boolean构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的Boolean对象的值为false. 其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为true的Boolean对象.Seek and Destroy (摧毁指定数组)实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。实现原理&#8195;filter() 为数组中的每个元素调用一次 callback函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组.&#8195;filter()从头至尾遍历数组,若回调函数返回的是true(通过测试),就存入新数组中.若返回的是false,则过滤掉.12345678910111213141516function destroyer(arr) &#123; // 先将第一个参数隔开,定义一个储存着待移除的空数组 var args = arguments[0], removeArgs = []; // 要被删除的参数装进'removeArgs'里 for (var i = 1; i &lt; arguments.length; i++) &#123; removeArgs.push(arguments[i]); &#125; // 遍历'args',若'removeArgs'中不存在'value',应该返回-1.反之返回false被过滤掉. return args.filter(function(value) &#123; return removeArgs.indexOf(value) === -1; &#125;);&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3);Where do I belong (数组排序并找出元素索引)先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。&#8195;举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。&#8195; 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。思路&#8195;这个没啥好说的了..将第二个参数push进数组中,再进行排序.排序后通过indexOf()来实现功能.不过需要注意的是sort默认是按照’Unicode’编码进行排序的.Caesars Cipher (凯撒密码)风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。思路&#8195;本次练习用到String.charCodeAt()和String.fromCharCode(),首先来查询字符串的Unicode字符.&#8195;根据Unicode表我们得知:小于65和大于90对应的就是数字和小写字符a-z大于等于65和小于等于77对应的就是大写字符A-M (13位)大于等于78和小于等于90对应的就是大写字符N-Z&#8195;ROT13的功能就是移位,如果序号小于78(A-M字母)，使用String.fromCharCode()转换成该序号加13的字符,反之减13.1234567891011121314151617181920212223function rot13(str) &#123; // LBH QVQ VG! var newStr = []; for (var i = 0;i &lt; str.length;i ++) &#123; // 查询每个字符串的Unicode编号 var temp = str.charCodeAt(i); // 非大写字母,空格,数字等都不转换 if (temp &lt; 65 || temp &gt; 91) &#123; newStr.push(str.charAt(i)); continue; // 大于77(N-Z),就转换成该序号 - 13的字符串. &#125; else if (temp &gt; 77) &#123; newStr.push(String.fromCharCode(temp - 13)); // 小于78(A-M),就转换成该序号 + 13的字符串 &#125; else &#123; newStr.push(String.fromCharCode(temp + 13)); &#125; &#125; return newStr.join('');&#125;rot13("SERR PBQR PNZC"); // 你可以修改这一行来测试你的代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法深入研究之一 (基础算法)]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2FBasic%20Algorithm%20Scripting%20-%201%2F</url>
    <content type="text"><![CDATA[一些基础的算法练习Palindromes(回文处理)Palindromes称之为回文。在中文文当中是指倒着念和顺着念都是相同的，前后对称.正则表达式replace()1234567function palindrome(str) &#123; var string = str.replace(/[\W_]/g,'').toLowerCase(); var replaceStr = string.split('').reverse().join(''); return replaceStr === string;&#125;palindrome("eye"); // true思路&#8195;首先对字符串进行处理..去掉字符串多余的标点符号和空格，然后把字符串转化成小写.&#8195;split把字符串拆分为一个字符串组成的数组.reverse反转数组顺序,join拼接字符串.Title Case a Sentence(首个单词字母大写)句中单词首字母大写,确保字符串的每个单词首字母都大写，其余部分小写。1234567function titleCase(str) &#123; return str.toLowerCase().replace(/( |^)[a-z]/g, function(L) &#123; return L.toUpperCase(); &#125;);&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot思路&#8195;首先把字符串转换为小写,再用正则匹配带空格或者就字母开头的首个字母replace替换成大写字母.Return Largest Numbers in Arrays(返回数组最大的数字)找出多个数组中的最大数,并返回一个新数组12345678910111213function largestOfFour(arr) &#123; // 请把你的代码写在这里 var count = []; for (var i = 0; i &lt; arr.length; i ++) &#123; var a = arr[i].sort(function (a,b) &#123; return b-a; &#125;); count.push(a[0]); &#125; return count;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); // [5,27,39,1001]思路&#8195;新定义一个数组,遍历传进来的数组进行从大到小排序,将排序后最大的数push进新的数组count最后再返回.Confirm the Ending(检查字符串结尾)检查字符串结尾,判断一个字符串(str)是否以指定的字符串(target)结尾。如果是，返回true;如果不是，返回false。123456789101112function confirmEnding(str, target) &#123; var l = str.length - target.length; if (str.substr(l) === target) &#123; return true; &#125; else &#123; return false; &#125;&#125;confirmEnding("Connor", "n"); // falseconfirmEnding("Bastian", "n"); // trueconfirmEnding("He has to give me a new name", "me"); // true思路&#8195;乍一看好像挺麻烦的样子,容我们深入一看却发现好像并没有想象中的麻烦..&#8195;这里用上了String.prototype.substr()而参数start是一个字符的索引,把字符串str.length - target.length就可以对比结尾字符串是否一样了.Repeat a string repeat a string(重复输出字符串)重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。&#8195;对于这种题目可以使用两种方法解决:递归while循环12345678910111213// 第一种使用递归function repeat(str, num) &#123; // 请把你的代码写在这里 if (num &lt; 0)&#123; return ""; &#125; else if (num === 1) &#123; return str; &#125; else &#123; return str + repeat(str, num - 1); &#125;&#125;repeat("abc", 3); // "abcabcabc"1234567891011// 第二种使用whilefunction repeat(str, num) &#123; var s = ''; while(num &gt; 0)&#123; s += str; num --; &#125; return s;&#125;repeat("abc", 3);思路&#8195;递归一般放进if()判断语句中,是一种通过重复地调用函数本身,逐次减少num的值来实现效果.第二种使用了while语句,每调用一次就递减1,直至num &gt; 0.Truncate a string(截断字符串)截断字符串,如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。插入到字符串尾部的三个点号也会计入字符串的长度。如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。12345678910111213function truncate(str, num) &#123; // 首先判断num的值是不是大于字符串的长度,若是,那就没有必要省略了. if(num &gt;= str.length) &#123; return str; &#125; else if (num &lt;= 3) &#123; return str.slice(0,num) + "..."; &#125; else &#123; return str.slice(0,num-3) + "..."; &#125;&#125;truncate("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length);思路&#8195;slice截取字符串.substr(),indexOf()和lastIndexOf()办法同理.https://www.w3cplus.com/javascript/confirm-the-ending.html 大漠老师有一篇文章对此使用有着更详细的说明.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ffc</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
