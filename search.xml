<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从搭建到部署，快速构建一个私人博客]]></title>
    <url>%2Fblog%2F2019%2F08%2F19%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[有时候我们希望有一个受控的博客，来记录或分享一些东西。这个博客的主题内容由你自己来决定，可以是技术分享(编程、汉化分享等)，也可以是生活感想。本文将介绍一个可以迅速搭建并部署的受控博客。阅读本文前，希望你对以下知识点有所了解:git(版本控制) 的基础使用markdown 的使用为什么要搭建博客在线类博客有很多选择，为什么我们需要从零搭建新的博客呢？自己搭建的博客有什么好处吗？首先，前文所提的 “博客受控”，指的就是能够自己控制的博客的样式、内容等，自己想怎么改就怎么改。内容受控是指我们知道在线类的博客是受平台限制的，这意味着你所发表的内容是需要受审才能发出的，一些敏感的技术词汇，该篇文章都可能会被和谐或被删除。但在自己搭建博客就没有这样的问题，最起码能保留源文件。其二，博客的样式是受控的。像著名在线博客CSDN上一些博主的文章确实是有学习参考的价值，但问题的是该站广告是在是太多了，字体和排版的阅读体验并不太好。但如果是自己搭建的博客的话，就可以自己着手优化这些问题。但博客的搭建还需要我们从各方面考虑利弊。平台类博客会有相应的推荐系统，会对同类型文章相互引流，在 SEO 方面会做得比我们好。个人搭建的博客，刚起步时的浏览量并不高，但是可以通过SEO等方式来逐步增加自己网站的权重。或者提高博客的质量和干货，读者认为文章有价值，自然会收藏起来形成熟客。那么博客能写什么东西呢？在日常生活中，有很多知识点是呈碎片状，写博客的本质上就是对自己知识的一种梳理，然后再将这些知识分享出来，可能会有对这方面知识有疑惑，或者想找到解决方案，自身分享出来的东西能给读者做一定的参考。同时这也会是一个良性循环，因为分享的同时，你可能也需要去查询一些资料，同时也可以找到别人遇到过并分享出来的解决方案，是一个相互收益的过程。我们的基本需求是梳理与分享，那么更应该把注意力放在内容本身，网站布局的排版样式等则是增加读者阅读体验的问题。因此我们可以使用现成的博客框架快速完成这些事。博客框架有很多种选择，笔者选择的是 Hexo，因为它足够便捷优雅。startHexo 依赖 Node.js 和 NPM包管理，Node.js 安装后一般会自带NPM。我们打开终端(Windows PowerShell / cmd.exe、bash、macOS 里的终端)，输入以下命令:12345678910# 检查 npm 是否安装成功npm -v# 安装 hexo cli，# 如果安装速度过慢的话，可以安装国内的淘宝镜像# 在命令行输入 ` npm install -g cnpm --registry=https://registry.npm.taobao.org`npm install -g hexo-cli# 检查 hexo 是否安装成功，并查看版本hexo -v 依赖安装成功后，我们可以在命令行输入 hexo help 查看使用方式(描述是英文，示例部分笔者将其转为中文): Usage: hexo &lt;command&gt; command description help 获取命令的帮助 init 创建一个新的 Hexo 文件夹 version 显示版本信息 使用 hexo help [command] 可以查看更多的信息, 如: 123456789101112hexo help init# Usage: hexo init [destination]# Description(描述):# 在指定的路径或当前目录中创建一个新的Hexo文件夹.# Arguments（参数）:# destination 文件夹路径。 如果未指定，则在当前文件夹中初始化# Options（选项）:# --no-clone 复制文件而不是从GitHub克隆# --no-install 跳过 npm 依赖安装(默认初始化会自动装依赖) 全局选项： options description --config 指定配置文件而不是使用默认的 _config.yml --cwd 指定 CWD --debug 显示终端中的所有详细消息 --draft 显示草稿帖子 --safe 禁用所有插件和脚本 --silent 在控制台上隐藏输出 在官网 commands 中可以找到全部完整的解释。 建站在终端上，我们可以看到有一个 init 的命令，我们可以使用这个命令来初始化 hexo 项目，但再建站之前我们需要先决定在哪里存放博客源代码。 我推荐使用如微软的 OneDrive（win10 系统自带）之类的云文件夹。你可以白嫖它 5G 的云储存空间。当你在设备A下修改了文件，它会自动同步到云端上。切换回设备B并登录账号后，它又会自动从云端下载数据，是一个便捷的方式。 但值得注意的是 OneDrive 毕竟是国外服务，由于众所周知的原因可能需要科学上网才能使用。该方式只是数据备份与同步的问题，不使用它也不会影响下文的构建。 1234567891011# 如果你是 unix 系统的话，可以使用该命令查看当前路径pwd# /Users/anran/OneDrive# 初始化文件夹名为 bloghexo init blog# INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git# other install info ...# 进入文件夹cd blog 安装完成后目录如下: 123456789.├── _config.yml (网站的配置信息)├── package.json (应用依赖信息)├── node_modules (依赖包)├── scaffolds (模板文件)├── source (资源文件夹是存放用户资源的地方)| ├── _drafts (草稿文件夹，刚初始化时可能不存在)| └── _posts (文章/帖子源码列表)└── themes (主题) 配置建站完成后我们需要进行 配置，hexo 中主要有两项配置。一项是站点配置文件，路径为 /_config.yml。另一项是主题配置文件,路径是/themes/(下载的主题)/_config.yml。 我们可以先在站点配置文件修改以下基础选项: 12345678910111213141516171819# Hexo Configuration# 网站主标题，SEO元素之一title: blog#网站副标题，可选subtitle:# 网站描述, SEO元素之一，用于告诉搜索引擎关于这个站点的描述description: 分享生活、分享技术# 网站的关键词，如:keywords: Front end# 网站作者author: anran758# 网站使用的语言, 由于 Hexo 具备多语言配置，默认为英文，我们需要修改回中文语言language: zh-CN 启动初始化项目后默认会安装相关的依赖，接着在命令行输入如下命令来运行博客： 12345678# 启动服务，默认端口为 4000，启动服务后可以在浏览器输入 `http://localhost:4000` 查看效果hexo server# or 简写方式hexo s# 还可以使用 -p, 指定 9000 端口hexo s -p 9000 写作步骤我们一般通过命令行来操作博客: 比如创建文章的方式如下: hexo new [layout] &lt;title&gt; layout是指定布局，Hexo默认有post、page 和 draft 三种布局，它们分别对应不同的路径。我们也可以自定义布局，但实际页面会和post相同，都将储存到source/_posts文件夹。 按照我个人的写作习惯，通常写作步骤是： 创建草稿(drafts) 在草稿上进行写作 整理细节并在本地服务器上查看效果(server) 发布至正式的帖子上 生成静态文件并部署(后续讲) 创建草稿(drafts) 12$ hexo new draft "My first post"# INFO Created: ~/blog/source/_drafts/My-first-post.md 在初次创建草稿会生成一个名为 _drafts 的草稿文件夹，接着该文件夹下有一个我们刚刚创建的草稿，名为 My-first-post.md 的 markdown 文件，文件内容如下: 1234---title: My first posttags:--- 在本地服务器查看草稿(drafts) 我们可以启动本地服务器一边写作一边预览,但默认情况下草稿是不会被展示出来的，如果你想查看草稿的话，可以输入以下命令: 12345$ hexo s -p 9000 --draft# INFO Start processing# INFO Hexo is running at http://localhost:9000 . Press Ctrl+C to stop.# 如果需要退出服务器，按住 control + c 发布草稿(publish) 如果我们在本地服务器上校队完草稿细节后，可以将草稿发布为文章，否则在后续生成博客静态文件时不会被打包出来: 1234# hexo publish [layout] &lt;filename&gt;# 将草稿发布为文章$ hexo publish post My-first-post# INFO Published: ~/blog/source/_posts/My-first-post.md 输入命令后你可以发现发布的文章被转移到了source/_posts/上，这样就完成了本地的文章发布。 生成静态文件(generate) Hexo框架的一项工作就是将源文件 markdown 最后生成为 HTML： 123456789101112131415# 生成文件$ hexo generate# INFO Start processing# INFO Files loaded in 275 ms# INFO Generated: 2019/08/11/My-first-post/index.html# INFO 1 files generated in 152 ms# 简写形式$ hexo g# 监控文件变化，并生成静态文件$ hexo g --watch# 生成文件并部署(部署后面单独章节来讲解)$ hexo g -d 主题我们熟悉完博客系统的操作后，接下来就是美化博客。Hexo 支持主题，我们可以根据官网的创建主题教程自己来设计，也可以直接在主题商城 中找现成的主题。这里以笔者推荐的主题 Next 为例: 笔者一开始使用 next 主题时，版本才 5.x，当时仍有很多博客所需的东西没有集成。如今回头一看，发现 next 升级了好几个大版本。github 主题仓库也迁移至了 https://github.com/theme-next 里，乃至文档都有两个不同的版本。 新文档是采用它自身主题的一个scheme来建成，是全英文文档，可以保证信息资料是最新的。旧文档布局便于阅读，同时是中文文档，大多参数也能在该文档找到，但毕竟没有再过多的维护，建议还是以最新文档为参考。 安装主题可以通过git clone克隆至blog/theme/下: 12345678$ pwd# /Users/anran/OneDrive/Blog# 启动主题前需要清除缓存与已部署的文件$ hexo clean# clone 主题$ git clone https://github.com/iissnan/hexo-theme-next themes/next 接着在 站点配置文件(/_config.yml) 中启动 theme。再打开主题配置文件(/themes/next/_config.yml)选择 Scheme: 123456789# _config.yml- theme: landscape+ theme: next# /themes/next/_config.yml# 提供三种模式#scheme: Muse#scheme: Mistscheme: Pisces 评论、订阅、数据统计、SEO 等部分功能配置已经集成至 next 主题配置中，但大多还需要额外添加依赖还需要根据文档来配置。next 在主题配置中集成了由于配置自定义项过多，读者可以根据自己所需添加相应的统计、SEO 相关的 app key 等就不进一步展开讲。 部署我们使用git进行部署，可以将网站部署至私人服务器、也可以部署到免费的github pages上。本文将介绍部署至github的方法，如果你还没有github账号的话，那你需要先注册一个账号。 步骤如下: 访问github.com，点击sign up注册账号。 进入注册页，输入账号密码和邮箱，输入验证码! 选择免费用户 接着是关于github推荐服务的调查，当然你也可以跳过它. 验证完毕后，它会提示你创建一个仓库，这里我们先创建一个blog。 复制仓库链接，copy 至 站点配置文件(/_config.yml)里。同时安装hexo-deployer-git的依赖： 1npm install hexo-deployer-git --save 1234567url: https://yourname.github.io/blog # 修改为 github io 的地址root: /blog/ # 要将资源映射到仓库名deploy: type: git repo: https://github.com/yourname/blog.git # blog 的 git 地址 branch: gh-pages # 发布至 gp-pages 分支，如果该分支不存在，就会自动创建它 接着开始部署。如果你还没配置git账号的话，它会提示你输入账号密码，输入正确的账号密码后就部署成功了。 1234567891011121314151617181920212223242526272829303132333435363738# 或者使用`hexo d -g`, 两者是等价的效果hexo g -d# *** Please tell me who you are.# Run# git config --global user.email "you@example.com"# git config --global user.name "Your Name"# to set your account's default identity.# Omit --global to set the identity only in this repository.# fatal: unable to auto-detect email address (got '29625@DESKTOP-0R7P8H4.(none)')# Logon failed, use ctrl+c to cancel basic credential prompt.# Username for 'https://github.com': anran758INFO Start processingINFO Files loaded in 621 msINFO 0 files generated in 424 msINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...INFO Congratulations! Your are using the latest version of theme NexT.Enumerating objects: 131, done.Counting objects: 100% (131/131), done.Delta compression using up to 8 threadsCompressing objects: 100% (91/91), done.Writing objects: 100% (131/131), 257.72 KiB | 2.48 MiB/s, done.Total 131 (delta 43), reused 0 (delta 0)remote: Resolving deltas: 100% (43/43), done.To https://github.com/yourname/blog.git * [new branch] HEAD -&gt; gh-pagesBranch 'master' set up to track remote branch 'gh-pages' from 'https://github.com/yourname/blog.git'.# 如果没有配置全局 git 账号的话可以先配置，不然下次部署还是会提示你输入账号密码git config --global user.email "you@example.com"git config --global user.name "Your Name" 接着在我们创建的blog下进入settings项，设置 github pages 为 gh-pages 也就是之前在配置里设置的分支即可。这样就可以在线上查看我们部署的状况啦~]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[环境搭建] 从零开始配置前端开发环境]]></title>
    <url>%2Fblog%2F2019%2F07%2F26%2Fconfiguring-mac-front-end-development-env-from-zero%2F</url>
    <content type="text"><![CDATA[前段时间更换了设备，正好趁着这个机会来记录一下适合前端开发的一个环境，以及推荐提高效率的应用。基础环境Node.js 是JavaScript运行时，目前前端工程化必不可缺的一个环境。通常我们会选择稳定版本(LTS)进行下载。NPM 是javascript的包管理工具，也是目前Node.js默认的包管理工具。一般下载了Node.js后会附带npm，不用专门的去下载。YARN 是Fackbook开源的依赖管理包，和npm是做同样的工作，但相比npm安装依赖的速度会更加迅速。两者都是讲依赖写入package.json中，在使用习惯上是相近的。Git 是最先进的代码版本控制软件。开发环境关于编辑器目前前端开发主流的编辑器有 sublimeText、WebStorm、vscode，三种主流器各有特点:sublimeText是一个十分轻巧的编辑器，在 macOS 上下载该软件仅需 15.2MB. 由于轻巧的缘故，很多那你所需的环境需要安装相应的插件，比如你可能需要某个语言的语法高亮，因此你需要在 store 上找到相应插件来提高你开发体验。然后该编辑器是付费软件(虽然可以无限试用webStorm 是一个功能强大的编辑器，同时也是一个付费软件，并不像sublimeText那样可以无限试用，由于功能太过于齐全，一些低配置的电脑可能会吃不消。以上特点是群友对webStorm的评价，笔者没有使用该编辑器，不过多评论。vsocde 是由微软开源的一个编辑器，虽然是后起之秀，但开源后该编辑器的设计与体验迅速吸引了一大批用户。它内置了一些前端基础的开发环境，针对Node.js还可以进行短点调试。笔者一开始也是sublimeText用户，但自从使用了vscode后就再也回不去了，因为确实是太好用了!vscode其中有一个插件叫做 setiings sync , 它可以将你的编辑器配置上传至gist。就算你换了一个全新的设备，下载vscode后，再下载该插件，传入Token后就可以同步你所有的配置，十分的方便~vscode的配置可以查看该文章: [环境搭建] 从零开始配置 vscode关于浏览器前端的工作更多时候是与用户打交道，我们的工作产出通常在浏览器页面上呈现。浏览器通常提供了开发者工具以供开发者调试，要选择浏览器作为调试可以先参考目前市面的浏览器份额： 目前市面上主流的浏览器主要就是chrome、Safari、IE/Edge、opera、firefox这五种浏览器。国内市场有UC浏览器等，但内核的大多都是采用webkit或者兼容低版本IE内核。从 statcounter 上我们可以看到浏览器市场份额，选中 Edit Chart Data, 再选择 Region 为 China, 我们就能看到中国浏览器市场份额的数据, 以 2018.07 - 2019.07 的趋势为例:从统计数据来看目前主要的趋势还是以chrome所使用的webkit内核作为主流，同时chrome的开发者工具对于开发人员十分的友好，因此有很多的开发者选择了该浏览器作为首选的调试工具。chrome还有一个便利就是登陆了谷歌账号后，可以在别的机器上进行同步插件和配置。打开chrome，右键页面并选中 “检查“即可打开开发者工具，chrome的具体使用参考下面几篇文章:Chrome 键盘快捷键Chrome 开发工具指南关于设计图每个团队的设计师提供的设计图可能是不一致的，有些团队的设计师可能使用Skitch, 一个可以直接导出为html文件的设计图、有些则直接提供PSD文件。如果要在两者当中选择，那么我更喜欢PSD的设计图。虽然Skitch导出的设计图可以直接查看每个元素的尺寸，但没有标注和测量的功能。PSD文件通常是源文件，可以在设计软件中打开，可以查看具体设计的详细信息。打开PSD文件通常有两种方式：Photoshop这个著名的设计软件就不必再多说了吧，优点是功能齐全，你想要的这里都有，缺点是具备一定的学习成本，功能繁多带来的问题就是眼花缭乱。PxCook 就是专门为前端与设计师协作的工具，阉割了开发所用不到的功能，具备各种标注于测量。扩展应用有了以上的环境其实就可以投入开发了，但实际工作中还是不太够用，我们需要添加一些好用插件或者工具可以增加效率~chrome 插件下面推荐一些比较好用的开发类插件，但链接需要科学上网才能访问：Markdown Preview Plusmarkdown 是程序员最常用的一个文件之一，默认情况下chomre查看markdown是无格式文字展示，可以安装此插件将markdown格式为文档。Enhanced GitHub该插件将增强github的功能，能显示仓库的大小，能够支持下载单个文件等。GitHub Hovercard该插件提供 hover card, 显示用户信息、仓库信息、issue、ccommit 信息等。JSONViewJSON是一个通用的数据格式，无论是前端还是后端都会跟这个数据格式打交道，有时我们直接在URL打开会返回JSON接口后，会在页面上显示一串字符串对象，并不太方便阅读数据。该插件就是格式化返回的JSON, 使其美观。NIM(Node.js 调试管理工具)Node.js的调试工具，具体教程商城页有介绍。Vue.js devtools、Redux DevTools、React Developer Tools对应前端框架开发必备的 devtools，需要的时候再安装也不迟。Proxy SwitchyOmega开发中还是必不可免会有使用代理的情况，该插件可以轻松快捷地管理和切换多个代理设置。应用SourcetreeSourcetree 是Git GUI，使用可视化界面来对代码进行版本控制，操作起来会比较友好。Git flow该包封装了release、feature、hotfix等项目代码管理流程，减少输入git命令过程。git flow也被封装进了 SourceTree 中，只不过一个是带有 UI 界面的软件，另一个是直接在命令行使用的包，满足不同人的需求。PostmanPostman是一个跨平台的应用，它拥有完整的API开发环境，该应用前后端的朋友都能使用的了。在Chrome插件商城中你也能找到它，安装后会自动将该应用离线下载至本地。如果你更偏爱于命令行，可以尝试curl。Mac 环境针对 macOS 环境的补充Homebrew: macOS 的包管理器，如果需要使用 macOS 进行开发的话，请务必安装该包！scrollreverser： 可以将鼠标和触摸板设置不同的方向。ShadowsocksX-NG: 查看更广阔知识库的钥匙SwitchHosts: 开发中难免会修改hosts，该款软件可以用于快速切换hosts文件。iterm2: macOS 默认的终端实际上并不太好用，iterm2的出现就是为了替代默认的重点，它支持更多的功能。oh-my-zsh: 默认的终端或者iterm2的外观并不太美观~ zsh框架能使你的终端颜值更上一步~ 不仅如此，它作为一个框架，有更多的插件和主题可选择，感兴趣的朋友可以深究一下~]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>macOS</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant design pro 使用 no-mock 造成 POST 请求被重定向为 GET 请求]]></title>
    <url>%2Fblog%2F2019%2F07%2F16%2Fant-design-redirect-change-method%2F</url>
    <content type="text"><![CDATA[最近在 ant design pro 的项目遇到了一个奇怪的问题，在输入命令行npm run start:no-mock后，发现预期发出POST请求变成了GET请求，状态码是301永久重定向。而在使用mock数据中不会出现这种问题。因此使用断点调试，经过一番尝试，逐步检查函数的调用及传参问题，最后也将此问题排除掉了。随后想到问题是不是出现在类库身上，接口是基于dva/fetch进行封装的，而dva/fetch又是基于浏览器原生(native code)的fetch进行封装. 使用断点并没有进入fetch内部。为了缩小范围，将发出请求的参数和方法从Network中拷贝下来，使用fetch直接调用，发现只要不经过umi类处理就不会出现这种现象。12345// 通过 dva/fetch// request('/api/login', &#123; method: 'POST', body: &#123;username, password&#125; &#125;)// 直接调用原生 fetchrequest('https://zzz.xxx.com/api/login', &#123; method: 'POST', body: &#123;username, password&#125; &#125;) 随后在network上我注意到，通过umi处理后的请求URL有点奇怪: 虽然我没有研究过umi的具体实现细节，但可以推测出umi是通过config拿到proxy.target作为base url. 但项目中target使用的协议是http协议，在实际的network中被转换为了https. 难不成就是这个在作祟？抱着尝试的态度将target上的协议转为https, 发现就能正常的发出POST请求了。。 但这样就会很迷茫，真的是umi干的吗？由于该项目基础架构另一个团队上接手上来的，有了很多复杂的因素干扰，method在哪一步进行了转换呢? 然后为了解惑做了一些简单的排查: 从网络原理来考虑，这种情况应该是在客户端发生的，为了排除服务端重定向的嫌疑，使用了抓包查看了没有经过浏览器格式的报文信息，确定了是客户端的问题。接着去看了部分源码也没有看到相关的逻辑。 最后近期业务量还挺重的，因此在此文记录一下，后序会继续关注一下这个问题，了解到原因再回来补充。 由于项目是运行在内网中，因此没有升级umi最新版本(内网可能没有最新的版本的镜像), 也有可能在最新版已经修复但没有继续尝试了。如果有遇到相同问题的同学可以了解一下这个情况。 1234&#123; "umi": "^2.0.1", "umi-plugin-react": "^1.0.1"&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>ant design pro</tag>
        <tag>react</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在本地测试微信登录]]></title>
    <url>%2Fblog%2F2019%2F05%2F18%2Fwechat-pc-login%2F</url>
    <content type="text"><![CDATA[在做微信登录的时候，希望能在本地能够测试登录。这里使用的是微信开放平台的网站应用微信登录, 与微信公众平台不同，微信开放平台并没有提供测试号的服务，因此在调试起来会十分的麻烦。比较传统的方法就是部署上测试服务器上专门先测试这一个接口。但从流程上来说，会比较麻烦，不够高效。下文将分享另一种测试的过程。代码编写首先在页面引入微信的js文件：1&lt;script src="//res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js"&gt;&lt;/script&gt; 然后在登录页上实例化登录对象： 12345678910111213141516171819202122232425262728293031&lt;!-- login.vuw --&gt;&lt;template&gt; &lt;div class="container"&gt; &lt;div id="login_container"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// other code ...export default &#123; // other code ... mounted() &#123; APIs.login(&#123; redirect_uri: Base64.encode('http://apitest.anran758.com') &#125;).then(res =&gt; &#123; /* eslint-disable no-new */ new WxLogin(&#123; id: 'login_container', // appid: "", // scope: "", // redirect_uri: "", // state: "", // style: "", // href: "" ...res.data &#125;); &#125;) &#125;,&#125;;&lt;/script&gt; WxLogin接收一个对象，对象属性如下所示。其中对象里的appid, scope，redirect_uri, state四个属性是由后端控制返回的。 参数 是否必须 说明 self_redirect 否 true：手机点击确认登录后可以在 iframe 内跳转到 redirect_uri，false：手机点击确认登录后可以在 top window 跳转到 redirect_uri。默认为 false。 id 是 第三方页面显示二维码的容器id appid 是 应用唯一标识，在微信开放平台提交应用审核通过后获得 scope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可 redirect_uri 是 重定向地址，需要进行UrlEncode state 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 style 否 提供”black”、”white”可选，默认为黑色文字描述。详见文档底部FAQ href 否 自定义样式链接，第三方可根据实际需求覆盖默认样式。详见文档底部FAQ 该方法会生成一个二维码，并挂载到指定的容器 ID 上。用户扫描二维码时，页面会向微信服务端发送一个请求等待用户确认，用户确认完成后，就会将页面重定向至指定的路径（redirect_uri）。 那么现在问题就来了：重定向的地址要跟微信开放平台里设置的重定向的域名一致，就是说我们在本地开发起的localhost:8080这种是不行的。这时我们就会想到了去修改hosts，但光改hosts是不行，还需要改端口。。这时就可以用到shistle了。 shistlewhistle是基于Node实现的跨平台web调试代理工具，主要用于查看、修改HTTP、HTTPS、Websocket的请求、响应，也可以作为HTTP代理服务器使用。我们可以使用它来进行转发： 通过 npm 来安装 whistle: 12345678# 全局安装 whistlenpm install -g whistle# 启动 whistlew2 start# 指定端口号来启动 whistlew2 start -p 9000 安装完毕后命令行提示我们可以进入 whistle 的控制台(默认启动的 URL 是 127.0.0.1:8899)，但此时还不能直接抓包，还需要配置代理才可以使用. 配置代理可以使用全局代理或浏览器代理，比较推荐的做法是使用后者。我个人习惯使用chrome浏览器，因此可以安装 SwitchyOmega 代理插件，将 shistle 的配置信息填入，保存配置后记得切换插件的模式噢。 想要拦截HTPPS的请求的话，还需要安装根证书, 接着进入 whistle 的控制台, 点进rules, 配置需要代理或转发的地址。这个配置规则类似于设置 hosts. 设置好 rules 后，将本地开发的的网址http://localhost:8020/#/login替换为http://test.anran758:8020/#/login再进行测试登录，登录完毕后就能拿到用户数据了。 参考资料 whistle 网站应用微信登录开发指南]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
        <tag>微信登录</tag>
        <tag>shistle</tag>
        <tag>网站应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UI组件] 来做一个可配置的滑块进度条吧]]></title>
    <url>%2Fblog%2F2019%2F05%2F03%2Fminp-customize-slider%2F</url>
    <content type="text"><![CDATA[在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, 宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。123456789101112131415161718192021222324252627282930313233343536Component(&#123; /** * 组件的属性列表 */ properties: &#123; // 滑块大小 blockSize: &#123; type: Number, value: 32, &#125;, // 滑块宽度 blockBorderWidth: &#123; type: Number, value: 3 &#125;, // 滑轨高度 height: &#123; type: Number, value: 2 &#125;, // 滑轨进度 step: &#123; type: Number, value: 0, &#125;, // 进度值小数位 digits: &#123; type: Number, value: 0, &#125;, &#125;,&#125;); 123456789&lt;view id="slider-wrap" class="slider-wrap"&gt; &lt;view class="silder-bg" style="height: &#123;&#123;height&#125;&#125;rpx;"&gt; &lt;view class="silder-bg-inner"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="silder-block" style="height: &#123;&#123;blockSize&#125;&#125;rpx; border-width: &#123;&#123;blockBorderWidth&#125;&#125;rpx;" &gt;&lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.slider-wrap &#123; position: relative; display: flex; align-items: center; width: 100%;&#125;.silder-bg,.silder-bg-inner,.silder-block &#123; position: absolute; left: 0;&#125;.silder-bg,.silder-bg-inner &#123; width: 100%; height: 2rpx; flex: 1;&#125;.silder-bg &#123; overflow: hidden; background-color: #eeeeee; border-radius: 8rpx; z-index: 0;&#125;.silder-bg-inner &#123; height: 100%; background-color: #66a6ff; /* border-radius: 8rpx; */ z-index: 1; border-bottom-left-radius: 8rpx; border-top-left-radius: 8rpx;&#125;.silder-block &#123; width: 32rpx; height: 32rpx; background-color: #ffffff; border: solid 3rpx #66a6ff; z-index: 2; border-radius: 50%; box-sizing: border-box;&#125; 点击行为事件 滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~ 在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。 得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条 如下图所示：((191 - 36) / 301) * 100 ≈ 52 123&lt;view class="slider-wrap" bindtap="tappingSlider"&gt; &lt;!-- ...other --&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Component(&#123; // ... /** * 组件的初始数据 */ data: &#123; containerInfo: null, percentage: 0, &#125;, ready() &#123; // 取到滑块进度条的位置信息 wx.createSelectorQuery().in(this) .select('.slider-wrap') .boundingClientRect((rect) =&gt; &#123; if (!rect) return; this.data.container = rect; this._initBloackPos(); &#125;).exec() &#125;, // 点击进度条 tappingSlider(evt) &#123; const &#123; containerInfo &#125; = this.data; if (!containerInfo) return; const &#123; clientX &#125; = evt.changedTouches[0]; const &#123; digits, _maxDistance &#125; = this.data; // 需要做边界处理 const perc = this._computeOffset(clientX, containerInfo.left, 100); const percentage = this._boundaryHandler(perc); this.setData(&#123; percentage &#125;); this.triggerEvent('change', &#123; value: percentage.toFixed(digits) * 1 &#125;); &#125;, /** * 计算相对容器的偏移距离 * * @param &#123; Number &#125; x - X 坐标 * @param &#123; Number &#125; offset - 偏移量 * @param &#123; Number &#125; maxVal - 在 maxVal 范围内求百分比 */ _computeOffset(x, offset, maxVal) &#123; const &#123; width &#125; = this.data.containerInfo; // 底层保证一定精度 return (((x - offset) / width) * maxVal).toFixed(4) * 1; &#125;, /** * 边界处理 * @param &#123; Number &#125; num - 待处理的最值 * @param &#123; Number &#125; maxNum - num 最大值 * @param &#123; Number &#125; minNum - num 最小值 */ _boundaryHandler(num, maxNum = 100, minNum = 0) &#123; return num &gt; maxNum ? maxNum : (num &lt; minNum ? minNum : num); &#125;,&#125;); 123456789101112&lt;view class="slider-wrap" bindtap="tappingSlider" bindtouchmove="onTouchMove"&gt; &lt;view class="silder-bg" style="height: &#123;&#123;height&#125;&#125;rpx;"&gt; &lt;view class="silder-bg-inner" style="width: &#123;&#123;percentage&#125;&#125;%; height: &#123;&#123;height&#125;&#125;rpx;" &gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="silder-block" style="left: &#123;&#123;percentage&#125;&#125;%;width: &#123;&#123;blockSize&#125;&#125;rpx;height: &#123;&#123;blockSize&#125;&#125;rpx; border-width: &#123;&#123;blockBorderWidth&#125;&#125;rpx;" &gt;&lt;/view&gt;&lt;/view&gt; 虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ 当我们点击到百分百时，滑块超出原先设定的容器宽度。 超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。 在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量： 1234567891011121314151617181920212223242526272829303132333435Component(&#123; // ... data: &#123; // other data... _blockOffset: 0, _maxDistance: 100, &#125;, methods: &#123; // 点击进度条 tappingSlider(evt) &#123; const &#123; containerInfo &#125; = this.data; if (!containerInfo) return; const &#123; clientX &#125; = evt.changedTouches[0]; const &#123; digits, _maxDistance &#125; = this.data; const computeOffset = (maxVal) =&gt; &#123; return this._computeOffset(clientX, containerInfo.left, maxVal); &#125; // 滑块偏移度 const _blockOffset = this._boundaryHandler( computeOffset(_maxDistance), _maxDistance ); // 实际百分比 const percentage = this._boundaryHandler(computeOffset(100)); this.setData(&#123; _blockOffset, percentage &#125;); this.triggerEvent('change', &#123; value: percentage.toFixed(digits) * 1 &#125;); &#125;, &#125;&#125;) 12345&lt;!-- other code --&gt;&lt;view class="silder-block" style="left: &#123;&#123;_blockOffset&#125;&#125;%;width: &#123;&#123;blockSize&#125;&#125;rpx;height: &#123;&#123;blockSize&#125;&#125;rpx; border-width: &#123;&#123;blockBorderWidth&#125;&#125;rpx;"&gt;&lt;/view&gt; 如此，该事件就完成啦~ 滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块 -&gt; 拖动滑块 -&gt; 释放滑块这三个步骤。 因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。 首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, 随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Component(&#123; methods: &#123; onTouchStart(evt) &#123; this.data.moving = true; // 记录原始坐标 this.data.originPos = this.data._blockOffset; this.data.originPercentage = this.data.percentage; this.data._startTouchX = evt.changedTouches[0].clientX; &#125;, // 滑块移动 onTouchMove(evt) &#123; const &#123; moving, containerInfo &#125; = this.data; if (!moving || !containerInfo) return; const &#123; clientX &#125; = evt.changedTouches[0]; const &#123; digits, originPos, originPercentage, _startTouchX, _maxDistance &#125; = this.data; // 计算偏移量 const computeOffset = (maxVal) =&gt; &#123; return this._computeOffset(clientX, _startTouchX, maxVal); &#125; // 实际百分比 const perc = originPercentage + computeOffset(100); const percentage = this._boundaryHandler(perc); // 滑块偏移度 const offset = originPos + computeOffset(_maxDistance); const _blockOffset = this._boundaryHandler(offset, _maxDistance); this.setData(&#123; percentage, _blockOffset &#125;); this.triggerEvent('change', &#123; value: percentage.toFixed(digits) * 1 &#125;); &#125;, onTouchEnd(evt) &#123; this.data.moving = false; &#125;, &#125;&#125;) 1234567891011121314&lt;view class="slider-wrap" bindtap="tappingSlider" bindtouchmove="onTouchMove"&gt; &lt;view class="silder-bg" style="height: &#123;&#123;height&#125;&#125;rpx;"&gt; &lt;view class="silder-bg-inner" style="width: &#123;&#123;percentage&#125;&#125;%; height: &#123;&#123;height&#125;&#125;rpx;" &gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="silder-block" style="left: &#123;&#123;_blockOffset&#125;&#125;%;width: &#123;&#123;blockSize&#125;&#125;rpx;height: &#123;&#123;blockSize&#125;&#125;rpx; border-width: &#123;&#123;blockBorderWidth&#125;&#125;rpx;" bindtouchstart="onTouchStart" bindtouchend="onTouchEnd" &gt;&lt;/view&gt;&lt;/view&gt; 总结以上就是滑块进度条组件的实现~ 实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~ 本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 API 的差异罢了~ 微信代码片段, 可以直接拿来就用。 2019/05/04 更新： 后面又重新看了一遍，发现该组件还是有可优化的空间： 操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动: 12345678910111213141516&lt;view class="slider-wrap" bindtouchstart="onTouchStart" bindtouchmove="onTouchMove" bindtouchend="onTouchEnd"&gt; &lt;view class="silder-bg" style="height: &#123;&#123;height&#125;&#125;rpx;"&gt; &lt;view class="silder-bg-inner" style="width: &#123;&#123;percentage&#125;&#125;%; height: &#123;&#123;height&#125;&#125;rpx;" &gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="silder-block" style="left: &#123;&#123;_blockOffset&#125;&#125;%;width: &#123;&#123;blockSize&#125;&#125;rpx;height: &#123;&#123;blockSize&#125;&#125;rpx; border-width: &#123;&#123;blockBorderWidth&#125;&#125;rpx;" &gt;&lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536Component(&#123; // other options ... methods: &#123; // other method ... onTouchStart(evt) &#123; this.data.moving = true; const &#123; containerInfo &#125; = this.data; if (!containerInfo) return; const &#123; clientX &#125; = evt.changedTouches[0]; const &#123; digits, _maxDistance &#125; = this.data; const computeOffset = (maxVal) =&gt; &#123; return this._computeOffset(clientX, containerInfo.left, maxVal); &#125; // 滑块偏移度 const _blockOffset = this._boundaryHandler( computeOffset(_maxDistance), _maxDistance ); // 实际百分比 const percentage = this._boundaryHandler(computeOffset(100)); // 记录原始坐标 this.data.originPos = _blockOffset; this.data.originPercentage = percentage; this.data._startTouchX = clientX; this.setData(&#123; _blockOffset, percentage &#125;); this.triggerEvent('change', &#123; value: percentage.toFixed(digits) * 1 &#125;); &#125;, &#125;&#125;); 微信代码片段 v0.0.2]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>小程序开发</tag>
        <tag>UI组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5微信支付所遇到的若干问题]]></title>
    <url>%2Fblog%2F2019%2F02%2F23%2Fh5-cookie-lost%2F</url>
    <content type="text"><![CDATA[最近做了个H5微信支付的需求，记录一下所遇到的一些问题。。cookie 丢失的问题在H5页面中，一开始我们是需要拿到微信用户的信息。因此需要调用获取用户的接口。在第一次调用该接口时，需要有一个授权的过程。没有拿到用户信息的话，就需要调取授权让用户确认。然后问题就来了~授权完成后，会发现后端是拿不到cookie信息。经过查询资料后发现原来还是跨域在作祟~虽然我们解决了基本的跨域问题，即域名(origin)的不同。但是默认情况下跨域请求不会发送cookie.这时前端需要设置XHR的withCredentials: true, 后端也需要配合设置Access-Control-Allow-Credentials即可。以 axios 为例, withCredentials: true 与 data 平级:12345678910const opt = &#123; url: '/user', method: 'get', data: &#123; name: 'jojo' &#125;, withCredentials: false,&#125;axios(opt).then(res =&gt; console.log(res)) 这种情况一般是前后端项目不在同一个域名的情况下，且需要带凭证的场景需要设置Credentials。 url未注册(url not registered)随后微信弹了一下url not registered的错误，检查支付目录已经正确的被配置。 相关资料 微信内H5调起支付 jsapi 开发流程]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>h5</tag>
        <tag>微信</tag>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在微信小程序中保存网络图片]]></title>
    <url>%2Fblog%2F2019%2F02%2F11%2Fminiprograms-download-image%2F</url>
    <content type="text"><![CDATA[在小程序的文档中我们得知，wx.saveImageToPhotosAlbum 是用来保存图片到相册的。但是仔细一看会发现这个接口的filePath参数只接受临时文件路径或永久文件路径，不支持网络图片路径，意味着我们不能直接调用这个接口。。因此先需要把该文件下载至本地，使用 wx.downloadFile 。但值得注意的是小程序只可以跟指定的域名与进行网络通信，也就是说下载图片之前，我们需要先去微信公众者平台的开发设置里设置uploadFile合法域名。示例代码如下：123&lt;!-- index.wxml --&gt;&lt;image class="qr-code" src="&#123;&#123;url&#125;&#125;" mode="aspectFill" /&gt;&lt;button class="text" bindtap="saveImage"&gt;保存图片&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// index.jsconst app = getApp()Page(&#123; data: &#123; url: 'https://avatars3.githubusercontent.com/u/23024075?s=460&amp;v=4' &#125;, // 保存图片 saveImage() &#123; this.wxToPromise('downloadFile', &#123; url: this.data.url &#125;) .then(res =&gt; this.wxToPromise('saveImageToPhotosAlbum', &#123; filePath: res.tempFilePath &#125;)) .then(res =&gt; &#123; // do something wx.showToast(&#123; title: '保存成功~',icon: 'none' &#125;); &#125;) .catch(err) =&gt; &#123; console.log(err); // 如果是用户自己取消的话保存图片的话 // if (~err.errMsg.indexOf('cancel')) return; &#125;) &#125;, /** * 将 callback 转为易读的 promise * @returns [promise] */ wxToPromise(method, opt) &#123; return new Promise((resolve, reject) =&gt; &#123; wx[method](&#123; ...opt, success(res) &#123; opt.success &amp;&amp; opt.success(); resolve(res) &#125;, fail(err) &#123; opt.fail &amp;&amp; opt.fail(); reject(err) &#125; &#125;) &#125;); &#125;,&#125;) 然后理论上就可以保存图片了… 用户第一次在我们的小程序使用保存图片这个功能是会弹出一个授权弹框，如果用户手滑点了拒绝授权后再点一次保存图片，然后就会发现什么反应都没有了。。。 出现这样的原因是因为这个授权弹框只会出现一次，所以我们得想办法再让用户重新授权一次。这时就想到使用 wx.authorize . 但是经过测试后发现，使用 wx.authorize 后，会报 authorize:fail auth deny 的错误。然后经过查阅资料得知： 如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口； 如果用户已授权，可以直接调用接口； 如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调。请开发者兼容用户拒绝授权的场景。 emmm… 那这样效果当然不符合我们预期，只能在换一种方式。这时就想到了使用&lt;button open-type=&quot;openSetting&quot;/&gt;，在交互上做一个提示弹框，引导用户重新授权： 123456789101112131415161718&lt;image class="qr-code" src="&#123;&#123;url&#125;&#125;" mode="aspectFill" /&gt;&lt;button class="text" bindtap="saveImage"&gt;保存图片&lt;/button&gt;&lt;!-- 简陋版提示 --&gt;&lt;view wx:if="&#123;&#123;showDialog&#125;&#125;" class="dialog-wrap"&gt; &lt;view class="dialog"&gt; 这是一段提示用户授权的提示语 &lt;view class="dialog-footer"&gt; &lt;button class="btn" open-type="openSetting" bindtap="confirm" &gt; 授权 &lt;/button&gt; &lt;button class="btn" bindtap="cancel"&gt;取消&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const app = getApp()Page(&#123; data: &#123; url: 'https://avatars3.githubusercontent.com/u/23024075?s=460&amp;v=4', showDialog: false, &#125;, saveImage() &#123; this.wxToPromise('downloadFile', &#123; url: this.data.url &#125;) .then(res =&gt; this.wxToPromise('saveImageToPhotosAlbum', &#123; filePath: res.tempFilePath &#125;)) .then(res =&gt; &#123; console.log(res); // this.hide(); wx.showToast(&#123; title: '保存成功~', icon: 'none', &#125;); &#125;) .catch((&#123; errMsg &#125;) =&gt; &#123; console.log(errMsg) // if (~errMsg.indexOf('cancel')) return; if (!~errMsg.indexOf('auth')) &#123; wx.showToast(&#123; title: '图片保存失败，稍后再试', icon: 'none' &#125;); &#125; else &#123; // 调用授权提示弹框 this.setData(&#123; showDialog: true &#125;) &#125;; &#125;) &#125;, // callback to promise wxToPromise(method, opt) &#123; return new Promise((resolve, reject) =&gt; &#123; wx[method](&#123; ...opt, success(res) &#123; opt.success &amp;&amp; opt.success(); resolve(res) &#125;, fail(err) &#123; opt.fail &amp;&amp; opt.fail(); reject(err) &#125; &#125;) &#125;); &#125;, confirm() &#123; this.setData(&#123; showDialog:false &#125;) &#125;, cancel() &#123; this.setData(&#123; showDialog: false &#125;) &#125;&#125;) 最后这样就完成啦~ 微信代码片段点这里, 该功能需要添加appid才能进行正常的测试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[小程序开发笔记 - 小程序项目的结构设计]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Fminiprogrmas-build-frame%2F</url>
    <content type="text"><![CDATA[在工作中也做了好几个小程序项目了，正好抽空将小程序开发的一些知识重新整理一下~简要认识小程序开发其中小程序的构成是由.wxml、.wxss、.js、.json四种类型构成(下文将简称为四类文件)。其开发方式跟传统网页开发是十分类似的。.wxml模板文件对应为传统网页开发的.html文件，是一个页面(组件)的骨架。只不过它里面采用的语法跟传统的HTML语法有些差异, 比如标签的名称是微信自己在底层封装的组件。.wxss样式文件则对应CSS样式文件，具有大部分CSS的特性(比如css3的某些伪类特性就没有，但常见的css3属性倒是可以用)，除此之外还在此基础上做了新的扩展。js一直都是作为跟页面交互角色，在小程序开发中也不例外。在js中，可以使用微信提供的API。如常见的Page(构造器)和Component，还有微信给出的一些特定权限的API.json则是配置文件，一般是页面或者组件内那一级的配置文件。(这里有个小细节可以区分wxml和wxss区别，这两者都是以wx(微信)为开头，后面的小尾巴是区别是样式文件还是模板文件)。具体的更多细节可以去看官网文档。本文的重心还是在讨论项目结构如何安排会比较整洁合理。项目结构设计思路每个小程序项目的根目录会有一个project.config.json的项目配置文件，可以设置miniprogramRoot属性指定小程序源码的目录, 默认为根目录(/)。意思是说把源代码放在/src/下的目录也没有问题，笔者采用的是源码在根目录方式。首先，小程序规定：一个小程序主体部分由三个文件组成，同时必须放在项目的根目录。app.js 需要在里面调用App()函数，注册一个小程序。app.json 小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。app.wxss 全局样式，作用于每一个页面。但注意的是app.wxss写的全局样式不会影响组件内的样式。1234├── app.js├── app.json├── app.wxss└── project.config.json 页面小程序是由许多页面组成的，因此我们需要一个目录来存放页面, 我们通常把这个文件夹命名为/pages/。app.json的pages是一个数组，数组的每一项是用来指定页面的路径，框架会根据路径自动去寻找相对位置的四类文件(小程序的代码构成)。数组第一项为小程序入口页面。 每个页面为单独的一个目录, 页面的四类文件使用统一的名称。这里我们跟官方同步，四类文件跟随目录的名称走: 1234567891011├── pages│ │── home│ │ ├── home.wxml│ │ ├── home.js│ │ ├── home.json│ │ └── home.wxss│ └── user│ ├── user.wxml│ └── user.js├── ...└── project.config.json 除此之外，在开发小程序时，页面是会分主要页面和次要页面(子页)，子页通常是一些列表页详情页的东西。理论上只会有一个入口能跳的过去那种二级页面。如果这样的子页一多，然后全都放在了/pages/目录下，就会导致目录列表变得庞大，会比较难找… 这时可以考虑换一种方式储存，在页面文件夹里再加一个文件夹, 名为subpage。把子页放在这个文件夹内，这样层级关系就清晰了，缺点就是不适合套太深。或者说一个产品也不应该把页面藏得太深让用户找不到… 12345678910├── pages│ └── home│ ├── subpage│ │ └── detail│ │ ├── index.wxml│ │ └── ...│ ├── home.wxml│ └── ...├── ...└── project.config.json 至于项目简单一些的话前者会好一点(子页命名参照master-description的格式)，页面太过复杂的话可能会比较推荐使用后者的方式。 图片既然有了页面，那么页面必不可免会需要引用到图片。图片大致可以分为业务类和公共类。一些可以复用的图片我们可以放在同一个地方统一管理。而业务类则放在对应的页面目录下, 命名格式推荐为dir@description: 12345678910111213141516├── iamges (公共图片)│ │── icon│ │ ├── icon@download.png│ │ └── icon@cancel.png| └── ...├── pages│ └── index│ ├── images│ | └── index@bg.png│ | └── index@video.png│ ├── index.wxml│ ├── index.js│ ├── index.json│ └── index.wxss├── ...└── project.config.json 但值得注意的是，在js中使用import引入图片时不能通过根目录进行查找，而wxml则没有这种限制。 12345&lt;!-- 绝对路径 --&gt;&lt;images src="/images/icon@download.png" /&gt;&lt;!-- 相对路径 --&gt;&lt;images src="./images/index@video.png" /&gt; 1234// 会报错import iconDownload from '/images/icon@download.png'// 只能使用相对路径import iconDownload from '/../../icon@download.png' 样式写完页面后自然需要给页面润色, 我们可以通过在页面的.wxss来写局部样式，这没问题。但在我们完成一个又一个页面后，这时你可能会发现有些页面的样式重复性太高了。 因为一个成熟的设计师，在设计每一个产品时，大多会有一套设计风格或者称之为主题的东西。这些元素大量重复在各个页面中，我们重复写这些样式实际上代码是有点冗余的。 这时有经验的开发者很自然就会想到将重复性的代码抽出来，所幸微信提供了@import语句可以导入外联样式表。而这些通用的样式可以放在/style/目录下 12345├── style│ ├── button.wxss│ └── ...├── ...└── project.config.json 直接在.wxss的顶层引入即可复用。123@improt '/style/button.wxss';/* other code */ 至于是为何不在app.json中设定全局样式而单独抽出来的原因也是前文所提及的问题————组件中默认情况下不受全局样式影响的，理论上组件也不该受到外部样式的”无意“的影响。但app.json中的样式只需要加载一次就全局可用，外部样式就不一定了(因为没有实际的调研过)，而且还需要额外的去做引入的那一步。具体用哪一种方式还是要看具体情况来自己斟酌啦~ 还有一些方法，比如使用scss、less之类的预处理之类的方案，也是可以，只不过超出了本文的讨论范围，不展开讲。 组件组件对于熟悉模块化开发的同学自然不陌生，小程序基础库版本 1.6.3 就开始支持自定义组件了，至今为止也不用担心兼容性的问题了。从笔者角度来看看法，小程序的组件可以分为全局组件和局部组件。 全局性是指那种封装了登录、弹框、动画组件等等之类的组件，局部的大多是减轻一个页面内的复杂度，通过模块”搭积木”的方式来组成一个页面。即使某个功能砍了也能对页面减少牵连。 我们习惯于将全局性的东西放在源码的根目录上，因此会在根目录上创建/components文件夹，里面存放全局性的组件。其中全局性的组件有不少会有同等类型的组件，因为可以再进一步的分类，如动画类组件存放为一个文件夹内。再利用编辑器的文件名排序的特性，可以加上@提前组件集合。 组件下的四类文件按照componment/index的方式命名与page区分。 1234567891011121314151617181920├── componments (公共组件)│ │── anima│ │ ├── coin│ | | ├── index.js│ | | └── ...│ │ └── liquid│ | └── ...| └── ...├── pages│ └── home│ ├── componments│ | └── goods│ | ├── index.wxml│ | └── ...│ ├── home.wxml│ ├── home.js│ ├── home.json│ └── home.wxss├── ...└── project.config.json utils在原生小程序开发中，一般在源码的根目录下，都会有一个utils文件夹，专门来干杂七杂八的脏话累活。其中包含工具类函数、API的管理、配置信息等。 12345678├── utils (工具集)│ │── api│ │ └── ...| ├── ... (其他工具类)| ├── config.js| └── local.config.js (本地配置，git忽略)├── ...└── project.config.json 分包当小程序的资源大小超过了2M时，进行预览调试时就会报文件过大的错误，这时你可能就需要进行分包，将资源分开加载。小程序文档给出的目录结构是: 123456789101112131415├── app.js├── app.json├── app.wxss├── packageA│ └── pages│ ├── cat│ └── dog├── packageB│ └── pages│ ├── apple│ └── banana├── pages│ ├── index│ └── user└── utils 但经过我们在项目中尝试，我们发现通过编辑器的字符串排序后，会破坏目录结构的清晰度，所以推荐将分包放置到一个文件夹内。 1234567├── subpackages (分包)│ │── news│ │ └── ...| └── store│ └── ...├── ...└── project.config.json 结束最后的一个小程序项目主体结构大致是： 123456789101112131415161718192021222324252627├── components (公共组件目录)│ ├── @anima (动画组件)│ └── ...├── images（公共图片）│ └── icon│ ├── icon@download.png│ └── icon@cancel.png├── pages（主包目录）│ └── home (app.json 设置的入口页)│ ├── home.wxml│ ├── home.js│ ├── home.json│ └── home.wxss├── style（公用样式目录）├── subpackages（分包目录）│ │── news| └── store├── utils（公共模块，工具类）│ ├── config.js（项目配置）│ └── local.config.js (本地配置，git忽略)├── .editorconfig├── .gitignore├── app.js├── app.json├── app.wxss├── project.config.json└── README.md 以上是从原生小程序开发的角度来对项目结构的设计进行一个思路总结，没有过多的讲更深入的东西。下一期想整理一下关于API封装和管理，欢迎指导~]]></content>
      <categories>
        <category>小程序开发</category>
      </categories>
      <tags>
        <tag>小程序开发</tag>
        <tag>小程序开发笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts 的食用方式]]></title>
    <url>%2Fblog%2F2018%2F06%2F28%2Fhow-to-use-echart%2F</url>
    <content type="text"><![CDATA[ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上。可以这么说，在国内，是个前端都知道这个玩意是干嘛用的，毕竟它还是出自于国人之手。虽说如此，但是Echarts涵盖的类型实在是太广了，它给我们提供了很多配置项，但呼之而来的问题是会有点让刚接触的人有点茫然… 哪些参数是必要的？哪个参数又跟什么地方的key值相对应，缺失后就无法正常的显示…因此就来专门讲一讲这配置项的坑以及如何通过组件的方式正确的”食用“。其实Echarts也有自己的使用教程，但本文的重心并不是从零开始讲解Echarts，至于更多使用细节可以看官方的文档。这里姑且先用折线图作示例。首先需要先引入ECharts, 我们选择好自己所需的版本后(tips: 如何选择版本，可以去看看这里)，然后在&lt;/body&gt;前插入脚本：&lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt; 。随后通过echarts提供的 API 初始化目标容器节点：12// 初始化 echartsvar myChart = echarts.init(document.getElementById('main')); 接着我们需要填写配置项： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121var config = &#123; // 全局 tooltip , tooltip: &#123; show: true, // 坐标轴触发 trigger: 'axis' &#125;, // 图例组件，也就是提供显示或隐藏某一条数据信息开关 legend: &#123; // 组件在底部显示 bottom: '0px', // 图例每项之间的间隔 itemGap: 46, // 图例的数据数组, 省略则自动从 series.name 中获取 // 但我们需要定制样式，因此我们添上去上去 data: [ &#123; name: '曝光量', icon: 'circle' &#125;, &#123; name: '点击量', icon: 'circle' &#125; ], // 文字样式 textStyle: &#123; color: '#276dcc', fontSize: 14 &#125; &#125;, // 重设全局调色盘的颜色，比如当前涉嫌图示例中有两条数据 // 那这两条数据就会取得我们当前设置颜色作为展示 color: ['#42a66a', '#276dcc'], // 网格布局 grid: &#123; // 下面三个是离容器的位置 left: '3%', right: '4%', bottom: '40px', // 坐标刻度，默认是false containLabel: true &#125;, // X轴配置 xAxis: &#123; type: 'category', boundaryGap: false, // 坐标轴配置 axisLine: &#123; lineStyle: &#123; color: '#d6dfea' &#125; &#125;, // 坐标轴上的 label 样式 axisLabel: &#123; margin: 18, fontSize: 14, color: '#56749d' &#125;, // 类目数据，只有在 type: 'category' 中有效。 // 一般情况下我们并不会手动写死数据进去，而是通过 Ajax 请求数据来展示 data: [] &#125;, // Y轴配置 yAxis: [ &#123; // 数值轴 type: 'value', name: '点击量', // 左侧显示 position: 'left', // 下面的样式不再多说 axisLine: &#123; lineStyle: &#123; color: '#d6dfea' &#125; &#125;, axisLabel: &#123; margin: 18, fontSize: 14, color: '#56749d' &#125; &#125;, &#123; type: 'value', name: '曝光量', position: 'right', axisLine: &#123; lineStyle: &#123; color: '#d6dfea' &#125; &#125;, axisLabel: &#123; margin: 18, fontSize: 14, color: '#56749d' &#125; &#125; ], // 系列列表, 这个是数据的关键所在 series: [ // 如果 legend.data 设置了数据的话，那么 series 的数目需要和 legend.data 的数目一致。 // 否则图表会不工作 !! &#123; name: '点击量', // 图表的类型，在这个示例中我们使用是折线图 type: 'line', yAxisIndex: 1, // 系列中的数据内容数组 // 同样的，我们主要展示的数据来自于服务端 data: [] &#125;, &#123; name: '曝光量', type: 'line', // 折线图一维数据可能是这种形式的数组 // [1, 2, 3, 1, 4] data: [] &#125; ]&#125;; 随后可以通过 Ajax 获取数据，再使用setOption来设置选项： 1234567891011$.ajax(&#123; url: url, method: 'GET', data: data&#125;).done(function(res) &#123; config.series[0].data = res.data.click; config.series[1].data = res.data.exposure; config.xAxis.data = res.data.xAxis; myChart.setOption(option);&#125;); 如此，这样我们定义的 echarts 就完成啦~ Vue 组件在vue中封装组件也不难，大致如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;template&gt; &lt;div :class="['data-echart', echartClass ]"&gt; &lt;div class="data-echart__header"&gt; &lt;slot name="title"&gt; &lt;div class="header__title"&gt; &lt;span v-if="title" class="title-name"&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;el-popover v-if="tooltip" ref="tooltip" placement='bottom' trigger='hover'&gt; &lt;div v-html="tooltip"&gt;&lt;/div&gt; &lt;/el-popover&gt; &lt;i v-if="tooltip" class="el-icon-question" v-popover:tooltip&gt;&lt;/i&gt; &lt;/div&gt; &lt;/slot&gt; &lt;/div&gt; &lt;div :id="echartId" class="echart__main"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from 'echarts';export default &#123; name: 'echart', props: &#123; title: &#123; type: String, default: '' &#125;, tooltip: &#123; type: String, default: '' &#125;, echartClass: &#123; type: String, default: '' &#125;, option: &#123; type: Object, default() &#123; return &#123;&#125;; &#125; &#125;, loading: &#123; type: Boolean, default: false &#125; &#125;, computed: &#123; domEchartId() &#123; return (document || window.document).getElementById(this.echartId); &#125; &#125;, data() &#123; return &#123; // 随机生成一个ID echartId: this.randomChar(20), myChart: null &#125;; &#125;, watch: &#123; option: &#123; deep: true, handler(newVal) &#123; this.update(newVal); &#125; &#125;, loading(newVal) &#123; this.toggleLoading(newVal); &#125; &#125;, mounted() &#123; this.init(); &#125;, methods: &#123; // 调起loading toggleLoading(flag) &#123; flag ? this.myChart.showLoading() : this.myChart.hideLoading(); &#125;, init() &#123; this.myChart = echarts.init(this.domEchartId); this.myChart.on('click', (params) =&gt; &#123; this.$emit('clickEchart', params); &#125;); // 绘制图表 this.myChart.setOption(this.option); // Object.keys(this.data).length !== 0 &amp;&amp; this.myChart.setOption(this.data); &#125;, update(data) &#123; this.myChart.setOption(data); &#125;, /** * 生成随机字符串 * @param &#123; Number &#125; len - 指定随机字符串的长度 */ randomChar(len) &#123; const x = '0123456789qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'; let tmp = ''; for (let i = 0; i &lt; len; i++) &#123; tmp += x.charAt(Math.ceil(Math.random() * 100000000) % x.length); &#125; return tmp; &#125;, &#125;&#125;;&lt;/script&gt;&lt;style lang='scss' scoped&gt;@import '~Scss/theme';.data-echart &#123; display: flex; flex-direction: column; width: 100%; height: 100%; overflow: hidden;&#125;.data-echart__header &#123; width: 100%;&#125;.header__title &#123; .title-name &#123; font-size: 16px; color: $f-color--title; font-weight: 600; &#125; .el-icon-question &#123; font-size: 18px; color: $f-color--tip; &#125;&#125;.echart__main &#123; flex: 1; width: 100%; height: 100%;&#125;&lt;/style&gt; 我们需要将组件放入一个设有高度的容器上： 123&lt;div class="container" style="height: 600px;"&gt; &lt;echart :option="charts.option"&gt;&lt;/echart&gt;&lt;/div&gt; 调用的方式也面类似。首先声明一个基础的配置作为模板，在通过 ajax 拿到数据。通过动态数据传入组件内，组件watch到数据变化后立即重新渲染： 12345678910111213141516171819202122232425// 某处集中封装的 ajax 请求import API from 'Common/apis'// 同上配置const config = &#123;...&#125;export default &#123; data() &#123; return &#123; charts: &#123; title: 'My charts' option： config &#125; &#125; &#125;， created() &#123; API.getChartData() .then(res =&gt; &#123; let data = res.data this.charts.option.xAxis.data = data.xAxis; this.charts.option.series[0].data = data.click; this.charts.option.series[1].data = data.exposure; &#125;) &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Echarts</tag>
        <tag>图表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚点定位导航]]></title>
    <url>%2Fblog%2F2018%2F06%2F09%2Fjavascript-position-navigation%2F</url>
    <content type="text"><![CDATA[一般我们翻阅百科的时候，如果文章过长的话，就不太方便找到我们想要的资源。此时有一个定位导航的话，那可真是帮大忙了~今天，就来聊聊这种常见的锚点定位导航的原理以及是如何实现的。定位原理首先我们来了解一下，什么锚点？在海上，水手们会将锚丢入海中，或者靠岸时将锚抛上岸，其固定目的是让船固定位置。而锚点(anchor)也是一样，只不过场景不同罢了。页面锚点定位可以通过name或者id属性来定位。name已经被HTML5废弃了，就不再多提。在页面上，每个id都会自动创建一个锚点，同时还会生成一个hash，表示所处的文档位置。浏览器可以通过hash来确定位置，使用的方式一般如下：1234&lt;a href="#title"&gt;跳到title&lt;/a&gt;&lt;!-- 地址栏后会加上一段 # 开头的 hash --&gt;&lt;!-- https://anran758.github.io/blog/#title --&gt; 这个hash值我们可以通过浏览器的APIlocation.hash取到。但值得注意的是，跳转hash的话是不会像服务端发送请求的(除了第一次请求页面)。 深入分析但我们光知道跳转的原理可不够，只要你尝试了上面的跳转方法后，你会发现浏览器跳转方式是很唐突的。它会直愣愣的跳到指定位置(或者没有找到指定位置会，跳到页面最上面)，这在用户看来是十分生硬的，在体验上这个交互并不太友好。这时产品就会要求我们对此处进行优化~ 不过知道了上面的原理后，我们也可以直接使用js的方式来代替这种原生的默认跳转： 首先我们页面的结构大致如下: 12345678910111213141516171819&lt;nav class="nav"&gt; &lt;a class="actived" href="#title1"&gt;第一组图片&lt;/a&gt; &lt;a href="#title2"&gt;第二组图片&lt;/a&gt; &lt;a href="#title3"&gt;第三组图片&lt;/a&gt;&lt;/nav&gt;&lt;main id="content"&gt; &lt;article id="title1" class="item"&gt; &lt;!-- 许多内容 --&gt; &lt;/article&gt; &lt;article id="title2" class="item"&gt; &lt;!-- 许多内容 --&gt; &lt;/article&gt; &lt;article id="title3" class="item"&gt; &lt;!-- 许多内容 --&gt; &lt;/article&gt;&lt;/main&gt; 页面布局固定了后，元素离页面顶部的距离可以通过offsetTop来获取到。同时我们可以操作滚动容器(html)的scrollTop来修改滚动位置。嘿，这样一上(目标距离顶部的高度)一下(滚动条)，两个API双剑合璧后，我们就可以点击模拟滚动啦.. 1234567891011121314151617// jquery 环境var $menu = $('.nav');var $menuList = $menu.find('a');// 给超链接绑定点击事件$menuList.each(function() &#123; var $this = $(this); $this.click(function(e) &#123; var id = $this.attr('href').replace(/#/g, ''); // 获取目标距离顶部的高度 var top = $('#' + id).offset().top - 60; // 给滚动容器加动画的效果，滚动到目标位置 $('html').animate(&#123; scrollTop: top &#125;, 1000); &#125;);&#125;); 蹡蹡！在页面中调试会发现，点击后页面会平滑的滚动到指定的锚点~ 除此之外，我们还得再添加一个功能：在页面滚动的时候，能让用户知道自己所在的位置~ 1234567891011121314151617181920212223242526272829var contentList = $('#content').find('.item');$(window).scroll(function(e) &#123; var top = $(document).scrollTop(); // 获取目前滚动条所处的区间 var currentID = ''; contentList.each(function() &#123; var $this = $(this); // 获取当前距离顶部的数值 var itemTop = $this.offset().top; // 如果当前滚动距离已经进入了 item 的区间 if (top &gt; itemTop - 250) &#123; currentID = '#' + $this.attr('id'); &#125; else &#123; return false; &#125; &#125;); var currentLink = $menu.find('.actived'); // 移除其他的类名 if (currentID &amp;&amp; currentLink.attr('href') !== currentID) &#123; currentLink.removeClass('actived'); $menu.find("[href='" + currentID + "']").addClass('actived'); &#125;&#125;); 这样就锚点定位导航的功能就大功告成啦~ 最后将测试代码放入了codepen上了，感兴趣的同学可以去看看。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>业务组件</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将项目资源上传至七牛CDN]]></title>
    <url>%2Fblog%2F2018%2F05%2F24%2Fnode-%E5%B0%86%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90%E4%B8%8A%E4%BC%A0%E8%87%B3%E4%B8%83%E7%89%9BCDN%2F</url>
    <content type="text"><![CDATA[在实际工作中，常常会遇到需要将项目中的资源传入 CDN 上，以提升用户的加载速度。七牛就是国内一个挺有名的服务商，今天就来分享一下，如何将项目资源上传至七牛吧~一般情况下，我们开发中会有一个脚手架，里面搭建了我们的开发环境，我们通过npm安装七牛的 API 客户端，npm install -D qn。随后我们在 build 目录下(这里我们习惯将脚手架相关的代码放在此处..)创建一个名为upload.js的文件。一般  我们的代码打包后会放在一个dist目录下，我们通过 Node.js 查找我们想要  上传的所有文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');const fs = require('fs');const rootPath = path.resolve(__dirname, '../');// 定义指定目录，以及过滤掉多余的系统文件const distPath = 'dist';const ignore = ['.DS_Store'];/** * 获取全部文件 * @param &#123; String &#125; dir - 指定目录 * @return &#123; Array &#125; 返回待上传的文件数组 */function getAllFiles(dir) &#123; try &#123; let paths = fs.readdirSync(dir); let files = []; paths.forEach(function(file) &#123; // 获取文件相关信息 let dirname = path.resolve(dir, './', file); let stat = fs.lstatSync(dirname); // 过滤文件 let filter = ignore.filter(function(v) &#123; return v === file; &#125;); if (filter.length) return true; if (!stat.isDirectory()) &#123; // 如果是文件的话，就转为将绝对路径转为相对路径 // users/xxx/project/dist/static/js/vendors.js // =&gt; ./dist/static/js/vendors.js' files.push(dirname.replace(rootPath, '.')); &#125; else &#123; // 文件夹，递归继续查找文件 files = files.concat(getAllFiles(dirname)); &#125; &#125;); return files; &#125; catch (e) &#123; console.log(e + '\n'); &#125;&#125; ok~ 有了文件列表后，接着我们就要考虑上传的问题啦。不过在这之前，我们还需要再做一些准备…我们要先去七牛开发者平台获取签名信息，用来作为上传的凭证。 123456789101112131415161718// config/base.jsmodule.exports = &#123; // other configuration... cdn: &#123; // https://portal.qiniu.com/user/key accessKey: 'your access key', secretKey: 'your secret key', // https://portal.qiniu.com/bucket/koudaifm/index bucket: 'project', // 就是储存空间的域名，一般来说也是你的项目名 origin: 'http://fs.project.com', // 外链域名，这个可以自己设置，一开始七牛会分配给你一个随机的域名 // https://developer.qiniu.com/kodo/manual/1671/region-endpoint // 这个是跟项目所在的储存区域相对应的，比如华南地区的就是这个示例的uploadURL uploadURL: 'http://up-z2.qiniu.com', // timeout: 3600000 // 超时，唔..这里姑且不需要 &#125;&#125;; 考虑到上传资源时，可能会碰到资源已存在的问题，这时就需要再额外创建一个函数来处理这个问题~ 然后我们开始封装上传函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const colors = require('colors');// 将配置项放到单独文件上，统一改起来也方便..const config = require('../config/base');const pluginName = require('../package.json').name;let client = qn.create(config.cdn);let done = 0;// 删除七牛资源function qnDelete(key, cb) &#123; client.delete(key, function(err) &#123; if (!err) &#123; console.log('Delete '.yellow + 'success'.green + ': ', key); cb &amp;&amp; cb(); &#125; else &#123; console.log( 'Delete '.yellow + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; &#125;);&#125;// 上传资源function qnUpload(dir) &#123; // 上传到七牛对应的(bucket)下 var key = pluginName + dir.replace('./', '/'); client.uploadFile(dir, &#123; key: key &#125;, function(err, result) &#123; if (!err) &#123; console.log('Upload ' + 'success'.green + ': ', result.key); &#125; else &#123; // 如果目标资源已存在，七牛会返回一个 614 的错误码 // https://developer.qiniu.com/fusion/kb/1352/the-http-request-return-a-status-code if (err.code === 614) &#123; // 删除文件并重试，以最新 qnDelete(key, function() &#123; qnUpload(dir); &#125;); return true; &#125; // 报错信息 console.log( 'Upload ' + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; if (++done === filesLength) &#123; console.log('\n'); &#125; &#125;);&#125;console.log(`Upload $&#123;distPath&#125;/** to qiniu CDN.\n`);// 对每个文件调用 qnUploadmyFiles.forEach(qnUpload); 锵锵！一个可复用的上传组件就这么出现啦~ 最后上完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const path = require('path');const fs = require('fs');const qn = require('qn');const colors = require('colors');const config = require('../config/base');const pluginName = require('../package.json').name;const rootPath = path.resolve(__dirname, '../');const distPath = 'dist';const ignore = ['.DS_Store'];/** * 获取全部文件 * @param &#123; String &#125; dir - 指定目录 * @return &#123; Array &#125; 返回待上传的文件数组 */function getAllFiles(dir) &#123; try &#123; let paths = fs.readdirSync(dir); let files = []; paths.forEach(function(file) &#123; // 获取文件信息 let dirname = path.resolve(dir, './', file); let stat = fs.lstatSync(dirname); let filter = ignore.filter(function(v) &#123; return v === file; &#125;); if (filter.length) return true; if (!stat.isDirectory()) &#123; // 如果是文件的话，就转为将绝对路径转为相对路径 // users/xxx/project/dist/static/js/vendors.js // =&gt; ./dist/static/js/vendors.js' files.push(dirname.replace(rootPath, '.')); &#125; else &#123; // 递归重复查找文件 files = files.concat(getAllFiles(dirname)); &#125; &#125;); return files; &#125; catch (e) &#123; console.log(e + '\n'); &#125;&#125;const myFiles = getAllFiles(distPath);const filesLength = myFiles.length;// 七牛上传配置// https://www.npmjs.com/package/qn#uploadlet client = qn.create(config.cdn);let done = 0;// 删除七牛资源function qnDelete(key, cb) &#123; client.delete(key, function(err) &#123; if (!err) &#123; console.log('Delete '.yellow + 'success'.green + ': ', key); cb &amp;&amp; cb(); &#125; else &#123; console.log( 'Delete '.yellow + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; &#125;);&#125;// 上传资源function qnUpload(dir) &#123; // 上传到七牛对应的(bucket)下 var key = pluginName + dir.replace('./', '/'); client.uploadFile(dir, &#123; key: key &#125;, function(err, result) &#123; if (!err) &#123; console.log('Upload ' + 'success'.green + ': ', result.key); &#125; else &#123; // 如果目标资源已存在，七牛会返回一个 614 的错误码 // https://developer.qiniu.com/fusion/kb/1352/the-http-request-return-a-status-code if (err.code === 614) &#123; // 删除文件并重试 qnDelete(key, function() &#123; qnUpload(dir); &#125;); return true; &#125; // 报错信息 console.log( 'Upload ' + 'error'.red + ': ', err.name + ' [code: ' + err.code + ']' ); &#125; if (++done === filesLength) &#123; console.log('\n'); &#125; &#125;);&#125;console.log(`Upload $&#123;distPath&#125;/** to qiniu CDN.\n`);myFiles.forEach(qnUpload);]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Javascirpt</tag>
        <tag>七牛</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的几种压缩图片的思路]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2Fcanvas-compress-prictures%2F</url>
    <content type="text"><![CDATA[在做H5开发时，难免会遇到需要上传图片的需求。那么一般都是如何去处理压缩的需求呢？这里简要的概述一下原理，做个笔记加深印象~目前主流对图片进行处理都是使用canvas技术~当我们碰到需要压缩图片的场景时，第一种我们就可以尝试控制图片的尺寸。因为图片的尺寸越大，里面包含的信息就越多，自然体积也随着增加了起来。我们可以做一个宽高的限制，超出就对其进行尺寸的缩放。那么限制最大值是多少呢？这个应该根据产品或者需求来调整。当然，裁剪图片也是一种思路，那么该如何去裁剪，让用户选择还是我们自定义？这也是需要考虑的一点。判断缩放的方法主要使用drawImage将图片导入canvas，如果图片超过了指定的宽高，就进行缩放图片。关于这一点，我觉得张鑫旭老师的这篇文章讲的已经足够简洁的了，感兴趣的同学可以看这边~第二种就是使用canvas提供的另一个接口：canvas.toDataURL(type, encoderOptions)。这是浏览器原生提供可以压缩图片的方法，该方法返回一个包含图片展示的data URI(也就是我们常说的base64)。它接受两个可选参数，我们可以使用type参数指定其类型，默认为PNG格式。encoderOptions则是压缩图片质量参数，区间在 0~1 之间。值得注意的是，压缩图片质量这个参数只对image/jpeg或image/webp有效。所幸的是，其他格式用不了压缩图片的参数，但浏览器还是会对图片进行压缩处理，剔除对 web 展示没啥用的元数据(虽然可能会涉及到版权纠纷的问题)。123var canvas = document.getElementById("canvas");// 中间处理的过程省略 ...var fullQuality = canvas.toDataURL("image/jpeg", 0.8); 但单单是转为 base64 是不能满足我们一些需求的，这时我们可能会想要让它再转为对服务端友好的blob类型。这时我们就需要用到window.atob(), 将已经编译成 base64 的字符串解码为二进制。 12345678910111213141516171819202122232425var type = fullQuality.split(',')[0].split(':')[1].split(';')[0];// 解码为二进制var binStr = atob(fullQuality.split(',')[1]);var length = binStr.length;// 创建一个缓存区，容器大小可以容纳 binStr.// 这个缓存区我们是不能直接操作的。var buffer = new ArrayBuffer(binStr);// 建立`Uint8Array`类型数组// 这样我们就可以通过对象的方法或者数组索引读写里面的数据啦//// var buff = new ArrayBuffer(4); =&gt; ArrayBuffer(4) &#123;&#125;// var arr = new Uint8Array(buff); =&gt; Uint8Array(4) [0, 0, 0, 0]// arr[2] = 8;// console.log(buff) =&gt; 缓存区和 Uint8Array 同时被修改了var arr = new Uint8Array(buffer);for (var i = 0; i &lt; length; i++) &#123; // 逐个查询 binStr 里的二进制 Unicode 编码，并存入类型数组中 arr[i] = binStr.charCodeAt(i);&#125;var blob = new Blob([buffer],&#123; type: type &#125; 如果是想转为File类型的话，和上面的方法实现的也一致.. 123// https://developer.mozilla.org/en-US/docs/Web/API/File/File// 第一个参数传入 ArrayBuffer 也行，blob 也行..var file = new File([buff], "img.jpg", &#123; type: type &#125;); 哇，转个类型都看起来好像挺麻烦的样子呢…那么有没有内置的方法呀？答案是有，canvas 里有个toBlob(callback, type, encoderOptions)的方法, 它接受三个参数，一个是将canvas转为blob后接受的回调函数、一个是指定的图片格式、另一个是图片质量，区间也在 0~1 之间。 看起来这个方法似乎比上面那个更好用呢..然而残念的是，这货还受着兼容性影响，不在乎的兼容性的话倒是可以使用… 不然就需要上一种polyfill 的方式来实现~ 123456789101112canvas.toBlob(function (blob) &#123; // 接收转换后的 blob 类型 // 此时可以在函数里发起请求 $.ajax(&#123; url: baseURL + '/uploader/', data: &#123; act_id: actID, pic_1: blob &#125;, type: 'POST', success: function (data) &#123; // success &#125; &#125;);&#125;, 'image/png');]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈CSS3 Matrix 的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2F%E8%B0%88%E8%B0%88CSS3-Matrix-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CSS3的transform里有一个方法叫做Matrix，该需要六个参数，可以使用数学函数让元素进行旋转、缩放、移动以及倾斜元素。光是看这名词好像有点吓人，仿佛又回想起当初被数学支配的恐惧。的确，相比那些translate(25deg)之类有着明确语义跟容易调用方法外，Matrix使用起来确实有些复杂~Matrix的参数分别有a, b, c, d, e, f六个参数，我们可以分别对应：1transform: matrix(X轴的缩放， X轴拉升, Y轴的拉伸, Y轴的缩放, X轴的位移, Y轴的位移); 这样看上去好像好多了，我们常使用的几个方法也是可以通过Matrix来实现： 元素默认情况下的表现可以用Matrix来表示为：matrix(1, 0, 0, 1, 0, 0); 通过上面的例子，我们很容易推测出缩放的公式为：translate(sx, sy)等于matrix(sx, 0, 0, sy, 0, 0); 位移就更简单啦： translate(tx, ty)等于matrix(1, 0, 0, 1, tx, ty); 拉升则是：skew(degx, degy)等于matrix(1, tan(degx), tan(degy), 1, 0, 0) 旋转没有提供相应的参数，他需要套用数学的公式，毕竟这个方法名就是矩阵嘛：rotate(deg)等于matrix(cos(deg),sin(deg), -sin(deg), cos(deg), 0, 0) 那问题来了，为啥有简单易用的方法不用，我们非要搞这么麻烦的东西呢？这是因为很多时候我们需要高度精确定制动画时，那些简单的方法以及不能满足我们的需求啦~]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>transform</tag>
        <tag>css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-flow 练习笔记]]></title>
    <url>%2Fblog%2F2018%2F04%2F23%2Fgit-flow%2F</url>
    <content type="text"><![CDATA[在我们团队开发中，必不可免会使用到版本控制。同时还需要一个统一的工作流程，创建新的功能、打补丁、正式版发布打tag等等，git-flow工作流就这些繁琐的东西简化了，它封装了git命令，将命令组合了起来，我们只需要几行代码就能解决这些繁琐的工作。正好工作也有好一段时间了，想将这方面的知识梳理一下。git flow 有好几个版本，这里笔者演示使用的是git-flow-avh的版本。初始化首先我们先开始初始化仓库的工作流，我们在命令行使用git flow init。12345678910$ git flow initflags:ERROR short flag required for (showcommands) on this platformflags:ERROR short flag required for (local) on this platformflags:ERROR short flag required for (global) on this platformflags:ERROR short flag required for (system) on this platformflags:ERROR short flag required for (file) on this platform/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedNo branches exist yet. Base branches must be created now. 命令行出现了警告，告诉我们还没有基础的分支。这是因为测试是全新的仓库作测试，这个我们姑且先不管它，接着引导会向我们确定需要初始化分支的名字，我们都采用默认即可。直到询问Version tag prefix时，我们采用v作版本前缀，这其实也是很常见的一种习惯。 1234567891011121314151617181920212223242526Branch name for production releases: [master]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedBranch name for "next release" development: [develop]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedHow to name your supporting branch prefixes?Feature branches? [feature/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedBugfix branches? [bugfix/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedRelease branches? [release/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedHotfix branches? [hotfix/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedSupport branches? [support/]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedVersion tag prefix? [] v/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedHooks and filters directory? [/Users/anran/MyProject/git-flow-test/.git/hooks]/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected 随后我们使用git branch查看一下当前分支，我们会发现，git flow 创建了两条分支————主分支（master）和开发分支（develop），并自动切换到了 develop 上。 一般来说，我们常将 master 作为部署的分支，这个版本的产品防止稳定的代码和功能，作为产品的一个正式版部署。正常情况下，我们不能直接在 master 分支上进行工作，而该是在 develop 开发环境下进行工作。除此之外，develop 还是一个基础的分支，当我们开发新的功能时，我们会另开一个分支，在新的分支上进行功能开发，等功能开发完毕后再合并进来 develop 分支。 嘿，我们先创建一个README.md，在里面添加一些文字进去，再提交上去。 1234567891011121314151617➜ git-flow-test git:(develop) git branch* develop master➜ git-flow-test git:(develop) touch README.md➜ git-flow-test git:(develop) ✗ vim README.md➜ git-flow-test git:(develop) ✗ git add .➜ git-flow-test git:(develop) ✗ git statusOn branch developChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: README.md➜ git-flow-test git:(develop) ✗ git commit -m "First commit"[develop 61ec91a] First commit 1 file changed, 1 insertion(+) create mode 100644 README.md 如果这时直接用push的话，git会提示你没有设定上游分支————别忘了现在我们在使用全新的测试仓库。 bash12345678910111213141516➜ git-flow-test git:(develop) git pushfatal: The current branch develop has no upstream branch.To push the current branch and set the remote as upstream, use git push --set-upstream origin develop➜ git-flow-test git:(develop) git push --set-upstream origin developCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (5/5), 385 bytes | 385.00 KiB/s, done.Total 5 (delta 0), reused 0 (delta 0)To github.com:anran758/git-flow-test.git * [new branch] develop -&gt; developBranch &apos;develop&apos; set up to track remote branch &apos;develop&apos; from &apos;origin&apos;.➜ git-flow-test git:(develop) 功能分支umm..现在假设我们现在碰到了一个需求，需要加一些功能，这时我们就需要开一个功能分支了，这时工作中常用的分支。那为啥都切到开发环境了还要单独开一个分支呢？这是避免产品调皮的说，“诶嘿，兄弟，刚才那个功能只是我突发奇想，咱们不要了吧”。嗯，这时宰一个产品祭天事小，污染了全局的开发环境才事大，回退都不好回退（可能团队中其他人也在写一些功能上去或者修复了一些bug上去，回退意味着其他人也会收到影响）。 而单独开一个分支则没那么多破事需要烦恼，再不济就删除这个分支即可，不需要耗费额外的成本。 我们先看一下给flow都有啥，使用命令git flow -h会提示如下： 12345678910111213141516➜ git-flow-test git:(develop) git flow -hflags:ERROR short flag required for (showcommands) on this platformusage: git flow &lt;subcommand&gt;Available subcommands are: init Initialize a new git repo with support for the branching model. feature Manage your feature branches. bugfix Manage your bugfix branches. release Manage your release branches. hotfix Manage your hotfix branches. support Manage your support branches. version Shows version information. config Manage your git-flow configuration. log Show log deviating from base branch.Try 'git flow &lt;subcommand&gt; help' for details. 因为我们现在是想做一个新功能，feature 就是我们想要的命令。我们进一步查看详情： 12345678910111213141516➜ git-flow-test git:(develop) git flow feature helpflags:ERROR short flag required for (showcommands) on this platformusage: git flow feature [list] or: git flow feature start or: git flow feature finish or: git flow feature publish or: git flow feature track or: git flow feature diff or: git flow feature rebase or: git flow feature checkout or: git flow feature pull or: git flow feature delete Manage your feature branches. For more specific help type the command followed by --help 我们使用git flow feature start再加上一个名字，这个名字代表着这个功能分支是做什么的。 12345678910111213➜ git-flow-test git:(develop) git flow feature start homeflags:ERROR short flag required for (showcommands) on this platform/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expected/usr/local/bin/gitflow-common: line 81: [: -eq: unary operator expectedSwitched to a new branch 'feature/home'Summary of actions:- A new branch 'feature/home' was created, based on 'develop'- You are now on branch 'feature/home'Now, start committing on your feature. When done, use: git flow feature finish home 这时我们创建了一个名为feature/home的新分支，并且切换到了新分支上。feature的前缀就是前面使用默认的功能分支的名字。这个 feature 可以当成一个放置功能的文件夹。 随后我创建一个 HTML 文件，并在上面写了少许代码假装（雾）完成了这个新功能的开发。使用git flow feature finish &lt;name&gt;完成本回合的开发。 12345678910➜ git-flow-test git:(feature/home) ✗ git flow finish homeSwitched to branch 'develop'Your branch is up to date with 'origin/develop'.Already up to date.Deleted branch feature/home (was 61ec91a).Summary of actions:- The feature branch 'feature/home' was merged into 'develop'- Feature branch 'feature/home' has been locally deleted- You are now on branch 'develop' git flow 将分支合并后，会将feature/home分支删除。这时分支会切换到develop。注意，这时候的代码还没有提交到远端！ 12345678910111213➜ git-flow-test git:(develop) ✗ git add .➜ git-flow-test git:(develop) ✗ git commit -m "添加新的功能"[develop 9ca31f9] 添加新的功能 1 file changed, 12 insertions(+) create mode 100644 index.html➜ git-flow-test git:(develop) ✗ git pushCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 482 bytes | 482.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:anran758/git-flow-test.git 61ec91a..9ca31f9 develop -&gt; develop 正式发布好啦，当我们开发的差不多了，bug都修完并且都测试过了，这时就可以考虑部署一版了。这时我们可以使用git flow release start &lt;version number&gt;进入发布的状态。 12345678910111213➜ git-flow-test git:(develop) ✗ git flow release start 1.0.0Switched to a new branch 'release/1.0.0'Summary of actions:- A new branch 'release/1.0.0' was created, based on 'develop'- You are now on branch 'release/1.0.0'Follow-up actions:- Bump the version number now!- Start committing last-minute fixes in preparing your release- When done, run: git flow release finish '1.0.0' git flow 基于develop创建了一个新的分支，同时切换到新分支release/1.0.0上了。 这时我们可以进入最后的准备啦~比如我们一般发布都需要写版本信息，说明这版本都做了什么？新加了哪些功能？修了哪些bug等信息。 1234567891011121314151617181920212223➜ git-flow-test git:(release/1.0.0) ✗ touch changelog.md➜ git-flow-test git:(release/1.0.0) ✗ vim changelog.md----# item name## v1.0.0 2018/04/23* 基础功能完善* 完成巴拉巴拉功能~~~"changelog.md" 6L, 83C----➜ git-flow-test git:(release/1.0.0) ✗ git add changelog.md➜ git-flow-test git:(release/1.0.0) ✗ git commit -m "增加版本号信息"[release/1.0.0 f8464d6] 修改版本号信息 1 file changed, 6 insertions(+) create mode 100644 changelog.md 这时暂时先不用push，不过这里值得注意的是，一般来说，我们只有两个长期分支，一个 develop，另一个是 master分支。例如release 、feature等分支一般不会出现在远程的分支中。这是以为当我们做完这些工作流后，这些分支都会合并删除了。 等完成这些工作后，我们把发布流程结束，在命令行输入: git flow release finish 1.0.0。git flow将会做以下几个步骤： pull代码，以确保本地分支的代码都是最新的版本。 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。这时命令行会进入vim编辑器里的合并信息页，默认会以Merge branch &#39;release/1.0.0&#39;作为 commit信息提交。我们也可以自己输入一些信息进行描述。(vim编辑器状态下，输入a则进入编辑状态，使用:q为不保存信息退出编辑器，:wq为保存信息并退出vim)。 123456789101112Merge branch 'release/1.0.0'# Please enter a commit message to explain why this merge is necessary,# especially if it merges an updated upstream into a topic branch.## Lines starting with '#' will be ignored, and an empty message aborts# the commit.~~~"~/MyProject/git-flow-test/.git/MERGE_MSG" 7L, 256C 保存后又会进入另一个信息，这次这个是确定版本号信息。我们将v1.0.0前面的#去掉，让其作为tag，v是一开头初始化所用的前缀，而1.0.0则是我们这次发布的名称（版本号）。 12345678## Write a message for tag:# v1.0.0# Lines starting with '#' will be ignored.~~~"~/MyProject/git-flow-test/.git/TAG_EDITMSG" 5L, 84C 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字。 清理操作，版本分支会被删除，并且回到 “develop”。 hotfix上线后，在进行测试时会可能会发现之前没有留意到的小bug，比如展示的数据调错了字段，当bug修复后，这时就可以使用git flow 里的hotfix，用来表示bug的修复。值得注意的是，hotfix与之前两个分支有些不同，hotfix是基于master主分支的修复，而前面两者是基于develop分支。 12345678910111213➜ git-flow-test git:(master) git flow hotfix start v1.0.1hotfixSwitched to a new branch 'hotfix/v1.0.1hotfix'Summary of actions:- A new branch 'hotfix/v1.0.1hotfix' was created, based on 'master'- You are now on branch 'hotfix/v1.0.1hotfix'Follow-up actions:- Start committing your hot fixes- Bump the version number now!- When done, run: git flow hotfix finish 'fixShoppingCart' 然后你会看到git flow会提示你： 开始修复你bug 修复bug也是需要影响版本号的 完成上述工作后就可以结束这个补丁啦~ 123456789101112131415161718192021222324252627➜ git-flow-test git:(hotfix/v1.0.1hotfix) vim index.html➜ git-flow-test git:(hotfix/v1.0.1hotfix) ✗ vim changelog.md➜ git-flow-test git:(hotfix/v1.0.1hotfix) ✗ git add .➜ git-flow-test git:(hotfix/v1.0.1hotfix) ✗ git commit -m "fixed shopping cart bug"[hotfix/v1.0.1hotfix 1506b7f] fixed shopping cart bug 2 files changed, 4 insertions(+), 2 deletions(-)➜ git-flow-test git:(hotfix/v1.0.1hotfix) git flow hotfix finish v1.0.1hotfixSwitched to branch 'master'Merge made by the 'recursive' strategy. changelog.md | 2 ++ index.html | 4 ++-- 2 files changed, 4 insertions(+), 2 deletions(-)Switched to branch 'develop'Your branch is up to date with 'origin/develop'.Merge made by the 'recursive' strategy. changelog.md | 8 ++++++++ index.html | 4 ++-- 2 files changed, 10 insertions(+), 2 deletions(-) create mode 100644 changelog.mdDeleted branch hotfix/v1.0.1hotfix (was 1506b7f).Summary of actions:- Hotfix branch 'hotfix/v1.0.1hotfix' has been merged into 'master'- The hotfix was tagged 'vv1.0.1hotfix'- Hotfix tag 'vv1.0.1hotfix' has been back-merged into 'develop'- Hotfix branch 'hotfix/v1.0.1hotfix' has been locally deleted- You are now on branch 'develop' 我们使用git flow hotfix finish v1.0.1hotfix结束工作流后，跟之前那样会出现合并的信息，如果需要的话，就添加相应秒速信息，再保存退出即可。 这时会将修复的部分同时合并到master和develop分支上，同时会为这次hotfix打上 tag。 其他bugfix，它也是修复bug分支。看到这里就会有同学会疑问了：“啥？又改bug，这和之前那个又有啥区别？”。 原来它与hotbug不同的是，它是基于develop分支的。事实上这一个工作流在笔者的日常开发中用的比较少，似乎有些gif flow 的模型中都没有这个工作流，不过我也没有深入的去考证~因为目前没有遇到碰到这个的场景，了解的同学不妨留言讨论分享一下。 除此之外还有一个support的功能，是想用来支持以前的版本产品，这是一个实验性的功能，不太建议使用这个。 如果你偏爱于可视化的git的话，如同 sourcetree 之类的 Git GUI 也内置有git flow。 总结git flow实际上就一连串命令的组合，我们也可以单个单个的输入命令达到同样的效果。虽说git flow统一了工作流程，但并不是适用于全部的场景。项目中只有一个人时却反而会显得有点繁琐了。我们应该根据实际项目去选择符合项目的工作流。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>git flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器与服务端的背后交互: 详解页面请求的过程]]></title>
    <url>%2Fblog%2F2018%2F04%2F06%2FURL-to-browser%2F</url>
    <content type="text"><![CDATA[这其实一个很经典的一个题目啦~但其涉及知识面之广，却值得一说。开始我们将 URL 输入至浏览器的地址栏后回车, 首先浏览器就会开始检查 URL 是否合法, 是否 IP 地址， 若是不符合匹配规则, 将会以关联字进行搜索， 并带至搜索页（这个看浏览器设置）.我们以掘金为例, 我在输入 URL 的时候粗心的输错了协议. 但 Chrome 浏览器不认识这玩意呀, 然后将我们带到了搜索页. 仿佛在说: “嘿, 兄弟. 虽然不太理解你想干嘛, 但是你可以看看这里有你想要的东西吗?”DNS嘿, 接下来我们需要了解一些基础的概念~通常我们看到诸如www.baidu.com/之类的网址， 我们将其称之为域名. 而 DNS就是域名系统(Domain Name System)，它所处于的角色就是将主机名和域名映射为相应的 IP 地址.事实上我们向服务端请求资源时, 也可以直接输入目标 IP, 并不一定需要通过域名才能访问到. 但更多的时候，我们常见的还是使用域名的方式进行访问， 这是为什么呢？其实这个也很好理解，当你需要记住十个以上诸如111.13.101.208的 IP 地址的话，你就会感觉头疼了，如果我们使用我们熟悉的单词去记的话，相反就没那么困扰了（想想淘宝，京东和百度的域名~）.然而当计算机在网络进行通讯时, 它们仍然需要 IP 地址————因为它们不认得域名，这时 DNS 就派上用场啦~ 换句话说, 域名对于服务端来说, 并不是必须的，这只不过是方便人脑记忆罢了~ok, 咱们回归正题, 我们把前面的错误纠正, 输入正确的 URL =&gt; 浏览器开始解析 DNS:首先浏览器将接收到的URL查询主机名，并将主机名发送到DNS客户端.随后查找缓存中是否有该域名的记录， 缓存查找会根据以下几步进行查找：每个浏览器都有自己的缓存, 浏览器会先检查自身的缓存的是否存在目标的DNS记录? 如果有则进行尝试连接.(chrome 浏览器的 DNS 是采用预解析的, 我们可以在地址栏输入 about:DNS 查看浏览器本地的DNS)如果浏览器缓存没有找到, 进而会查找操作系统中的DNS. (windows 可以在命令行使用ipconfig /displaydns来查看 DNS)如果在本地DNS都没有找到的话, 则会查找hosts 文件(域名解析文件), 它是负责将主机名映射到相应的IP地址。随带一提，我们在日常开发中常用到的127.0.0.1默认就在hotst 文件中映射了域名为localhost, 因此我们直接使用localhost来访问127.0.0.1。这些都是可以由我们自定义的。如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器（比如谷歌通用 DNS 地址 8.8.8.8），我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。如果要查询的域名，由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析。如果仍然没有找到的话， 本地 DNS 会发出一个请求到 ISP DNS 缓存服务器（互联网服务提供商，如电信，你用的是哪一家的网）进行递归查询.如果仍然没有找到，就会去根域名进行查询，根域名服务器全球只有十三台。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器 IP 告诉本地 DNS 服务器。顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的 IP 地址告诉本地 DNS 服务器。主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录。找到会将结果缓存起来， 同时返回结果给客户端.从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。资料借鉴： DNS 解析的过程是什么，求详细的？TCP/IP 连接世界上几乎所有的 HTPP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层。 HTTP 的连接实际上就是 TCP 连接以及其使用规则。 –《HTTP 权威指南》紧接着，浏览器拿到 IP 地址后， 浏览器获取 URL 的端口（每个协议都有默认的端口号，比如 http 默认端口就为 80.），URL 中没有则获取协议的默认端口。随即浏览器发起 TCP 连接请求：创建新的套接字（socket）.浏览器发起到 120.41.39.47:443(掘金主页 IP 及端口) 的连接.建立一条新的 TCP 连接时， TCP 软件会进行交换一系列的 IP 分组，对连接的有关参数进行沟通.a1). 首先浏览器会发送一个小的 TCP 分组，这个分组设置了一个特殊的 SYN 标记，用来表示这是一条连接请求，然后等待服务端的回应.a2). 服务器接受了连接后， 会对一些连接参数进行计算，并向客户端传回个 TCP 分组，这分组中包含有 SYN 和 ACK(确定字符) 标记，说明请求已经成功建立.a3). 如果浏览器迟迟没有收到 ACK 标记时， 可能会重新发送一个请求。如果 收到后，则会向服务器回送一条 ACK（确认信息），将完整的请求头发送出去.服务器读取请求后，对 HTTP 请求进行处理.判断请求是否合理合法，合理的话就执行所请求的动作，并将数据写回客户端.在输入网址后，浏览器向服务端发起请求，服务端先是返回一个doc类型的HTML文件回来，浏览器解析文档时，再一次根据文档里的(link 或者 script 标签)进一步请求外部资源（详情放在下面再说）.我们可以在Network上看到，浏览器将请求发出去后，请求的status会变为pending，这也是上面说到开始建立连接请求的第一步，正在等待服务器的回应。随即我们点进请求详情内，可以发现请求头只有少量的字段。我们再打开一个请求状态（status）为 200 的请求，就能看到完整的请求头以及服务端传回来的响应了.渲染文档接着上面的问题， 浏览器开始解析页面。不过不同的浏览器引擎渲染过程都不太一样，这里姑且先说说webkit内核的渲染方式.首先浏览器的HTML解释器（HTML Parser）先工作，它将HTML的标签解析为DOM树。（DOM树构建）.如果遇到了&lt;script&gt;标签则会停止解析文档，这是因为JavaScript中可能会带有document.write方法，可能会重写页面的结构，因此浏览器会等待script标签下载完毕并执行后才会继续解析文档。这也是著名的web开发最佳实践的规则之一的由来————将&lt;script&gt;放在&lt;body/&gt;&gt;之上，这样就不会阻塞文档解析了。接着css解析器（CSS Parser）会在DOM树构建完毕后开始解析css，它和DOM树一样最后解析出来的是树形结构的CSSOM（css object module，别名也要StyleRules），浏览器将解析后的样式信息保存到新建的RenderStyle对象中。RenderStyle对象被RenderObject类所管理和使用.当创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息，这个过程也被称之为回流与重绘（reflow and reflow）.页面呈现.页面绘制的过程在下图的加载Mozilla官网动图就很好的体现了出来~]]></content>
  </entry>
  <entry>
    <title><![CDATA[详解图片的加载方式]]></title>
    <url>%2Fblog%2F2018%2F03%2F24%2Floading-pictures%2F</url>
    <content type="text"><![CDATA[[大图预警，流量慎入！] 我们在浏览页面获取信息时, 细心的你可能会留意到, 不同网页的图片可能有不同的加载方式. 那么究竟是由什么决定图片的加载方式的呢? 然后不由的陷入了沉思(.jpg), 所谓耳听为虚, 就让自己来动手操作一下吧~加载方式目前所知的图片加载方式主要有两种: 一种是线性加载, 而另一种则是渐进式加载.线性加载其实我们已经很熟悉啦, 图片的加载方式由上至下, 一点一点的加载的方式. 同时也是最常见的方式. 如下为例:渐进式则如同名字一般, 它会先显示低分辨率的近似图像, 再逐步的增加图片分辨率(模糊到清晰). 这里容我卖个关子, 不上示例图先.实现原理那么到底是什么决定了图片的加载方式呢? 事实上, 加载方式在作图的时候就已经被定下来了.比如在 Photoshop 中, 我们使用快捷键ctrl + shift + alt + s, 弹出储存为 Web 所用格式, 再选择jpeg格式后能看到下面有一个连续的选项(悬浮提示以多条路径下载), 这个选项的背后就是一个算法的接口，默认是不勾选的。渐进式使用的是小波变换, 而默认线性加载则是离散余弦变化算法. (关于算法的问题已经超出了本文的讨论范围, 这里姑且不谈.)浏览器在加载页面的时候, 读取图片的压缩算法, 再根据不同的压缩算法来选择相应的渲染算法.两者对比嗯, 看似很有道理的样子呢, 那实际效果如何呢? 来动手测试一下: 我准备了两张相同内容但不同加载方式的图片. 将控制台打开, 设置一个比较差的网速来对比两张图片的加载情况.what? 怎么好像跟想象中的有所出入? 仔细一瞧, 图一虽然从上至下的加载, 但同时它的清晰度也跟着变化. 而图二则没有这种的效果.随后我想到了文件大小的限制的问题, 为了了解更详细加载过程, 我再次准备了两张png的格式, 只不过在ps上png格式需要勾选的选项变成是交错, 然后再次进行试验:啊哈… 由于图片本身也挺大的, 在这加载期间两者之间差距就体现出来了 —— 原来前面那只是因为算法前期结构的构建. 细心的同学还会看到, 虽然图一看上去最先加载完了图片, 但控制台里跳动Size和Time还在告诉我们, 浏览器仍然还没有下载渲染完这张图片, 安静的等待渲染完毕后, 你可能还会惊讶的发现: 什么? 图一竟然比图二还加载的时间还长一点?是的, 得益于渐进式逐步加载的算法, 人们在视觉上会感觉渐进式相比线性更快一些, 虽然实际加载的时间可能还会长点, 但用户体验的确是上去.然而并非所有浏览器都支持渐进式加载, 翻阅了一下资料, 发现早期张鑫旭dalao也写过类似的内容, 也可以参考一看: 渐进式jpeg(progressive jpeg)图片及其相关JavaScript的渐进式前文介绍渐进式的时候卖了个关子, 没上示例图是为啥呢~ 这是因为此物非彼物, 我们常看到的渐进式加载可能不是由图片本身算法的效果, 为了避免混淆才暂时不上. 文章看到这里, 有过开发经验的同学就会明白, 若真有这种需求, 我们总不能祈祷全部用户上传图片都是渐进式的吧, 这也不现实.google 图片就是使用javascript来操作图片的渐进式. 在点击查看大图的时候, 预先加载一个缩略图, 同时图片底布有一条loading的效果. 加载完毕后就显示清晰的图片, 并且将 loading 隐藏起来. 我在控制台研究了一段时间, 没研究出具体的实现手法. 知道的dalao也不妨留言, 交流一下~至于知乎的渐进式加载图片, 已经有知友分析过了, 实现方式跟我上一篇文章讲的东西思路也有相似之处, 只不过是针对方向不同~ 有兴趣的可以移步知友的回答: 新版知乎加载图片时从模糊到清晰的这个效果是如何做出来的？ - Tw93的回答最后如果有什么说的不对的或者, 欢迎dalao们指出批评~]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>image</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于移动端GIF动图逐个播放的思路]]></title>
    <url>%2Fblog%2F2018%2F03%2F11%2F%E5%85%B3%E4%BA%8E%E5%89%8D%E5%8F%B0GIF%E5%8A%A8%E5%9B%BE%E9%80%90%E4%B8%AA%E6%92%AD%E6%94%BE%E7%9A%84%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最近碰到了一个需求, 大致是移动端有一个提示页, 在页面中会四个GIF图, 连起来像一个”小视频”一样, 用来展示商品的步骤.但是四个GIF一起播放的话, 那么用户体验就自然没有那么好啦. 我仔细的想了想, 想到了微博的GIF图好像就是一张一张播放的, 那么我们前端有没有办法也实现这个逐个播放的功能呢…事实上, 浏览器并没有给我们提供控制GIF的API(据说曾经好像有, 但因为用户体验的问题被废除了, 关于这点我没有去考证过), 我们无法得知这个动画是否已经结束了, 或者控制它的播放和停止.网上并没有太多关于这方面的资料, 不过张鑫旭dalao的这篇文章. 其中一个方法给我一个思路 —— 虽然img并没有这种事件, 但是我们可以使用canvas做替换呀.说干就干, 这里借鉴dalao的代码, 对HTMLImageElement(可以用来操纵&lt;img&gt;元素的布局和图像)的原型作扩展, 增加两个方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950if ('getContext' in document.createElement('canvas')) &#123; // 扩展播放功能 HTMLImageElement.prototype.play = function () &#123; if (this.storeCanvas) &#123; // 移除存储的canvas this.storeCanvas.parentElement.removeChild(this.storeCanvas); this.storeCanvas = null; // 透明度还原 this.style.opacity = ''; &#125; if (this.storeUrl) &#123; this.src = this.storeUrl; &#125; &#125;; // 扩展停止功能 HTMLImageElement.prototype.stop = function () &#123; const canvas = document.createElement('canvas'); let width = this.width; let height = this.height; if (width &amp;&amp; height) &#123; // 存储图片链接 if (!this.storeUrl) &#123; this.storeUrl = this.src; &#125; // canvas 和图片相同宽高 canvas.width = width; canvas.height = height; canvas.getContext('2d').drawImage(this, 0, 0, width, height); // 重置当前图片 try &#123; this.src = canvas.toDataURL("image/gif"); &#125; catch (e) &#123; // 跨域, 这时画布被污染 this.removeAttribute('src'); canvas.style.position = 'absolute'; // 插入图片 this.parentElement.insertBefore(canvas, this); this.style.opacity = '0'; this.storeCanvas = canvas; &#125; &#125; &#125;;&#125; 因为前台并没有我们想要操作图片的事件, 因此无法得知gif能持续多少秒, 这点只能由服务端来判断. 所幸这次情况没有那么复杂, 我们不需要适配随机的GIF. 就根据我们手头的动图计算有多少帧, 查看得知每个GIF播放时间都为3s. 再使用定时器的方式去调用方法, 为了防止用户没看清GIF的动作, 因此在定时器时间上再翻了一倍. 页面代码大致如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class="body"&gt; &lt;!-- .split-line End --&gt; &lt;h3 class="body-title"&gt;观影指南&lt;/h3&gt; &lt;div class="body-tips"&gt; &lt;div class="tips-line clearfix"&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-1.gif" alt="tips-1"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;1.坐上座椅，系好安全带&lt;/p&gt; &lt;/div&gt; &lt;!-- .tips-group End --&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-2.gif" alt="tips-2"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;2.于右手边取眼镜佩戴，并带上耳机&lt;/p&gt; &lt;/div&gt; &lt;!-- .tips-group End --&gt; &lt;/div&gt; &lt;!-- .tips-line End --&gt; &lt;div class="tips-line clearfix"&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-3.gif" alt="tips-3"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;3.按下扶手上的按钮，开始观影&lt;/p&gt; &lt;/div&gt; &lt;div class="tips-group"&gt; &lt;div class="tips-img"&gt; &lt;img src="./tips-4.gif" alt="tips-4"&gt; &lt;span class="tips-bar"&gt;&lt;/span&gt; &lt;/div&gt; &lt;p&gt;4.如感不适，长按按钮停止观 影&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- .tips-line End --&gt; &lt;/div&gt; &lt;!-- .body-tips End --&gt; &lt;/div&gt; 首先选择全部目标GIF, 使其暂停(初始化). 紧接着包装一下定时器用函数调用: 123456789101112131415161718192021// 注意这里是 ES6 的写法const images = document.querySelectorAll('.tips-img img')let palyTimer = null;function palyGif (num = 0) &#123; clearTimeout(palyTimer) images[num].play() // 递归 palyTimer = setTimeout(() =&gt; &#123; images[num].stop() num = (images.length - 1 &lt;= num) ? 0 : ++num images[num].play() return palyGif(num) &#125;, 6000);&#125;// 初始化images.forEach(img =&gt; img.addEventListener('load', img.stop, &#123; once: true &#125;))// 函数提升, 将其推向下一队列setTimeout(() =&gt; palyGif(), 50); 仅仅几行代码留实现我们想要的效果啦(图片压了下): 至于微博那种逐个播放的效果, 我原本想在控制台研究一下它实现的原理. 但仔细一看, 发现微博动图在手机客户端和非客户端上的效果是不一样的. 也就是说在安卓客户端上的确逐个播放, 但是在手机网页上却是一起播放, 并没有实现这个功能, PC页面同理, 因此推测并不是使用js实现的. 最后各位看官如果有什么好的想法的话, 可以留个言一起交流一下呗~]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>gif</tag>
        <tag>canvas</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊常见的跨域问题]]></title>
    <url>%2Fblog%2F2018%2F03%2F04%2F%E8%81%8A%E8%81%8A%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[跨域是前端工程中一个很常见的问题啦. 今天就来聊一聊跨域, 以及常见的处理方式和原理.什么是跨域?跨域实际上源于浏览器对javascript的一种安全限制(也被称之为同源策略). 默认情况下, 我们只能访问同一协议、同一域名、同一端口下的资源. 如今都是提倡前后分离的情况下, 前端更是需要调用大量后台接口的场景, 因此解决跨域的问题就摆在了面前.产生跨域的原因产生跨域的原因我们主要归为这两点:浏览器安全限制(不能读取不同域、端口、协议下的内容)使用的是XHR(XMLHttpRequest)请求同源策略这个原因是众所周知了, 它作为一个安全策略, 的确有效预防了某些安全上的问题. 但同时又阻止了大量适合使用的跨域请求. 而 XHR 也受同源策略影响: 浏览器不允许 javascript 查找跨域文档的内容. 使用 XHR, 文档内容都是通过responseText属性暴露, 因此同源策略不允许 XHR 进行跨域请求.解决跨域跨域很多情况下都需要后端的配合, 因此主要先来谈谈前端的跨域方案.JSONP前文我们说过, 产生跨域的原因之一XHR请求, 但是script发出的请求类型(type)并不是xhr, 因此可以解决跨域的问题.JSONP 由回调函数和数据组成的, 实现方式就是动态创建一个&lt;script&gt;标签, 然后设置src属性指向的跨域的URL(包涵请求参数). 来向服务端请求数据.比如我们要查询小明的信息, 这时我们得知它的userID为 1150, 同时我们都知道GET请求可以通过url进行传参, 因此我们向服务器发起请求:123var script = document.createElement('script')script.src = "https://www.example.com/users?user_id=1150"document.body.appendChild(script) 在插入&lt;script&gt;标签到&lt;body&gt;后, 浏览器立马就去请求服务器的资源. 值得注意的是, 使用jsonp也需要服务端的配合. 因此必须通过某种方式来告知服务端, 我们正在通过&lt;script&gt;标签调用请求, 必须返回一个JSONP响应, 而不应该是普通JSON响应. 至于什么叫jsonp响应呢? 这里其实很好理解.. 假设后端发回来的是json格式的数据, 我们也用不了呀, 数据还是数据, 不会做任何变化.. 为了让浏览器可以在&lt;script&gt;标签里直接使用, 我们需要让服务端返回一段js代码 —— 用函数包装的json的形式(这也jsonp中”P(padding)”的含义). 这个函数名前后端可约定. 如下: 1234567// 服务端返回 js 代码到 &lt;script&gt;里userData(&#123;'naem':'小明','id':1150,'level':'中等'&#125;)// 前端定义函数function userData(data) &#123; // 当 jsonp 请求成功后, 将json传入函数并调用, 我们拿到 json 后就可以做一些其他的事&#125; 我们来拿B站为例. 打开chrome下的network, 上图就是jsonp的应用, 服务端返回的js脚本. 下图可以发现, 我们发出去的请求类型是script, 验证了前文所说的&lt;script&gt;不受同源策略影响的. 目前主流的类库都对jsonp进行了封装, 如JQuery的getJSON和ajax, 这里就不深入讲解了. 最后对jsonp总结一下: jsonp实际上是一个非正式传输协议, 或者说是一种”投机取巧”的方式. 我们可以利用&lt;script&gt;的特性从而进行数据交互解决跨域的问题. 相对来说, 它也有一定的局限性: 只能应用在GET请求上, 除此之外还有安全性的问题 —— 只能用在我们信任的服务端, 因为你不能保证对方未来会给你传些什么… 跨域资源共享(CORS)概述说完了”不正规”的jsonp, 紧接着我们再说说原生的CORS规范. 我们先来看看官方的定义: CORS(Cross-origin resource Sharing, 跨资源共享), 定义了访问跨域资源时, 浏览器和服务器应该如何沟通. 其背后主要思想就是使用自定义的HTTP头部来让浏览器与服务器进行沟通, 从而决定请求或相应是否成功, 还是应该失败. 目前主流的浏览器都已经对CORS有着良好的支持, 而IE8 ~ 9则还需要使用专用的XDomainRequest这里我们抛开不谈. 这个功能实际上是由浏览器自动完成的, 我们并不需要做什么额外的工作. 对于开发者来说, 也就需要了解一些安全细节的问题, 这一点我们放在后面讲. 两种请求浏览器发送CORS请求时, 会将请求分为简单请求与非简单请求. 在我们日常工作中, 常用的简单请求可以将其归为以下几点: 使用的方法(Methods)为HEAD、GET、POST 请求头无自定义头 Content-Type只能是以下几种 text/plain multipart/form-data application/x-www-form-urlencoded 非简单请求: PUT, Delete 方法的 ajax 请求 发送 JSON 格式的 ajax 请求(比如post数据) 带自定义头的 ajax 请求 如果是简单请求, 则会先执行, 后判断。执行的过程大致如下: 浏览器发起请求检测到是 CORS 请求, 然后添加一个origin字段(其中包含页面源信息: 协议、域名、端口) =&gt; 服务端收到后作相应的处理(对比origin, 服务端判断这个源是否接受)返回结果给浏览器 =&gt; 浏览器检查响应头是否允许跨域信息 =&gt; 允许, 那就当做没事发生. 不允许, 浏览器抛出相应的错误信息(值得一提的是, 这时状态码也还有可能是200). 非简单请求执行顺序又有些不同. 在发生 CORS 请求时, 浏览器预先发送一个option请求. 浏览器这种行为被称之为预检请求(Preflighted request). 其中包含如下的请求头: origin: 同上，包含页面源信息. Access-Control-Request-Methods: 请求方法 Access-Control-Request-Header: 自定义头部信息, 多个头部以逗号分隔(可选, 看请求时有没有定义请求头) 举个栗子, 我们用JQuery发送一段JSON格式的请求做演示: 1234567891011var result;$.ajax(&#123; type : "post", url: "https://www.example/api/rank", contentType : "application/json;charset=utf-8", data: JSON.stringify(&#123;name: "something"&#125;), success: function(json)&#123; result = json; &#125;&#125;); 这时请求头(Request Headers)信息如下: 123456789Accept: */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Access-Control-Request-Header: content-typeAccess-Control-Request-Methods: POSTConnection:keep-aliveHost: https://www.example.comorigin: localhost:8080User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 服务端接收到预检请求后, 判断是否允许这种类型的请求. 在响应头(Response Header)上返回如下头部与浏览器进行交流: Access-Control-Allow-Origin: 服务端允许的源信息 Access-Control-Allow-Methods: 服务端允许的方法, 多个方法可以使用顿号分隔 Access-Control-Allow-Headrs: 服务端允许的头部, 多个头部可以使用顿号分隔 当预检请求被通过后, 我们原本想要发送的请求才会发送出去. 另外, 细心的你或许已经注意到了, 非简单请求这一来一回需要发送两次请求, 如果频率高的情况下岂不是很费性能又影响效率? 所幸的是HTTP协议新增(IE10+)了一个响应头用于缓存预检请求. 服务端在响应头添加如下字段: 1Access-Control-Max-Age: 3600 这个响应头表示这个预检请求可以缓存多长时间, 单位为秒. 这里3600s = 1h, 也就是说一个小时内可以不用再发预检命令了. 带 cookie 的跨域请求默认情况下, 跨域请求是不带上 cookie 的. 前端需要将withCredentials属性设置为true, 同时还需要服务端设置Access-Control-Allow-Credentials为true启动 cookie. 如果在发送 cookie 的时候, 浏览器检测到服务端响应头没有这个头部, 那么就会在控制台抛出一个错误. 另外, 还有一个值得注意的是. 服务端响应头设置了Access-Control-Allow-Origin: *的话, 是不能满足带 cookie 的跨域请求的. 因此有这种场景不能使用通配符, 需要全匹配字段. CORS 总结简单总结一下 CORS. CORS的出现也是为了解决跨域的问题. 只不过和JSONP不同, 它是纳入规范的一部分, 它几乎支持所有的类型的HTTP请求(JSONP只能使用GET). 唯一美中不足的也就是兼容性的问题, 因此可以使用JSONP作向下的兼容 事实上前端在 CORS 上并没有多少可操作的余地, 主要的还是浏览器来处理、服务端在设置, 但是并不代表我们就不需要了解这些知识啦. 嗯, 其他的跨域方法先挖个坑..]]></content>
  </entry>
  <entry>
    <title><![CDATA[[环境搭建] 从零开始配置 vscode]]></title>
    <url>%2Fblog%2F2018%2F02%2F06%2Fdev-zero-configuration-vscode%2F</url>
    <content type="text"><![CDATA[我们在进行开发工作时，选择一个顺手好用的 IDE 是必不可免的, 其中 vscode 就是一个很好的选择。它能让你大部分的工作都在编辑器内完成, 大大的提高开发效率~概述vscode 内置了前端相关的基础环境，如emmet扩展。另外的环境则可以通过它自己的插件商城来找到对应的插件。比如常见的预处理器的语法高亮。同时它有良好成熟的生态圈, 足够满足我们日常开发的所需的东西.它提供了很多便捷的自定义配置，并且贴心的给每行设置都加上了备注，告诉你是有什么作用。同时 vscode 对中文的支持很好，对于啃英语有些吃力的朋友会比较友善(虽然英语是程序员的基本功之一~vscode 还内置 git 源代码管理系统, 也就是说我们在写完代码后无需离开编辑器再另开一个bash来提交代码，直接在编辑器上完成对比代码差异后，确定无误后再提交相关的工作。还可以直接在编辑器上进行代码调试, 不过这些不在本文的讨论中。主题One Monokai Theme程序员的日常生活就是在coding, 可以说每天都在跟编辑器打交道, 因此编辑器的颜值能影响到咱们的心情，进而影响开发效率~在扩展商城里, 我们可以去挑选一些自己喜欢的主题, 来提高编程体验。这里笔者推荐使用One Monokai的主题, 它的配色对阅读代码还是挺舒服的，当然也可以去尝试其他的主题~下载主题后还需要用户设置上设置使用的主题.关于快捷键如果你是某个编辑器的用户，你已经习惯了原先编辑器的快捷键，现在切换过来的话怕又要重新设置自己熟悉的快捷键觉得很麻烦的话，没有关系~vscode贴心的准备了其他编辑器快捷键插件，节省你重新学习的时间成本。笔者就是从sublime转向vscode从此一去不复返~同步配置假设你现在配置了让自己很舒服的一个开发环境，这时你因为硬件故障导致电脑重装或者电脑迁移等因素，要需要重新配置环境，那肯定会挺苦恼的。因此强烈推荐安装一个settings sync的插件！它需要一个Github账号以及gits的token，它将你vscode相关的配置相关全部提交上gits上。这样不管你因为什么缘故导致重新安装开发环境，恢复vscode的环境只需三步：下载并安装vscode、下载settings sync、校验token并从远程下载配置。扩展插件善用插件的力量可以很大的提升我们的开发效率. 下面是一些常用插件跟大家分享一下.编辑器扩展Open-In-Browser由于VSCode没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项. 在 windows 下, 可以使用快捷键Alt + b快速的打开.Minify这是一款用于压缩合并JavaScript和CSS文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过uglify-js、clean-css和 html-minifier，与JavaScript、CSS和HTML协同工作。是一个可以不通过脚手架编译就进行压缩的办法，但平时工程化项目还是不能单单依赖这种方式。TODO Highlight开发中一些没有做完的事，一般会习惯性的打上TODO备注，但再要找的时候就很难显目的找到了。TODO Highlight顾名思义就是让TODO高亮的插件。前端类增强Auto Rename Tag自动重命名配对的HTML / XML标记, 这在修改标签名上一点挺便捷的.Auto Close Tag这个扩展是为 XML，PHP，Vue，JavaScript，TypeScript，JSX，TSX 等其他语言启用的。同时它是可配置的。输入标签的右括号后，结束标签将被自动插入。CSS Peek使用此插件，你可以追踪至样式表中CSS类和ids定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。JavaScript (ES6) code snippetses6已经是经常运用在我们的项目中了, 该扩展包含用于 Vscode 编辑器的 ES6 语法的 JavaScript 代码片段.（同时支持 JavaScript 和 TypeScript）。Veturvue开发必备, 可以格式化.vue文件, 由官方维护.Vue 2 Snippetsvue开发必备, 这个插件基于最新的Vue官方语法高亮文件添加了 Syntax Highlight, 并且依据Vue 2的 API 添加了Code Snippets`.WakaTime统计开发时间和效率，只需注册一个账号即可~代码规范化ESLint要养成一个良好的编程习惯, ESLint就是一个不错的选择. 它能适应项目中的规则来纠正你的不好的习惯。PrettierPrettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。EditorConfigEditor Config可以让团队开发时统一约定好一种规范. 这个主流的编辑器都支持.markdown如果你经常使用 Markdown 的话，还可以使用安装markdownlint和Markdown All in One这两个插件，前者可以约束编写的格式，后者提供方便的键盘快捷方式，目录，自动预览等。用户配置分享一下自己目前的配置, 可以根据项目所需或者自己的习惯进行调整.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&#123; &#123; "workbench.colorTheme": "One Monokai", // 编辑器 "editor.multiCursorModifier": "ctrlCmd", "editor.snippetSuggestions": "top", "editor.renderWhitespace": "all", "editor.formatOnPaste": true, "editor.wordWrap": "on", "editor.fontSize": 12, "editor.tabSize": 4, // 文件资源管理 "explorer.confirmDragAndDrop": false, "explorer.confirmDelete": false, // 终端 "terminal.integrated.cursorBlinking": true, "terminal.integrated.cursorStyle": "line", // emmet "emmet.triggerExpansionOnTab": true, "emmet.includeLanguages": &#123; "vue-html": "html", // "vue": "html", "wxml": "html", "javascript": "javascriptreact" &#125;, "emmet.syntaxProfiles": &#123; "vue-html": "html", // "vue": "html" &#125;, // 文件 "files.eol": "\n", "files.associations": &#123; "*.vue": "vue", "*.wxss": "css", "*.cjson": "jsonc", "*.wxs": "javascript" &#125;, // 窗口 "window.zoomLevel": 0, // 使用 vscode-typescript 来整理代码 "vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatter.ts": "vscode-typescript", // other "auto-close-tag.SublimeText3Mode": true, // 可能是让 CPU 炸了的罪魁祸首 "search.followSymlinks": false, "html.format.extraLiners": "", // sync githubg 同步模块 "sync.gist": "", "sync.autoDownload": false, "sync.autoUpload": true, "sync.forceDownload": false, "sync.quietSync": false, "sync.askGistName": false, "sync.removeExtensions": true, "sync.syncExtensions": true, "vetur.validation.template": false, // todo highlight "todohighlight.isEnable": true, "todohighlight.include": [ "**/*.js", "**/*.jsx", "**/*.ts", "**/*.tsx", "**/*.html", "**/*.css", "**/*.scss" ], "todohighlight.exclude": [ "**/node_modules/**", "**/bower_components/**", "**/dist/**", "**/build/**", "**/.vscode/**", "**/.github/**", "**/_output/**", "**/*.min.*", "**/*.map", "**/.next/**" ], // gitlens "gitlens.advanced.messages": &#123; "suppressCommitHasNoPreviousCommitWarning": false, "suppressCommitNotFoundWarning": false, "suppressFileNotUnderSourceControlWarning": false, "suppressGitVersionWarning": false, "suppressLineUncommittedWarning": false, "suppressNoRepositoryWarning": false, "suppressResultsExplorerNotice": false, "suppressShowKeyBindingsNotice": true &#125;, // prettier "prettier.singleQuote": true, // eslint "eslint.autoFixOnSave": true, // prettier "beautify.config": &#123; "brace_style": "collapse,preserve-inline", "end_with_newline": true &#125;, "minapp-vscode.disableAutoConfig": true, "minapp-vscode.reserveTags": [ "text" ], "minapp-vscode.prettyHtml": &#123; "wrapAttributes": true // 属性换行 &#125;, "diffEditor.ignoreTrimWhitespace": true, "terminal.integrated.rendererType": "dom", "editor.renderControlCharacters": true, "gitlens.views.fileHistory.enabled": true, "gitlens.views.lineHistory.enabled": true, "[vue]": &#123;&#125;, "files.insertFinalNewline": true, "vetur.format.options.tabSize": 4, "[javascript]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, "[json]": &#123; "editor.defaultFormatter": "HookyQR.beautify" &#125;, "[html]": &#123; "editor.defaultFormatter": "HookyQR.beautify" &#125;, "editor.suggestSelection": "first", "vsintellicode.modify.editor.suggestSelection": "automaticallyOverrodeDefaultValue", "[jsonc]": &#123; "editor.defaultFormatter": "HookyQR.beautify" &#125;, "prettier.eslintIntegration": true, "[markdown]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, "[scss]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, "[css]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, "workbench.settings.editor": "json", "[less]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;, "[typescript]": &#123; "editor.defaultFormatter": "esbenp.prettier-vscode" &#125;,&#125;&#125;]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>vscode</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的console]]></title>
    <url>%2Fblog%2F2018%2F01%2F30%2FDebug-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6console%2F</url>
    <content type="text"><![CDATA[打断点和console.log是我们前端调试中, 使用最为频繁的一种. 但实际上console API 可不仅仅用来查看某个值或者某个变量是否存在, 它还有更多的用法是不为人知的.概述console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的. 其次它是一个全局对象, 我们先在控制台将console打印出来, 看看它里面都有些什么东西, 再来一一讲解吧.Methodlogconsole.log就是向web控制台输出一条信息. 参数可以是变量, 数字, 字符串等.123456// 常规下var name = 'Jack'console.log('Hello') // Helloconsole.log(name) // Jackconsole.log(`Hello, $&#123;name&#125;`) // Hello, Jack 除此之外, 还支持格式化输出.1234var name = 'Jack'console.log('Hi, %s. what are you doing', name) // Hi, Jack. what are you doingconsole.log('%c I am some great text', 'font-size: 50px;') // 假装 50px: Hi, Jack. what are you doing 下面是它所支持的参数, 学习C语言的同学有没有感觉扑面而来的熟悉感呀~ 占位符 描述 %s 字符串 %d or %i 整数 %s 打印字符串 %f 浮点数 %c 样式代码 这里连知乎, 百度等大厂也用console来做招聘广告或做些有意思的事~ info, warn, error这三者实际上在我们开发时也时常出现. 现在主流的一些框架, 比如说Eslint, 就封装了相关方法. 当你语法出现不规范的地方, 就会根据错误来弹出指定的提示框来提示你. 12345678// Infoconsole.info('Hi, This is message')// warning 警告console.warn('On, Your operation may cause a security breach!')// Error 报错console.error('Shit! Variable does not exist!') 实际效果: tableconsole.table只接受一个数组或者对象, 可以接受一个额外的参数来描述表格的列数.它会把数据通过表格的形式打印出来, 这样我们看数据的时候就能直观了很多: 1234567var array = [ &#123; name: 'Jack', age: 12 &#125;, &#123; name: 'Tome', age: 18 &#125;, &#123; name: 'baka', age: 15 &#125;]console.table(array) groupconsole.group和console.groupWEnd就像一对标签一样. group在控制台创建一个新的分组, 输出到控制台上的内容都会被添加一个缩进, 表示该内容属于当前分组, 直到调用console.groupEnd()之后, 当前分组才结束.12345678910111213var boys = [ &#123; name: 'Jack', age: 12 &#125;, &#123; name: 'Tome', age: 18 &#125;, &#123; name: 'baka', age: 15 &#125;]boys.forEach(item =&gt; &#123; console.group(`$&#123;item.name&#125;`) console.log(`This is $&#123;item.name&#125;`); console.log(`$&#123;item.name&#125; is $&#123;item.age&#125; years old`); console.log(`$&#123;item.name&#125; is $&#123;item.age * 7&#125; years old`); console.groupEnd(`$&#123;item.name&#125;`)&#125;) dir console.dir —— 在控制台中显示指定JavaScript对象的属性，并通过类似文件树样式的交互列表 我们知道console.log实际上是可以输出DOM节点的, 但有时候我们只想知道 DOM 属性的话, 这里就可以使用dir来输出DOM对象.1234var head = document.getElementById('head')console.log(head)console.dir(head) 值得注意的是. MDN提醒我们, 这个特性是非标准, 尽量不要在生产模式下使用. countcount, 如同字面意思一样. count()会输出每一次被调用的次数. 该方法的兼容性也需要注意, 不适用于生产模式.12345678console.count('Steve')console.count('Steve')console.count('zeo')console.count('Steve')console.count('zeo')console.count('Steve')console.count('zeo')console.count('Steve') clearclear, 顾名思义就是清除. 看到别人那乱七八糟的用于调试的log或者info时, 这时只想要保留自己的调试信息. 那么console.clear()就可以为你解决这个烦恼, “一键清空”前面控制台所有的信息, 从头再来(雾) 12// something infoconsole.clear() time启动一个计时器（timer）来跟踪某一个操作的占用时长。每一个计时器必须拥有唯一的名字。 页面中最多能同时运行10,000个计时器。跟group一样, time也是配套的。 当以此计时器名字为参数调用 console.timeEnd() 时，浏览器将以毫秒为单位，输出对应计时器所经过的时间. 比如我们起一个fetch:1234567console.time('fetching data')fetch('https://api.github.com/users/anran758') .then(data =&gt; data.json()) .then(data =&gt; &#123; console.timeEnd('fetching data') console.log(data) &#125;) oh, 这样我们就轻易的知道了这次我们请求花费了多少时间啦~ assertconsole.assert()还是蛮有意思的. 它第一个参数接受一个断言(声明), 第二个参数是一个message. 如果断言为false，则将一个错误消息写入控制台。如果断言是true，就当做没发生。语法如下: 1console.assert(assertion, message [, subst1, ..., substN]); 这里的断言不一定是false才会触发错误. 我特意去测试了一下, 触发的规则也跟if的判断里的逻辑相反. 只要是断言是0, NaN, undefined, false, null, 空字符串&#39;&#39;就会激活报错. 12345678910111213// Assertion failed: Here is the "name" can not be emptyvar str = '';console.assert(str, 'Here is the "str" can not be empty')// Assertion failed: 0 is not allowed!var num = 0console.assert(0, '0 is not allowed!')// Assertion failed: That is wrong!console.assert(1 === 2, 'That is wrong!')// 什么都不会发生console.assert(1 === 1, 'That is wrong!') 总结在适当的地方使用恰当的方法能使调试变得更清晰. 发现身边很多小伙伴都只了解log的方法, 正好最近看到了这方面的知识, 总结了一下, 活用于开发中能使效率变得更好~ 参考资料:MDN - Console: https://developer.mozilla.org/zh-CN/docs/Web/API/Console从console.log说起（上）: http://www.alloyteam.com/2013/11/console-log/javascript30: https://courses.wesbos.com/account/access/5a658ec8a6b56c55273b4078/view/194129876]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>javascript</tag>
        <tag>tools</tag>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进 web 移动端开发]]></title>
    <url>%2Fblog%2F2018%2F01%2F25%2Fweb-%E8%B5%B0%E8%BF%9Bweb%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[近年来, 人们逐渐倾向移动端的使用. 越来越多的人使用手机/平板来上网. 既然有需求, 那就自然会有市场~ 作为一个身在一线的前端工程师在工作中也难免会遇到这种场景/需求. 下面就分享一下对于移动端的一些学习笔记~移动端基础的知识移动端的屏幕相比 PC 来说多的太多了, 因此我们不能只是使用传统的 px, 首先来认识一下我们常用的单位吧.px: css pixels 逻辑像素, 浏览器使用的抽象单位dp, pt: device independent pixels 设备无关像素dpr devicePixelRatio 设备像素缩放比它们之间的计算公式是: 1px = (dpr)² * dp这里我们用 IPhone 5 为例, 我们知道, iPhone 5 的dpr为 2, 根据上面的公式, 我们能得出:平面上: 1px = (2)² * dp =&gt; 1px = 4dp(四个物理像素)但我们在实际的开发中, 更多的是按照长度(维度)来换算:维度上: 1px = dpr * dp =&gt; 1px = 2 * dp因此在移动端开发的时候. 我们拿到 UI 的设计图, 设计图(IPhone5)的尺寸是640 * 1136. 这是因为dpr的缘故. 因此我们需要在开发时, 将原先的宽度除于 2 才行.还有我们常说的Retina屏又是什么? Retina屏(高清屏幕)就是dpr &lt;= 2.viewportviewport, 就是视图窗口. 其中它在手机上又分为一下两个窗口.Visual viewport (可视窗口)Layout viewport (布局窗口)最下面一层就是layout viewport, 上面一层就是visual viewport, visual viewport可以控制窗口的缩放(salce), 能看得到更多底层的layout viewport的东西.这里值得注意的是, layout viewport的宽度是大于浏览器可视区域的宽度的.Meta 标签如果我们没有限制viewport的缩放比的话. 我们通过获取window.innerWidth(布局窗口) / document.body.clientWidth的缩放比得知, 设备会根据页面的大小, 自动的去调整缩放比. 这就会不符合我们的预期.这时我们可以通过Meta标签来控制viewport. 它的语法如下:1&lt;meta name="viewport" content="name=value,name=value" /&gt; 参数如下: width: 设置布局 viewport 的特定值(“device-width”) initial-scale: 设置页面的初始缩放 minimum-sacle: 最少缩放 maximum-scale: 最大缩放 user-scalable: 用户能否缩放 目前主流的编辑器在使用emmet生成基本HTML模板时都会自带插入一句 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; 而有时候我们不希望用户能控制页面的搜索，那我们就可以设置user-scalable为no, 百度就是如下的做法: 1234&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/&gt; 移动端布局移动端的布局就能不像 PC 端一样用固定宽度了, 因为移动端有太多不同的屏幕分辨率了.. 因此现在主流的布局方式还是响应式布局和 flex 布局. 未来还有 Grid 布局, 不过现在普及度不够高暂时放放, 以后有机会单独开一篇. 响应式布局响应式布局实际上是一个设计理念, 它是多项技术的综合体. 其核心就是媒体查询(@media). 响应式网站的优点主要有: 减少工作量: 代码, 设计, 内容只需要一份. 多出的工作也仅仅是 js 和 css 样式的调整. 相对来说会节省时间 每个设备都能得到正确的设计 相反, 它也带有一些副作用(缺点): 由于我们是响应式布局, 需要加载更多的样式和脚本资源 设计比较难精准定位和控制 media实际上是 css3 的玩意, 对老版本浏览器兼容不好(特指 IE) 接着我们继续看看响应式设计着重的几个点吧: 关于响应式设计中针对不同分辨率的媒体查询设计, 可以看我 Repo 中的这一块. 百分比布局仅仅使用媒体查询来适应不同的固定宽度设计, 只会从一组 css 到另一组 css 的切换. 两组之间没有任何平滑渐变. 当没有命中媒体查询时, 表现就会不可控. 就比如说 iPhone 又出了个 iPad mini, 这个设备的宽度介于 iphone 和 ipad 之间. 这样就有可能会导致布局的错乱, 我们应该要尽量避免这种情况发生. 弹性图片很简单也很常见的思路. 图片设置宽度 100%, 外层一个 div 包裹着, div 设置宽度, 可以随着媒体查询改变宽度 从而实现自适应 123img &#123; max-width: 100%;&#125; 当页面达到手机屏幕宽度的时候, 我们可以考虑放弃一些传统页面的设计思想. 力求页面简单, 简洁(手机屏幕小). 因此需要作出以下处理: 同比例缩减元素尺寸 调整页面结构布局 隐藏冗余的元素除此之外, 应该将经常需要切换位置元素使用「绝对定位」, 减少重绘提高渲染性能. Flex 布局Flexbox的出现是为了解决复杂的 web 布局，因为这种布局方式很灵活。容器的子元素可以任意方向进行排列. 有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 Flex在移动布局上已经运用的很广泛了. 比如我们常见的垂直居中, 原先需要好几行代码的效果, 现在就一行align-items: center就能解决了, 十分便利. Flex网上已经有太多的详细教程了. 考虑到篇幅限制, 这边也就不再过多的赘述了. 不过值得一提的是, Flexbox是有新旧两个版本的, 新的是display: flex, 旧的(2009 年的语法)是display: box; 两者作用都差不多, 只是使用的属性名有些差异, 如果要兼容低版本的浏览器的话可以考虑后者. 扩展阅读:[张鑫旭]CSS box-flex 属性，然后弹性盒子模型简介: http://www.zhangxinxu.com/wordpress/?p=1338Flex 入门: http://ife.baidu.com/note/detail/id/952Flexbox 详解: https://segmentfault.com/a/1190000002910324 移动端一些常见的坑1px border这个问题常出现在 ios 下, 其根本原因还是retina屏的问题. 1px使用了2dp渲染, 因此看上去就会粗一点. 常见的解决方案有以下几个: 背景渐变 CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的。 123456789101112131415161718192021@mixin commonStyle() &#123; background-size: 100% 1px, 1px 100%, 100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top;&#125;@mixin border($border-color) &#123; @include commonStyle(); background-image: linear-gradient( 180deg, $border-color, $border-color 50%, transparent 50% ), linear-gradient( 270deg, $border-color, $border-color 50%, transparent 50% ), linear-gradient(0deg, $border-color, $border-color 50%, transparent 50%), linear-gradient(90deg, $border-color, $border-color 50%, transparent 50%);&#125; 缺点就是没办法实现圆角. 使用 scale 缩放 0.5 倍 1234567891011121314151617.sidebar .folder li &#123; padding: 8px 0 8px 15px; color: #7c7c7c; cursor: pointer; position: relative;&#125;.folder + li:before &#123; position: absolute; top: -1px; left: 0; content: ''; width: 100%; height: 1px; border-top: 1px solid #ddd; -webkit-transform: scaleY(0.5);&#125; 多行文本溢出webkit 内核的浏览器可以尝试使用-webkit-line-clamp, 可惜兼容性不高. 12345678.intwoline &#123; display: -webkit-box !important; overflow: hidden; text-overflow: ellipsis; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2;&#125; 终端交互优化最近几年，爆炸式的移动 Web 浏览器的使用打破了这个途径。低带宽，高延迟，小内存，低处理器性能的移动设备环境，迫使开发者不得不想办法通过优化前端页面的性能来满足用户的性能预期。 300 毫秒的故事 移动 web 页面上的 click 事件响应都要慢上 300ms 移动设备访问的 web 页面都是 pc 上的页面. 在默认的 viewport(980px)的页面往往都是需要”双击”或”捏开”放大页面, 来看清页面. 正是为了确定用户是”双击”还是”单击”. sofari 需要个 300ms 的延迟来判断. 而后来的 Iphone 也一直沿用这样的设计, 没借鉴成功 iPhone 的 android 也沿用了这样的设计. 于是”300ms 的延迟”就成为了一道规范. 因此针对这个延迟, 出现了使用 tap 基础事件去代替 click 事件. 已经有成熟的类库去帮我们实现了, 这也不展开讲. 移动端的事件现在智能手机的普及, 触摸成为了移动设备的交互的核心事件, 主要有这几种常用的事件• Touchstart: 手指触摸屏幕触发(只有第一下才会触发)• Touchmove: 手指在屏幕滑动, 连续触发• Touchend: 手指离开屏幕时触发• Touchcanel: 系统取消 touch 时候触发(不常用) 除了常见的事件属性外, 触摸事件也有自己专有的触摸属性: touches: 跟踪触摸操作的 touch 对象数组 targetTouches: 特定时间目标的 touch 对象数组 changeTouches: 上次触摸改变的 touch 对象数组 其中touches是最为常用的. 它是一个数组, 包含着几个 touch 对象, 每个 touch 对象包含如下属性:• clientX: 触摸目标在视口中的 x 坐标• clientY: 触摸目标在视口中的 y 坐标• Identifier: 标识触摸的唯一 ID• pageX: 触摸目标在页面中的 x 坐标.• pageY: 触摸目标在页面中的 y 坐标.• screenX: 触摸目标在屏幕中的 x 坐标• screenY: 触摸目标在屏幕中的 y 坐标• target: 触摸的 DOM 节点目标 不过值得注意的是 Android 下可能会有 touchend 不触发的 bug, 已知 Android 4.0, 4.1, 4.4 ~ 5.0 都有这个 bug. 弹性滚动当客户端的页面滚动到底部或顶部的时候, 滚动条会允许我们再向上(下)拖, 松开就会有缓冲反弹的效果, 能有一个良好的用户体验. 移动 web 页面也有这样的能力. 但是滚动有几种情况需要考虑(副作用): body 层滚动: (系统特殊化处理)自带弹性滚动, overflow:hidden 失效, GIF 和定时器暂停 局部滚动: 没有弹性滚动, 没有滚动惯性, 不流畅 而局部滚动开启弹性滚动的方式也很简单, 只需要在 body 上添加如下的代码: 12345body &#123; /* android 不支持, 但是有类库支持*/ overflow: hidden; -webkit-overflow-scrolling: touch;&#125; 上拉刷新, 下拉加载在移动端, 我们常常能看到这种 —— 顶部会允许下拉一小点距离, 松开时页会有弹性的滚动向下, 并且加载数据. 这是一种良好的交互. 多数类库或者插件都能实现这种效果. 可惜本人移动端的经验不足, 没有自己去实现过一次. (再占一个坑吧~ 总结移动端与 PC 端的开发主要还是着重点不同吧. 比如在移动开发时, 我们必须要考虑用户的流量, 并不是所有人都在用着好的 WIFi 来上网.其中如何在这个小屏幕下给用户带来良好的体验也是另外一门学问. 本文只是总结一些常见的东西, 比如移动端适配也还没有讲. 如果以后自己的工作重心倾向移动端的话, 就会继续再更新相关的内容吧~ 参考资料:饿了么 - 移动端 Web 开发踩坑之旅: https://zhuanlan.zhihu.com/p/26141351Hello, 移动 WEB: https://www.imooc.com/learn/494]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>解决方案</tag>
        <tag>移动端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我们要选用 Vue/React/Angular 进行开发]]></title>
    <url>%2Fblog%2F2018%2F01%2F23%2FJavaScript-%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%94%BE%E5%BC%83JQuery%E8%80%8C%E9%80%89%E7%94%A8Vue-React-Angular%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本篇文章是笔者早期写的，现在回顾来看其实是有一些片面的。jquery的语法封装确实不错JQuery, 曾经从事网页工作者的标配, 以前还没有前端的概念, 但不懂JQuery几乎是会被嘲讽的. 而当下的使用量却逐年降低, 更多的用户转向新兴的 React/Angular/Vue . 今天我们来聊聊, 相比JQuery成熟庞大生态圈, 为什么我们现在开始逐步的放弃 JQuery.前言截止至笔者写这篇文章为止(2018.1), 前端开发的大趋势主要是以下几点:旧浏览器逐渐被淘汰(比如IE8及以下, 主流框架已经放弃了支持)移动端需求的增加用户体验要求变得更高前端架构从传统的后台 MVC 向 RESTFul API + 前端 MV* 迁移众所周知. JQuery只是一个DOM和ajax的封装库. 现在前端项目的日益发展导致JQuery已经不足以承载太多的复杂项目了. JQuery能兼容各种低版本的浏览器这一大优势也在旧浏览器淘汰的路上逐步减弱. 越来越多的开发者开始拥抱新型框架, 它们使前端不太需要关心DOM了, 只需要关心状态.Vue因为我目前主要使用的是Vue的技术栈, 就来说说为什么要选择 Vue 吧.首先, Vue.js是一个库, 并不是一个真正框架(或者说是一个UI层面的框架). 它相比其他两个主流框架 (React/Angular) 来说 Vue 的学习成本相对来说会比较低. 其次 vue 的作者是国人尤雨溪, 因此它对中文的支持会更友好一点(说句题外话, 偶尔能看到有老外吐槽. Vue.js的源码偶尔能看到中文的注释2333).Vue是渐进式框架, 它主要关注的是视图管理. 其核心思想主要是数据驱动和组件化. vue的优势主要有以下几点:侵入性低不对整体构架做过多约束, 方便与其他库或是已有的前端技术栈整合. 比如说当前的项目就是在使用JQuery, 我们也可以将项目移入vue里, 然后逐步的进行改良.vue鼓励模块化因为组件系统是 Vue 的另一个重要概念, 因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用. 这将有利于将界面代码自然分割成更容易维护的模块. 简而言之就是模块化开发, 减少代码的重复性和提高复用性.vue.js比较推荐的是基于commonJs的一个模块方案. 通过webpack这样的模块构建工具, 将一个组件的模块, css和js都写在同一个文件里. Vue本身也有自己脚手架叫做vue-cli, 通过脚手架来帮助我们自动构建项目, 再使用npm进行包管理也是使项目模块化的一种.Vue的语法糖和各种修饰符使得编写JS变得更加的容易. 同时使用一些依赖库, 比如babel使我们能大胆的使用ES6的语法糖. 原先需要封装一个函数的命令, 现在只用一句代码就能解决了. 大大的提高效率.Vue也有自己的生态系统和一个活跃的社区.后记JQuery作为曾经的霸主, 现在市场使用的份额仍然不小. 原因主要是一些老旧的项目仍然在使用着. 其次, 有些时候我们也会遇到需要频繁操作DOM的场景, 再加上JQuery庞大的生态圈. 有很多完善的插件仍然可以使用. 因此, JQuery虽然过时了, 但在未来几年中, 也必然还会有它的份额存在.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>框架</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化 - 回流与重绘]]></title>
    <url>%2Fblog%2F2018%2F01%2F15%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[回流与重绘已经是个老生常谈的问题啦, 但提到性能优化上却又必不可免的提到它. 今天来谈一谈什么是回流与重绘, 我们该如何去测试, 如何针对性的去优化.概述在HTML中, 每一个标签都有自己的盒子模型. 浏览器在解析HTML的过程中会通过一个叫frame的对象对盒子进行操作. 它主要有三个动作:构建frame, 以建立DOM树.reflow, 布局引擎为frame计算图形, 以确定对象位置, 浏览器根据各种样式来计算结果放在它该出现的位置.repaint, 当计算好盒子模型的位置, 大小以及其他属性后, 浏览器就根据各自的特性进行绘制一遍, 显现出来给用户看.回流的代价回流(reflow)就是布局引擎为 frame 计算图形的过程. 但是这里需要我们注意的是, 回流并不仅仅只是在渲染页面的时候会触发, 实际上当你修改某个 css 属性或者操作 DOM 时, 就有可能会触发回流和重绘.也就是说, 我们操作 DOM 实际上是有代价的. 因为 DOM 的改变会导致浏览器重新计算的它的位置和渲染的样式. 我们来做一个假设, 当用户作出某个操作时(比如下拉滚动条), 你的页面中有几十个 DOM 节点同时发生回流绘制, 那这中间消耗的可是浏览器的资源, 可想而知这样页面的性能自然弱了下来.如何触发YaHoo!性能小组总结了一些导致reflow发生的一些因素:调整窗口大小改变字体增加或者移除样式表内容变化，比如用户在 input 框中输入文字, CSS3 动画等激活CSS伪类，比如:hover操作class属性脚本操作DOM计算offsetWidth和offsetHeight属性设置 style 属性的值而repaint只要视觉效果改变了, 就一定会触发repaint. 比如color或者background. 这个很好理解, 如同字面意思一样. 重绘嘛, 就是字体颜色发生了变化浏览器需要重新绘制一遍. 这里值得一提的是, 触发reflow一定会触发repaint, 而触发repaint却不一定会触发reflow.如何调试接下来我们找个页面测试一下, 看看该如何去调试回流与重绘的.先来介绍一下我使用的工具. 我们打开天猫官网, 打开Chrome开发者工具, 找到 More tools =&gt; Rendering 面板， 可以看到以下几个选项:Paint flashing - 高亮(绿色)显示重绘的页面区域Layer boders - 我们知道页面是由多个”图层”组合的, 最终显示给用户看的就是多图层叠加在一起的效果, 区别无非是层级的问题(css的absolute和z-index就可以很好的说明这一点). 勾选这个选项可以显示图层边款, 我们再根据分析哪些不是我们想要的.FPS meter - 玩游戏的同学大概会比较了解这个, 也就是显示绘制每秒帧数，帧速率分布和GPU内存. 这个更多的是用来分析页面交互和动画性能.Scrolling performance issues - 滚动性能问题. 它会高亮显示可能减慢滚动速度的元素(蓝绿色), 其中包括触摸和滚轮事件处理程序以及其他主线程滚动情况.(有兴趣的同学可以在淘宝的官网勾上这个选项, 看下都有啥).这里主要讲Paint flashing. 我们勾上按钮后, 首先能看到天猫的Logo是一个GIF的动态图, 不断闪烁的绿色高亮提醒着我们, 浏览器正在努力的绘制的图形. 这点很好理解, 因为它是动态的, 浏览器需要绘制 gif 的每一帧展示给用户看. 首屏的轮播图也同理, 内容的不断变化触发着回流与重绘.紧接着我们往下滚, 发现左下角的工具栏会随着滚动而发生重绘. 很显然, 这种是使用了fixed定位. 我们知道fixed是相对浏览器窗口进行定位的. 我们滚动一点, 它会重新计算位置, 导致触发回流. 所幸的是fixed定位只会对自己渲染, 而不会影响身边的DOM.接着我们继续测试. 咦? 这几个商品模块好像不太对劲呀? 怎么停止滚动了, 还是会发生不断的重绘? 打开审查元素一看, 模块中有一个 gif 的背景图片. 我们将属性关闭, 发现几个模块的重绘都消失了, 果然是这东西作祟呀. 紧接着我们来检查一下这 gif 是有什么特殊的作用. 将表面的DOM删掉, 还原background属性 —— 噢~原来是一个加载的loading…. 父元素加一个loading动图, 在子元素还没加载出来时显示loading. 加载后由于层级的关系自然就覆盖了上去, 用户自然就看不到了.这种看似巧妙简便的方法实则是在用户看不到的地方在浪费无意义的性能消耗而已. 因此我还特意的去测试了淘宝和京东的情况, 发现这种写法只有天猫才有. 不知道写页面的同学是偷懒还是什么其他的原因, 这里我们可不要养成这种习惯~很多时候坑就是自己挖的最后又自己踩了上去.如何优化到这里我们已经了解了渲染规则后, 那么就可以针对性的进行控制优化 —— 在我们 coding 的时候合理的去避开回流的影响来减少页面的开销.display:none这个属性已经被玩烂了, 该属性的作用就如同它名字一样直观. display就是用来控制显示的状态嘛… 因此很多人喜欢拿它来做隐藏某一个元素的方法. 而背后却忽略了(或者说不知道)它本身所带的回流性能开销(因为会影响节点的位置从而触发回流和重绘).值得庆幸的是, 已经有前行者帮我们踩过很多坑, 我们只需站在巨人的肩上, 借鉴一下前人的经验:如果想设定元素的样式，通过改变元素的class类名 (尽可能在 DOM 树的最里层)避免设置多项内联样式应用元素的动画，使用position属性的fixed值或absolute值(前文说过, 它只会影响自己)权衡平滑和速度避免使用table布局避免使用 CSS 的JavaScript表达式 (仅 IE 浏览器)除此之外, 使用JavaScript想要动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能.总结最后总结一下所学的概念, 回流(reflow), 就是布局引擎为frame计算图形, 确定节点位置的一个步骤. 其中触发回流的原因主要是节点(DOM)大小或者位置的改变才会触发回流. 而重绘, 就是表面的视觉效果改变了, 就会触发重绘. 其中触发了回流紧接着也会触发重绘, 而触发重绘不一定会触发回流(ahh..有点像绕口令).参考资料形象化的reflow: http://www.aoao.org.cn/blog/2008/05/reflow/影响 reflow 的因素及其优化: http://www.planabc.net/2009/04/13/reflow/Gecko Reflow Visualization - mozilla.org: https://www.youtube.com/watch?v=ZTnIxIA5KGw回流与重绘: CSS性能让JavaScript变慢?]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>性能优化</tag>
        <tag>HTML</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化 - 基础的性能优化]]></title>
    <url>%2Fblog%2F2018%2F01%2F13%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[其实很多性能方面的问题, 很多都是从基础就开始影响. 既然如此我们也从最底层逐步分析, 切入每一点小细节~图片优化web早期, 人们有很多想要实现的设计效果出于css或兼容性的限制, 不得不由图片来去实现这种效果. 以现在时代的眼光来说, 无疑是很不优雅的. 撇开图片本身所占用的空间大小外, 本身代码结构就不够语义化. 那么现在这个CSS3都已经普及的年代, 来试着让HTML, CSS属性或SVG用寥寥数行的代码来代替图片来实现效果吧~ 比如一个圆角, 一个渐变的海浪线等.图片格式每一种图片格式都有着自己的特点和优势, 下面来了解一下现在常见的图片格式来”对症下药”.主流的图片格式jpg 全名是JPEG. JPEG图片以24位颜色存储单个位图.png 可移植网络图形格式. 使用png格式的图片更多的是看中它有透明图层, 因为它是256色, 每一色都可以作为透明像素. 但相对的代价就是体积较大(这个可想而知嘛, 图片里面的信息装的多了, 体积自然就大了).GIF 这个稍微有点网络常识的对会知道, 常用于做动画.SVG 可缩放矢量图形. 它能很好的处理图形大小的改变, 放大缩小都不会失真, 适合静态图片展示，高保真文档查看和打印的应用场景. 如今主流浏览器都对它有着很好兼容性支持.没有被Web标准采纳的格式, 但还是值得关注图片格式APNG APNG 是出自 Mozilla 公司下的两位程序员之手, APNG 的出现是为了代替 GIF. 它相较GIF来说有着更好的图片质量, 还支持着透明图层, 同时图片的大小都比 GIF 格式要小.可惜由于出现的较晚, 没有被Web标准给采纳. 截止到笔者写这篇文章的时间(2018.1), Edge这个不合群的家伙在最新版本 Edge 17 仍然还没有支持这个格式, 而chrome 59才开始支持. 因此兼容性不高, 平时也很少能看到这种格式的出现.Webp是出自Google之手, WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。同上面的 APNG 一样, 同样没有被Web标准所采纳. 不过在 caniuse 上能发现, 如今国内大半的用户已经支持了 WebP , 这个未来还是可以小小的期待一下.正确的使用图片格式话归正题, 下面针对不同的使用场景, 来选择正确的图片格式.首先是jpg, 一般不需要透明图层的图片一律使用jpg, 它相对png来说两者的体积之差能有几倍之差.如果需要比较通用的动画的话, GIF是唯一的选择. 如果是相对简单的GIF动画的话, 也可以考虑使用CSS3来实现.如果需要清晰显示颜色丰富的图片或者需要用到透明图层的话, png是一个比较好的选择页面中图片加载方式细心的你或许会发现, 有时在网络慢的情况下, 能看到图片一点一点从上到下的加载. 或者是先模糊, 再清晰的加载方式.实际上这是图片的压缩算法呈现的效果, 逐行显示是离散余弦变化. 而模糊到清晰的是小波算法. 浏览器先读取图片的压缩算法, 再根据算法来选择不同的渲染算法. 下面是某图站的一张大的壁纸加载过程(没有找到小波算法的图, 以后留意到了再回来补)参考资料APNG 那些事常见的图片优化方案CSS-Sprite在页面中, 我们经常能看到一些icon图标. 这些icon实际上占用并不大, 但奈不住多呀. 100个icon的话就要发送一百个HTTP请求. CSS Sprite(精灵). 利用CSS的background-position和background-image属性, 只需要引用一张图片即可. 这极大的节省了HTTP请求量.iconfonticonfont 和上面所提的css-sprite方法类似, 不同的是这个方法是通过引入字体图标的形式. 好处是设置字体图标的颜色或者可以通过设置font-size来改变尺寸, 并且不容易失真.当然, 现在都是使用自动化工具, 都不需要自己手动去调整&lt;picture&gt;标签HTML5新出了一个&lt;picture&gt;标签, 它是一个容器, 用来为其内部特定的&lt;img&gt;提供多样的&lt;source&gt;元素. 浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源. 也就是所谓的响应式图片. 由于兼容性所限, 因此当下并没有广泛使用.media属性允许你提供一个用于给用户代理作为选择&lt;source&gt;元素的依据的媒体查询。如果这个媒体查询匹配结果为false，那么这个&lt;source&gt;元素会被跳过, 使用如下.12345&lt;picture&gt; &lt;source srcset="mdn-logo-smaller.png" media="(max-width: 768px)"&gt; &lt;source srcset="mdn-logo-big.png" media="(min-width: 1000px)"&gt; &lt;img src="mdn-logo-narrow.png" alt="MDN"&gt;&lt;/picture&gt; 构建自动化工具实现优化这个一句话说不完, 以后单独拎出来说这东西吧. 视频优化当下视频播放器分为两大流派, 一个是HTML5新进入的video标签, 使用方式简洁. 也是现在主流播放方案. 另一个是Flash播放器, 也是过去常用的播放方案. 虽然技术成熟, 插件多, 但也是逐步的将被淘汰. chrome浏览器默认禁止Flash播放器的使用, 就连Edge都要手动开启才能使用. 来对比一下两者的优缺点 优点 缺点 video 不需要下载额外的资源(如插件什么的) 不同浏览器video标签的外观都不一样. 如果要统一的话需要自己写UI来实现 Flash 兼容性好, 只需要有 Flash player 播放器插件都可以进行播放 1. 需要下载额外的 swf 播放文件才可以播放, 浏览器必须要有Flash player插件(回想以前网页老是让你下载Flash的场景)2. Flash player 版本的碎片化3. UI定制需要 as(带有学习成本) 当下主流的方案Flash 和 HTML5 两个方案相结合, 组成一个完整的方案. 当下就有几个成熟稳定的库, 如Flowplayer和VideoJs等. 视频优化需要的解决问题 由于各浏览器UI不同, 设计师会要求我们按照设计图做播放器. 在一些视频网站中, 可能产品经理就会让我们实现, 让用户一进来就最先看到视频.浏览器会将所有的多媒体文件放在最后面加载, 无论标签位置放置在什么位置. 解决的方案就是将&lt;link&gt;代替&lt;script&gt;标签引用. 常用的前端缓存技术SessionStorage 临时性存储, 数据仅仅在当前的页面生效, 关闭页面后数据就自动清除了. 同时刷新页面不属于”离开页面”的范围, 数据仍然会存在. 现在微信公众号开发常用这种方法来记录用户信息. Cookie, 兼容性最好的本地存储. 缺点是有大小的限制, 而且每次发送请求时, 请求头会带着Cookie一起发送过去.(这里有个问题, 如果在cookie中存储了1M的数据, 那么在请求的时候, 1M的数据也会跟着请求发送到服务端. 这就很大的影响带宽了) 现在基本大多数登录的合法性验证都是用cookie验证的. LocalStorage 特点是持久储存, 操作方法和 SessionStorage 乐视, 也都是操作key-value的形式. 几乎所有现代浏览器都已经支持了. 值得注意的是, LocalStorage 虽然可以永久储存, 但是无法跨浏览器的获取数据的, 还需要注意储存上限. 高性能DOM说到高性能的DOM, 就不得不提回流与重绘这个概念. 为此我又专门的写了一篇回流与重绘. 有兴趣的同学可以去看一下. 总结上文都只是在基础上的优化. 还有更多项目内工程化的优化就再等咱有时间再更新相关的内容吧~ 参考资料前端性能优化-通用的缓存SDK: https://www.imooc.com/learn/866]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解之排序二叉树]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是一种具有层级特性的的数据结构. 这些知识虽说在日常工作中不常使用, 但还是有必要让我们去学习一下, 研究其原理是如何运作. 下面将分享自己的一些理解和学习笔记, 来谈一谈什么是排序二叉树.二叉树的定义树(Tree), 是(n&gt;=0)个节点的有限集. 其中 n=0 时, 我们称之为空树. 在一棵非空树中, 只有一个根节点. 在二叉树中, 每个节点最多有两个子节点. 一般称为左节点和右节点(左、右子树).排序二叉树排序二叉树, 又称为二叉查找树. 它有着自己显著的特点:首先一个节点左孩子的值, 一定小于它本身节点的值.一个节点右孩子的值, 一定大于它本身节点的值.左、右孩子(子树)也分别是排序二叉树.构建排序二叉树二叉树大多也是递归定义的. 下面根据排序二叉树的特性来创建一个二叉树.1234567891011121314151617181920212223242526272829303132333435363738394041424344function BinaryTree(key) &#123; var root = null; var Node = function(key) &#123; this.key = key; this.left = null; this.right = null; &#125;; var insertNode = function(node, newNode) &#123; // 对比新旧节点 if (newNode.key &lt; node.key) &#123; // 左节点是否存在 if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; // 右节点是否存在 if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; // 暴露方法, 插入节点 this.insert = function(key) &#123; var newNode = new Node(key); // 根节点是不是空的 if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;;&#125;var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13];var binaryTree = new BinaryTree();nodes.forEach(function(key) &#123; binaryTree.insert(key);&#125;); 遍历二叉树我们已经构建好了一个排序二叉树, 现在想要获取二叉树每一个节点的信息, 因此我们需要遍历节点, 对它做一些操作. 中序遍历二叉树有三种遍历的方法, 分别是中序遍历, 前序遍历, 后序遍历. 其中中序遍历的顺序是: 左子树 -&gt; 根元素 -&gt; 右子树. 对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列. 百闻不如一见, 我们先看看图中的路线图, 整理一下思路先. 这里我们需要加入中序遍历的接口, 因此我们在原先代码上继续扩展并运行.控制台会依次输出”1 3 4 6 7 8 10 13 14” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 function BinaryTree(key) &#123; var root = null; var Node = function (key) &#123; this.key = key; this.left = null; this.right = null; &#125; var insertNode = function (node, newNode) &#123; // 对比新旧节点 if (newNode.key &lt; node.key) &#123; // 左节点是否存在 if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;+ // 中序遍历+ var inOrderTraverseNode = function (node, callback) &#123;+ // 递归遍历, 当到最后叶子节点时, 下面没有节点就会直接返回+ if (node !== null) &#123;+ inOrderTraverseNode(node.left, callback);+ callback(node.key);+ inOrderTraverseNode(node.right, callback);+ &#125;+ &#125; // 插入节点 this.insert = function (key) &#123; var newNode = new Node(key) if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;+ /**+ * 中序遍历+ * @param &#123;Function&#125; callback - 决定如何处理节点+ */+ this.inOrderTraverse = function (callback) &#123;+ inOrderTraverseNode(root, callback);+ &#125;+ &#125; // 初始化调用 var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13] var binaryTree = new BinaryTree(); nodes.forEach(function (key) &#123; binaryTree.insert(key) &#125;)+ // 调用成功后输出当前节点+ var callback = function (key) &#123;+ console.log(key)+ &#125; // 中序调用+ binaryTree.inOrderTraverse(callback); 前序遍历虽然前面已经有了中序遍历可以遍历节点, 为啥还要浪费精力学前序呢? 诶~这是因为每一种遍历都有自己应用优势. 前序遍历最大的作用, 就是如果我们想把已经有了的二叉树重新复制一遍, 使用前序遍历得到的效率相比重新构造一次来说, 两者的差距能差好几倍. 前序遍历的顺序与中序遍历有些不同, 前序是以: 根元素 - 左节点 - 右节点的顺序来遍历. 这里将遍历的路线图简化了下, 红色输出, 黄色返回上一级, 而绿色则是右子树遍历. 可以看到这是很典型的递归思想. 紧接着我们继续在代码上进行扩展. 12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code... // 前序排序 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key) preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) &#125; &#125; /** * 中序遍历 * 暴露中序遍历的方法 * * @param &#123;Function&#125; callback - 决定如何处理节点 */ this.preOrderTraverse = function (callback) &#123; inOrderTraverseNode(root, callback); &#125; binaryTree.preOrderTraverse(callback); // callback会依次打印 8 3 1 6 4 7 10 14 13&#125; 后序遍历看到这里, 大家可能已经意识到了. 不同的遍历方法实际上是对当前的节点访问的顺序不一样. 后序遍历的访问的次序就是: 左节点 - 右节点 - 根元素. 它的特点是, 当下面的左右孩子都遍历完了后才会触发回调函数(callback). 因此适用于破坏性操作的情况, 比如删除所有的节点 12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code... // 后序排序 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; preOrderTraverseNode(node.left, callback) preOrderTraverseNode(node.right, callback) callback(node.key) &#125; &#125; /** * 后序遍历 * 暴露后序遍历的方法 * * @param &#123;Function&#125; callback - 决定如何处理节点 */ this.postOrderTraverseNode = function (callback) &#123; inOrderTraverseNode(root, callback); &#125; binaryTree.postOrderTraverse(callback); // callback会依次打印 1 4 7 6 3 13 14 10 8&#125; 二叉树节点查找找出排序二叉树的最大节点和最小节点实际上也很简单. 前文提过, 根据排序二叉树的特性, 节点左孩子的值, 一定比节点本身小. 节点右孩子的值一定比节点本身大. 因此我们可以根据这个规则来进行查找: 123456789101112131415161718192021222324252627282930313233343536373839function BinaryTree(key) &#123; // other code ... var minNode = function (node) &#123; if (node) &#123; // 循环逐级向下查找, 直到没有左孩子(最小节点) while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; // 循环结束后直接反馈 node值 return node.key; &#125; return null; &#125; var maxNode = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.right) &#123; node = node.right; &#125; return node.key; &#125; return null; &#125; // 最小节点 this.min = function () &#123; return minNode(root) &#125; // 最大节点 this.max = function () &#123; return maxNode(root) &#125;&#125;console.log("min node is:" + binaryTree.min()) // 输出1console.log("min node is:" + binaryTree.max()) // 输出 14 查找节点是否存在:12345678910111213141516171819202122232425function BinaryTree(key) &#123; // other code var searchNode = function (node, key) &#123; if (!node) return false // 依旧是递归思想， key值比node.key值小, 就去查询左子树 if (key &lt; node.key) &#123; return searchNode(node.left, key) &#125; else if (key &gt; node.key) &#123; return searchNode(node.right, key) &#125; else &#123; return true &#125; &#125; this.search = function (key) &#123; return searchNode(root, key) &#125;&#125;console.log(binaryTree.search(7) ? "key 7 is found" : "key 7 is not found")// key 7 is foundconsole.log(binaryTree.search(9) ? "key 9 is found" : "key 9 is not found")// key 9 is not found 总结最后将上面的知识总结一下. 首先知道了树的实际上是一种具有层级特性的数据结构, 其中排序二叉树又是一种特殊的树. 它的具有以下几种性质: 如果左(孩子)子树不为空, 那么左子树一定比父节点(根节点)的值小. 如果右(孩子)子树不为空, 那么右子树一定比父节点(根节点)的值大. 其中左、右子树也分别是排序二叉树. 紧接着创建了二叉树节点后, 我们需要去遍历这些节点. 遍历的方法又分前序遍历, 中序遍历, 后序遍历. 三者的区别仅在遍历的顺序不同, 但却有着不同优势. 前序遍历是唯一一个从根元素开始遍历的, 其顺序为 根 - 左 - 右, 由于它是从根左右开始, 非常适合像复制节点这样的工作. 中序遍历的顺序是 左 - 根 - 右, 返回的是一个从小到大(从大到小)排序的好序列. 后序遍历的顺序是 左 - 右 - 根, 其特点是执行操作时，肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点. 后面还讲到了二叉树节点查找, 利用递归找到二叉树中最小(大)的节点值等.数据结构的学习之路还很长, 以后再一点一点慢慢的深入吧~]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>排序二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Vue项目的构建速度]]></title>
    <url>%2Fblog%2F2018%2F01%2F06%2F%E4%BC%98%E5%8C%96Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[随着项目依赖的增加, 在配合开发的时候听到后端同学的抱怨 build 时间长, 及其影响开发效率和心情. 然后翻阅了相关的资料开启Vue优化之路~项目依赖管理首先检查一下依赖, 去掉对项目没用的依赖, 然后注意开发依赖跟生产依赖不能弄混. 如scss, scss-loader要放在开发依赖中, 因为编译后就不需要了的.. 这一点我以前也有文章提过两者的区别, 有兴趣的同学可以去看看.优化配置修改config/index.js下的文件1234567// 开发环境dev下, 设置为`eval`能提高最快速度, 但是缺点是不能正确显示行号, Debug会有点影响devtool: 'eval'// 关闭生产环境的sourceMap, 不懂是啥的话可以看下面的文章// 阮一峰 - JavaScript Source Map 详解// http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.htmlproductionSourceMap: false 在src/mian.js关闭生产环境下的调试信息 12345// 关闭生产环境下的调试信息const isDebugMode = process.env.NODE_ENV !== "production";Vue.config.debug = isDebugMode;Vue.config.devtools = isDebugMode;Vue.config.productionTip = isDebugMode; 启动 DllPlugin在build文件夹中新增webpac.dll.config.js的js文件. 我们将第三方库抽取出来, 打包dll代码. 12345678910111213141516171819202122232425262728293031323334353637const path = require("path");const webpack = require("webpack");// 抽取第三方库const vendors = [ "vue/dist/vue.common.js", "vue-router", "babel-polyfill", "axios", "element-ui", "mint-ui" ]module.exports = &#123; entry: &#123; vendor: vendors &#125;, output: &#123; path: path.join(__dirname, "../static/js"), filename: "[name].dll.js", library: "[name]_[hash]" // vendor.dll.js中暴露出的全局变量名 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, ".", "[name]-manifest.json"), // 此处需要和 output.library 的值一致 name: "[name]_[hash]", context: __dirname &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 然后我们写一个快捷的调用方式, 在package.json的script上添加一行代码:123456&#123; "scripts": &#123; // other code... "dll": "webpack --config ./build/webpack.dll.config.js" &#125;&#125; 这样就可以直接在命令行使用npm run dll, 生成vendor-manifest.json和vendor.dll.js, 前者是库文件的node_modle路径和webpack打包id的映射. 后者是我们打包后的代码库. 随后这里我们再安装html-webpack-include-assets-plugin和copy-webpack-plugin这两个插件.1npm insatll --save-dev html-webpack-include-assets-plugin copy-webpack-plugin copy-webpack-plugin是因为项目的需要，我们需要copy到指定的目录下.html-webpack-include-assets-plugin是将vendor.dll.js插入到index.html里. 这里值得一提的是, 虽然我们可以直接在根目录的index.html里插入script, 但实际上并不妥当的. 当你npm run dev后, 你会发现在控制台那一行红色的报错, 告诉着你东西找不到, 虽然不影响开发, 但你会看得很难受. 紧接着我们在webpack.prod.conf.js上引用我们添加的依赖, 再添加以下代码1234567891011121314151617181920212223// config 是 config/index.js 里的配置// utils.assetsPath 也是 build/utils.js的配置// 这里这样写是为了跟项目统一plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require('./vendor-manifest.json') &#125;), // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]), // 将 vendor.dll.js 插入HTML里 new HtmlWebpackIncludeAssetsPlugin(&#123; assets: [utils.assetsPath('js/vendor.dll.js')], files: ['index.html'], append: false &#125;),] 在命令行进行打包npm run build, 可以看到构建的速度大大的提高啦, 我们的优化也告一段落了~ 后记最后再优化时说说踩的坑, 给后来人一些提示. Uncaught ReferenceError: vendor_library is not defined - 检查HTML里是否插入vendor.dll.js, 文件是否加载成功, 或者检查是否有路径问题. 一些打包后hash不变仍然会被清除重新打包 … 这是因为vue-cli默认配置会直接清空dist文件夹里的所有文件, 你提前放一些js文件进去也是没有用的.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对MVC与MVVM的理解]]></title>
    <url>%2Fblog%2F2018%2F01%2F05%2F%E6%B5%85%E8%B0%88%E5%AF%B9MVC%E4%B8%8EMVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开发中我们常听说MVC, MVP, MVVM这些好像很高端的名词, 那么你了解他实际上是什么东西吗? 下面谈谈对它们的理解.1. MVC其实上面所提的三者都是一种软件架构模式(或者说是一种概念), 其中MVC的历史最为长远.MVC模式可以分成以下三种, 就是模型(module), 界面(View), 控制器(controller). 三者之间的关系.MVC的好处在于视图控制模型分离降低耦合性提高代码重用性和可维护性因为是单向模块化, 不同层各施其职，互不干涉有优点再说说缺点:清晰的构架以代码的复杂性为代价, 对小项目优可能反而降低开发效率.Controller层代码难以复用的, 到后面会变得臃肿.运行效率相对较低, 太过于复杂反而不太适合中小型项目MVVMMVVM(Module-View-ViewModule)的出现主要是为了解决在开发过程中Controller越来越庞大的问题, 它将Controller替换成了ViewModule, 同时改变了通讯模式, 这是MVVM相对于MVC改进的核心思想.其中MVVM的显著特点就是双向绑定. view的变动会自动更新到Model中. 其中当下很流行的Vue框架就是采用了这个模式. 下图的就能很清晰的看的懂ViewModel是如何做的.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git emoji使用指南]]></title>
    <url>%2Fblog%2F2017%2F12%2F31%2FGit-emoji%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[emoji源于日语词汇“絵文字”, 想必大家对它都挺熟悉的吧, 其拟人化的生动形象，已经成为当下流行的表情之一. 接下来讲一下如何规范的在git中使用emoji提高我们项目的可读性吧~使用方式在git commit上加入emoji的二进制符号, 格式为1:emoji1: :emoji2: 本次提交的主要内容 如初次提交: 1git commit -m " Initialize Repo" 相关规范emoji 表情在提交代码的时候也不能乱用，否则容易造成误解. 因此开源项目gitmoji专门规定了在 github 提交代码时应当遵循的 emoji 规范： emoji emoji代码 说明 (喝彩) tada 初始提交 (调色板) art 改进代码的结构/格式 (闪电) zap 提高性能 (火焰) fire 删除代码或文件 (bug) bug 修复一个错误 (紧急救护车) ambulance 关键修补程序 (闪亮) sparkles 引用新功能 (备忘录) memo 编写文档 (火箭) rocket 部署新功能 (重构) recycle 代码重构 (口红) lipstick 更新UI和样式文件 (复选框) white_check_mark 添加测试 (苹果) apple 修复MacOS上的问题 (企鹅) penguin 修复Linux上的问题 (旗子) checkered_flag 修复Windows上的问题 (机器人) robot 解决Android上的问题 (绿苹果) green_apple 解决iOS上的问题 (书签) bookmark 发布/版本标签 (警告灯) rotating_light 移除 linter 警告 (施工) construction 工作正在进行中 (绿心) green_heart 修复CI构建 (下降) arrow_down 降级依赖关系 (上升) arrow_up 升级依赖关系 (图钉) pushpin 将依赖关系固定到特定的版本 (工人) construction_worker 添加CI构建系统 (上升趋势) chart_with_upwards_trend 添加分析或跟踪代码 (减号) heavy_minus_sign 删除依赖项 (鲸鱼) whale 关于Docker的工作 (加号) heavy_plus_sign 添加一个依赖项 (扳手) wrench 更改配置文件 (铅笔) pencil2 修正错别字 (hankey) hankey 编写需要改进的不好的代码 (回退) rewind 恢复更改 (国际化) globe_with_meridians 国际化和本地化 (合并) twisted_rightwards_arrows 合并分支 (打包) package 更新编译的文件或包 (外星人) alien 由于外部API更改而更新代码 (移动搬家) truck 移动或重命名文件 (页面) page_facing_up 添加或更新许可证 (爆炸性) boom 介绍突破性变化 (便当) bento 添加或更新资产 (好的手势) ok_hand 由于代码审阅更改而更新代码 (无障碍) wheelchair 改善无障碍 (灯泡) bulb 记录源代码 (文字框) speech_balloon 更新文字和文字 (存档箱) card_file_box 执行与数据库相关的更改 (声响) loud_sound 添加日志 (静音) mute 删除日志 (用户) children_crossing 改善用户体验/可用性 (建筑) building_construction 进行架构更改 参考资料: Git emoji: https://gitmoji.carloscuesta.meGithub emoji列表: https://segmentfault.com/a/1190000009649780]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新手不知道的JavaScript技巧 - 条件语句的简写技巧]]></title>
    <url>%2Fblog%2F2017%2F12%2F26%2F%E6%96%B0%E6%89%8B%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[可能入坑不久的同学还会用着if (value !== null || Value !== undefined)这样的判断语句, 而实际上只要理解判定的规则, 善用规则, 就能大大的提高代码的可读性. 接下来让我们深入学习一下.开始大多编程语言中最为常用的一个语句就是if语句, 这种条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句. 它的语法如下:123if (Expression) &#123; statement&#125; 其中Expression(表达式/条件)可以是任意表达式或者值. 首先它会解析表达式的值 如果表达式是无法解析的, 会报ReferenceError的错误并停止. 如果不是则继续. 判断值的引用类型, 如果是布尔值, 字符串和符号则继续. null和undefined永远都返回 false. 将值传入toBoolean(exprValue)根据下面的规则转换为布尔值. value Boolean 未定义(Undefined) false 空值(null) false 布尔值(Boolean) 返回参数本身 数字(Number) 如果参数是+0, -0或NaN，则返回false; 否则返回true 字符串(String) 如果参数是空字符串(长度为零)，则返回false; 否则返回true Symbol 返回 true Object 返回 true 这里我们得出undefined, null, NaN, 空字符串, 和数字 0 都是过不了条件语块的规则, 因此我们可以利用这一点来对代码进行简写. 1234567891011121314151617181920212223var userName = 'hello';var flag = false;// bad codeif (value != undefined) &#123; ...&#125;// bad codeif (value !== undefined || value !== null || value !== false) &#123; ...&#125;// good codeif (userName) &#123; something...&#125;// flag锁, 利用取反转换布尔值if (!flag) &#123; flag = true; something...&#125; 相同的, 也没有必要去使用==规范不推荐的方式去隐式转换类型, 这种规则同样适用于三目运算符, switch等条件运算中去… 这样看起来是不是自己的代码整洁多了呢~ 后记才疏学浅, 如果有什么说的不对或者需要改进的地方, 可以给我留言大家一起交流. 原创不易, 如果文章对你有帮助的话就随手点个赞鼓励一下呗~ 参考资料ECMA-262 官方文档http://www.ecma-international.org/ecma-262/6.0/#sec-if-statement]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>JavaScript原理分析</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥WebSockets]]></title>
    <url>%2Fblog%2F2017%2F12%2F25%2F%E5%88%9D%E7%AA%A5Web-Sockets%2F</url>
    <content type="text"><![CDATA[要说最令人津津乐道的新浏览器的API, 就数Web Sockets了. 接下来了解一下这个备受争议的API吧~什么是Web Socket?Web Socket是HTML5出来的一个持久化新协议. 它的目标是在一个单独的持久链接上提供全双工, 让客户端和服务器之间的数据交换变得更加简单.Web Socket是基于HTTP协议来建立连接. 由于使用了自定义的协议, 因此它的URL模式策略也与标准的HTTP不同, 未加密的http://对应着ws://, 而加密的连接的https://也变成https://.那使用Web Socket的好处是什么?能够在客户端和服务器之间发送非常少的数据, 而不用担心HTTP那样字节级的开销. 由于传递的数据很小, 表面看起来会很适用于移动端.主动性大家都知道, 标准HTTP请求是具有被动性的, 如ajax轮询:客户端: “lalala, 帮我看一下我快递有变动吗?”服务端: “没呢, 没变化”客户端: “那现在呢?”服务端: “也还没..”客户端: “那现在呢?”服务端: “还没…”客户端: “那现在呢?”服务端: “好啦好啦, 物流发生变化了, 你看到这里这里了”客户端: “那开始派送了吗?”服务端: “还没…”这样的缺点是什么… ajax轮询需要服务器有很快的处理速度和资源, 而频繁过多的请求可能会报503 Server Unavailable的错误了.而升级为Websocket后, 这时候服务器会主动把东西反馈给你, 如:客户端: “哥们, 咱建立Websocket协议, 需要chat，Websocket协议版本：17（HTTP Request）”服务端：”ok，确认，已升级为Websocket协议(HTTP Protocols Switched)”客户端: “那有啥事的话跟我讲噢”服务端: “balbalbal”服务端: “balbalbal”服务端: “hhhhhhhhhh”服务端: “笑死啦2333333”就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你, 这里场景就适用于聊天室之类的）没有同源限制，客户端可以与任意服务器通信(不用担心跨域)现状与短处既然它存在这种优势为什么如今还是使用的不多呢?HTML5新API嘛… 说到HTML5就不得不考虑到兼容性的问题, WebSocket在各浏览器的兼容性不一致这是问题其一.前文有提过. 相对于PC端, websocket的客户端和服务器之间发送非常少的数据, 表面看起来的确移动端会更有优势. 但是目前以国内的环境来说, 反而不好用. 当网络不稳定的时候开销尤其大.看到这里或许会有人问, 啊? 你之前不是说只需要1次HTTP请求就可以做信息传送了蛮?? 是的, 没错. 大家可能会玩过像阴阳师这样的游戏? 网络一闪, 就会让你重新登录.而长轮询断一次只会卡一秒, 而websocket断了则要重新从认证开始, 那当网络不稳定时, 那开销可想而知.其次就是性能上并没有绝对的优势, 所以当前主流还是标准的HTTP比较多, 而websocket, 据我所知当下适用的场景也只有手游上的使用了.后记websocket的路还很长, 虽然现在使用的不多, 但以后还是可以保留小小的期待. 上文提及资料有部分是来源于网上. 有部分是去咨询了相关的dalao. 才疏学浅若有违权, 或者说的不对的地方望各位指出.参考资料:WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎https://www.zhihu.com/question/20215561/answer/40316953]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>WebSocket</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于点击下拉菜单字体模糊及可能造成boder上下一像素宽度不一的坑]]></title>
    <url>%2Fblog%2F2017%2F12%2F23%2F%E5%85%B3%E4%BA%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E6%A8%A1%E7%B3%8A%E5%8F%8A%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90boder%E4%B8%8A%E4%B8%8B%E4%B8%80%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6%E4%B8%8D%E4%B8%80%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[关于点击下拉菜单会造成文字模糊及boder 1px上下和左右宽度不一致的问题.起始朋友叫帮忙看代码~ 问题是这样的, 当点击下拉菜单时, 整个页面的组件都变模糊一下. 然后border上下的边框能隐约看到会大概溢出那么一点(但是没到一个像素).因为使用了element组件, 大概能想到中间加有transition, 对问题进行排查后发现transform这个属性会对后代元素能产生影响, 将属性删除, 问题解决. 具体影响的原理, 现在占个坑, 以后再深入挖掘…Bug相关的图]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>transition</tag>
        <tag>transform</tag>
        <tag>布局bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git pull远程仓库代码冲突]]></title>
    <url>%2Fblog%2F2017%2F12%2F18%2Fgit-pull%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[常用git与远程仓库进行交互, 难免会遇到冲突的问题. 现在来了解一下, 当出现这种情况时, 该要如何处理.起始代码冲突, 无非就是同时有两个人在改动同一个文件所造成的冲突. 当你使用git pull后, git会提示你:123456$ git pullerror: Your local changes to the following files would be overwritten by merge: src/components/page/file.vuePlease commit your changes or stash them before you merge.AbortingUpdating 8e191be..c301cdc 这时候你可以使用git stash将本地修改存储起来. 使用git status查看, 是不是干净啦~123456$ git stashSaved working directory and index state WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/testHEAD is now at 8e191be Merge branch 'master' of https://github.com/anran758/test$ git status# On branch masternothing to commit, working directory clean 这时再使用将远程仓库的代码pull下来123456 $ git pullUpdating 8e191be..c301cdcFast-forward src/base/fonts/iconfont.eot | Bin 7320 -&gt; 7548 bytes src/components/page/file.vue | 10 +- create mode 100644 static/font_503074_8sfhbdjlucjtt9/iconfont.eot 现在要查看现有的储藏, 可以使用git stash list12$ git stash liststash@&#123;0&#125;: WIP on master: 8e191be Merge branch 'master' of https://github.com/anran758/test 这时我们还原储藏的内容, 使用命令git stash pop &#39;stash@{0}&#39;. 注意这里的要使用引号&#39;stash@{0}&#39;, 因为shell正在使用扩展里的内容, 否则会报一个unknown option: -encodedCommand1234567891011$ git stash pop 'stash@&#123;0&#125;'Auto-merging src/components/page/file.vueOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: src/components/page/film.vueno changes added to commit (use "git add" and/or "git commit -a") 之后就可以使用git diff或者利用图形工具, 如sourceTree(可视化git), vscode编辑器上对比代码, 手动解决冲突即可.]]></content>
      <tags>
        <tag>git</tag>
        <tag>代码冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是.gitkeep? 如何在windows下使用命令行创建.gitkeep文件]]></title>
    <url>%2Fblog%2F2017%2F12%2F16%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA-gitkeep%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在一些脚手架上构建项目中, 你或许会留意到某个目录中会有个名为.gitkeep的空文件. 那么这个文件是用来做什么的呢?缘由什么是.gitkeep? 其实是这样的, 当提交的代码时目录中有空文件夹时git会自动忽略掉. 而有时候你就是想留着这个, 以后有用处不想被忽略怎么办呢? 因此, .gitkeep就应运而生了….gitkeep是一个约定俗成的文件名并没有什么特殊规则, 它就相当于一个占位, 让git开始跟踪这个目录.其实任何文件都可以, 只不过大家都遵循这个命名, 会跟具有语义化. 如同字面意思一样…git + keep, 让git保持这个文件夹, 是不是很简单易懂呀?创建文件“哥, 能发个’.gitkeep’给我蛮? 项目中的弄丢了..”“啊? 直接创建一个不就完啦?”“创建不了呀!!系统不准, 会报错提示必须输入文件名”“噢~是有这个限制的, 你用命令行吧”“搜了圈, 好像没有找到在windows创建的方法诶, ““? ? ?”没错, 上面这场景就是让我写这篇博客的主要起因…其实windows下环境创建.开头的文件只能通过命令行的方法, 而且方式也很简单. 只需要输入一行命令即可..1type NUL &gt; .gitkeep 这段代码的意思就是创建一个空文件重定向到名为.gitkeep的文件中. gitignore与gitkeep在脚手架构建的项目中, 你也总能在根目录看到名为.giitignore的文件, 那么它和gitkeep又有什么关联呢? 前文有提过, .gitkeep只是约定俗成的一个名称, 而.gitignore是一个特殊文件, 如果你有什么不想提交上去的东西, 如配置了表单密码的配置文件呀什么的, 你可以写进这个文件中, git会自动的忽略掉它. 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 总结其实像.gitignore带有其他特殊文件还有其他, 如.nojekyll来告诉Github关闭 GitHub Pages 的 Jekyll 相关功能等, 由于实际工作中用的烧, 这里不详谈, 放着让大家去挖掘吧~]]></content>
      <tags>
        <tag>cmd</tag>
        <tag>Githubg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中Axios报错Promise未定义及IE10报语法错误的解决方案]]></title>
    <url>%2Fblog%2F2017%2F12%2F15%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%ADAxios%E6%8A%A5%E9%94%99Pomise%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%8F%8AIE10%E6%8A%A5%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[关于IE11及以下版本无法使用Promise还有IE10下报错的问题Promise未定义 ?在使用Axios开发时, IE11及以下版本报错会报Promise未定义的错误. 这是因为axios本质上是封装了ES6语法的promise,而promise在IE上并不兼容.然而说到js兼容, 这时候我们又能联想到babel.. 没错, babel中有一个工具叫做babel-Polyfill, 它会仿效一个完整的ES2015+环境，并意图运行于一个应用中而不是一个库/工具. 其实食用的方式也很简单.我们将babel-polyfill装进我们项目依赖中. 这里值得注意的是, 安装的时候需要安装到dependency(生产依赖)中, 而不是devDependency(开发依赖)(tips.关于两者的区别, 我以前的文章有专门讲过, 感兴趣的可以看一下)1npm install --save babel-polyfill 首先在mian.js的顶部引入import &quot;babel-polyfill&quot;;确保能够最先加载, 随后我们在build目录下webpack.config.js修改配置, 将app使用babel-polyfill进行编译. 这时候我们再重新编译, 就会发现promise未定义的错误就以及消失了12345module.exports = &#123; entry: &#123; app: ["babel-polyfill", './src/main.js'] &#125;&#125; 你以为文章到这里就结束了吗…. 随即我们切换到IE10下进行测试. 你会发现, 又冒出了一个报错.. Emmm, 解决一个又来一个, 惊不惊喜意不意外? 语法错误当你在IE10下看到提示语法错误的时, 这时候你就得去检查检查package.json下 webpack-dev-server版本是否高于2.6.1. 出现这个报错主要是因为项目中使用了const等语法, 然而IE11以下并不认得ES6语法语法.这个问题只有在开发模式才会出现, 只要es6转码后，打包放到服务器上，就没有问题了. 如果你想在开发阶段在IE10下测试你的代码, 你可以选择降低版本到2.6.1上, 问题就解决了.]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>IE兼容性错误</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端所能做的SEO]]></title>
    <url>%2Fblog%2F2017%2F12%2F05%2F%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%89%80%E8%83%BD%E5%81%9A%E7%9A%84SEO%2F</url>
    <content type="text"><![CDATA[SEO, 就是搜索引擎优化(Search Engine Optimization)的缩写, SEO优化是专门利用搜索引擎的搜索规则来提高网站在搜索引擎内的自然排名的一种方式. 能对搜索引擎的小蜘蛛更加友好. 那么前端能做哪些SEO的优化呢?SEO基础三要素我们进入某个网页打开调试工具, 在&lt;head&gt;标签里我们能的看到&lt;title&gt;标签, keywords和description的&lt;meta&gt;标签. 就是最基础的SEO三要素.其中&lt;title&gt;标签代表着页面的标题, &lt;meta keywords&gt;是网站的关键字, &lt;meta Description&gt;则是网页的描述, 即对这些关联字进行了扩展.昂, 现在我们知道了这三要素可以SEO优化, 那我们就疯狂的在关键字里加一堆上去, 越多越好?当然, 并不是这样的.这些都有限制的, 内容不可过长, 也不能过分的堆砌关键字, 每个页面的description也应该不同. 比如下方张老师的博客为例.网站构造布局优化对网站布局进行SEO优化, 控制首页链接数量, 扁平化的目录层次(最多三层目录层次), 然后对导航SEO优化.编写语义化代码我们常说, 要养成编写语义化代码的习惯. 那什么是语义化呢? 就是既要人看得懂, 也要机器能理解你的代码.其实我们常用的HTML标签很多都是带语义化的. 如:H1 ~ H6都是用于表示标题UL标签多用于无序列表Ol标签用于有序列表DL标签用于定义数据列表Em, strong表示强调等站内优化&lt;a&gt; - 标签优化, 外链上加上rel=”nofollow”, 让小蜘蛛别往外面爬&lt;h1&gt; - 正文标题使用h1&lt;img&gt; - 标签使用alt说明, alt对图片起着一个注释的作用&lt;strong&gt;``&lt;em&gt;与&lt;b&gt;``&lt;i&gt;标签&lt;strong&gt;是权重标签的代表, 在搜索引擎中能够得到高度的重视, 他能突出关键词, &lt;b&gt;与&lt;strong&gt;的效果是一样的, 但是在SEO中并不会起到很好的效果, 因此不推荐使用.&lt;em&gt;表示斜体, 权重标签的重要度仅次于&lt;strong&gt;.一些布局小技巧重要内容HTML代码放在最前面, 小蜘蛛抓取HTML内容是按照文档流从上往下抓取的. 利用这个特点, 我们可以将重要的HTML放在上面, 然后可以通过CSS来进行布局.重要的内容尽量不要用JS输出, 小蜘蛛看不懂JavaScript~尽少使用iframe框架. 小蜘蛛是不会读取里面的网页的谨慎使用display: none; 小蜘蛛会过滤掉display: none里的内容不断的精简代码, 能使用一个标签就不要用两个标签扩展阅读Chrome - 搜索引擎优化 (SEO) 入门指南总结SEO其实面对的是搜索引擎, 然后搜索引擎再将搜索的结果, 根据权重展现给用户. 文中讲的只是一些基础的知识, 除此之外还有robots.txt, 站外友链等, 这里就不详谈了. 平时前端er日常工作中应该培养好的编程习惯, 了解了SEO的规则, 可以隐性给自己页面提升质量呢~]]></content>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 遍历绑定toggle icon, 动态切换action]]></title>
    <url>%2Fblog%2F2017%2F11%2F29%2FVue-v-for-%E9%81%8D%E5%8E%86%E7%BB%91%E5%AE%9Atoggle-icon-%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2action%2F</url>
    <content type="text"><![CDATA[在Vue中实现动态绑定toggle action在遍历li标签时, 动态绑定点击事件, 当点击其中一个item时调用函数. 函数内判断是否处于action状态, 是则清除class, 从实现toggle的效果~ 按照这个思路也可以扩展为下拉菜单.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, index) in itemList&quot; @click=&quot;openItem(index)&quot; :key=&quot;item.id&quot; &gt; &#123;&#123; item.desc &#125;&#125; &lt;span class=&quot;icon&quot; :class=&quot;&#123;&apos;action&apos;: actionItem === index&#125;&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; itemList: [ &#123;desc: &apos;item1&apos;&#125;, &#123;desc: &apos;item2&apos;&#125;, &#123;desc: &apos;item3&apos;&#125; ], actionItem: null &#125; &#125;, methods: &#123; openItem (index) &#123; if (this.actionItem === index) &#123; this.actionItem = null &#125; else &#123; this.actionItem = index &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.list &#123; width: 500px; padding: 0; margin: 0 auto; text-align: left;&#125;.list li &#123; position: relative; margin: 14px 0; padding: 10px; border-bottom: 1px solid #ccc; list-style: none; cursor: pointer;&#125;.list .icon &#123; position: absolute; right: 10px; width: 0; height: 0px; border: 10px solid; border-color: #aaa transparent transparent transparent;&#125;.list .action &#123; border-color: rgb(254,0,0); border-radius: 50%;&#125;&lt;/style&gt; 初次点击, action触发, 再次点击清除action]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm包中的 install --save 和 install --save-dev之间到底有区别]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2F%E8%B0%88%E8%B0%88npm%E5%8C%85%E9%87%8C%E7%9A%84%20install%20--save%20%E5%92%8C%20install%20--save-dev%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当我们使用npm进行开发时经常能遇到需要安装依赖包, 那么npm install --save和npm install --save-dev之间到底有什么区别呢? 现在来探究一番.install –save-dev实际上--save-dev是开发时候所依赖的东西，如我们想添加自动添加前缀, 那么就安装autoprefixer到开发依赖去. 也就是编译打包后autoprefixer已经帮我们添加了相应的浏览器前缀, 那么我们之后就不需要依赖他了. 所以1npm install babel --save-dev 在这里我们可以看到已经放进package.json中的devDependencies(开发依赖)中去了. install –save--save就是你发布之后还依赖的东西。 如果编译打包后还需要依赖的库, 如vue, 所以就放进了dependencies中(生产依赖). 两者需要安装的依赖其实都可以在package.json中手动输入相应的库和版本号, 然后使用npm install就能进行安装package.json中的所有依赖了~]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JavaScript删除全部的微博]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2F%E4%BD%BF%E7%94%A8JavaScript%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E7%9A%84%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[生活中常常会遇到一些繁琐重复而又没有意义的东西, 所以常有人说, 作为一个程序员, 应该避免做重复没意义的事, 我们学习编程最终的目的之一无非也是偷懒….. 能让自动的就坚决不手动. 当然, 除了在学习中自己造一些有意义的轮子除外. 今天就利用一些自己所学的知识去解决生活上的一些麻烦. 比如..自动删光微博黑历史~开始打开chrome浏览器(其他非IE现代浏览器都可以), 进入我的主页, 然后按下F12进入控制台.原理分析首先这次只是单纯的想通过JavaScript批量删除全部微博代替手动而已, 那么就简单了. 我们只需要模仿点击删除的动作.找到删除微博的key, 选中DOM元素, 这里我们可以看到菜单a标签中有一个属性action-type=&quot;fl_menu, 在控制台进使用document.querySelectorAll进行测试输出, 可以看到是一个NodeList的类数组, 分别对应着页面每一个fl_menu.点击menu弹出下拉菜单, 继续用同样的方法分析节点, 找出一个表示用于删除的属性. 一般来说, 一个合格的程序员都懂得编写语义化的代码, 这里先推测action-type=&quot;feed_list_delete这个属性是专属删除微博的属性, 使用document.querySelector将代码在控制台上测试输出. 获取到页面中第一个delete DOM, 模拟点击后弹出一个确定框, 再次使用相同的方法确定即可.代码实现一般网站都会限制用户频繁操作, 这里我们使用setTimeout, 测试一个weibo能够容忍的一个操作频率(可能还跟网速有关).12345678910111213141516171819202122232425window.onload = (function() &#123; // 经测试, 750ms是一个较快较稳定的频率, 效率过快会弹警告. var timer = setTimeout(Delete, 750); var item = 0; function Delete() &#123; /* 这里需要停止定时器等待加载, 请求XHR进行加载剩余微博. * 这里是微博的一个限制, 当页面中不存在相应的DOM, 就进行页面刷新. */ if (item &gt; 15) &#123; item = 0; clearTimeout(timer); return timer = setTimeout(Delete, 15000); &#125; // 模拟点击 document.querySelector('a[action-type="fl_menu"]').click(); document.querySelector('a[action-type="feed_list_delete"]').click(); document.querySelector('a[action-type="ok"]').click(); ++item; console.log(`已成功删除了$&#123;item&#125;项`); timer = setTimeout(Delete, 750); &#125;&#125;)(); 总结这样我们想要的效果就实现了.省去了一条一条删的人力, 又能运用到自己所学的知识. 其实代码代码也很简单, 无非是用到了setTimeout重复去递归调用而已. 要注意的是querySelector, 和querySelector都是IE9+的API, 在这里没有去考虑对IE的兼容, 并且也没有必要.]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript深入理解-裁剪图片效果(选取框)]]></title>
    <url>%2Fblog%2F2017%2F11%2F17%2FJavascript%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[在生活中我们时常能看到这种图片裁剪的效果, 那么他实际上底层的原理是怎么实现的呢? 让我们深入的解剖一下.原理分析首先我们先将视图一分为三, 理解为三个层级叠加在一起的仰视图.最上面是可拖动的选择窗口中间待剪辑的可视窗口底层是一张opacity: .5的背景图片基础结构我们这里主要讲JavaScript, HTML与css就简要的过一下.首先HTML基本结构是两张相同的结构, 两张图片分别是调整过透明度的底图和一张被裁剪过了的中间层.mainBox包裹着选择的小方块square,相对定位于image在最上面一层.123456789101112131415161718&lt;!-- index.html --&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image1"&gt; &lt;img src="images/Konachan.com - 239917 sample.jpg" alt="img" id="image2"&gt; &lt;div id="mainBox" class="main"&gt; &lt;div class="square left-up"&gt;&lt;/div&gt; &lt;div class="square up"&gt;&lt;/div&gt; &lt;div class="square right-up"&gt;&lt;/div&gt; &lt;div class="square right"&gt;&lt;/div&gt; &lt;div class="square right-down"&gt;&lt;/div&gt; &lt;div class="square down"&gt;&lt;/div&gt; &lt;div class="square left-down"&gt;&lt;/div&gt; &lt;div class="square left"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324/* main.css */body &#123;background: #333;&#125;#box &#123;position: absolute;top: 100px; left: 200px; width: 460px; height: 360px;&#125;#box img &#123;width: 460px;&#125;#box #image1 &#123;opacity: .5;position: absolute; top: 0;left: 0;&#125;#box #image2 &#123;position: absolute; top: 0;left: 0; clip: rect(0, 200px, 200px, 0) &#125;#box .main &#123;position: absolute;border: 1px solid #fff; width: 200px; height: 200px;box-sizing: border-box;&#125;#box .main .square &#123;position: absolute; width: 8px;height: 8px; background: #fff&#125;#box .main .left-up&#123;left: -4px;top: -4px;cursor: nw-resize;&#125;#box .main .up&#123;left: 50%;top: -4px;margin-left: -4px;cursor: n-resize&#125;#box .main .right-up&#123;right: -4px;top: -4px;cursor: ne-resize&#125;#box .main .right&#123;right: -4px;top: 50%;margin-top: -4px;cursor: e-resize&#125;#box .main .right-down&#123;right: -4px;bottom: -4px;cursor: se-resize&#125;#box .main .down&#123;left: 50%;bottom: -4px;margin-left: -4px;cursor: s-resize&#125;#box .main .left-down&#123;left: -4px;bottom: -4px;cursor: sw-resize&#125;#box .main .left&#123;top: 50%;left: -4px;margin-top: -4px;cursor: w-resize&#125;#box &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; JavaScript实现ESMAScript并没有提供可拖动的API, 那我们先来思考一下, 该如何实现拖动的功能~ 最上层有9个小方块(Square), 分别代表着不同方向的边界, 拖动这个边界, 无非需要实现这下面的底层步骤. 鼠标落下(MouseDown) =&gt; 鼠标拖动 =&gt; 松开鼠标(MouseUp). 先创建一个clipImage函数作为入口函数, 主要获取目标元素和生成DOM节点(后面讲), 绑定事件.先给小方块绑定一个鼠标落下事件(mousedown), 当触发事件(MouseEvent)时, 监听器调用onMousedown函数.onMousedown函数中, 接受四个参数e事件, box目标元素, ctrl小方块的方向, type属性, 主要是用来记录数据并暴露给全局变量进行通讯. 12345678910111213141516171819202122232425262728293031;(function() &#123; // Util工具函数 var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; // "全局变量", 记录状态 var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var right = util.$('#box .main .right'); // Add mouse down event up.addEventListener('mousedown', function(e) &#123; onMousedown(e, box, up, 'up'); &#125;); function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; // 将接受到的信息暴露出去. _MainBox = box; _MainCtrl = ctrl; _MainType = type; &#125;&#125;)(); 紧接着来计算拖动的距离, 在onMouseDown函数上将moving拖动标记设为1(true也行). 判断拖动的标记是否启动, 创建getPosition函数获取元素相对于页面左/上边的偏移量用于计算拖动的偏移量. 如下图. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//初始化var moving = 0;function onMousedown(e, box, ctrl, type) &#123; var e = e || window.event; _MainBox = box; _MainCtrl = ctrl; _MainType = type; // 移动计算偏移量并设置到box上 moving = 1;&#125;// 获取元素相对于文档的距离function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;;&#125;// 监听鼠标相对于页面的坐标document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var addWidth, addHeight; var width = _MainBox.offsetWidth; // 相对于屏幕左/上的距离 var boxX = getPosition(_MainBox).left; switch(_MainType) &#123; case "right": addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; break; &#125; &#125;&#125;; 紧接着我们会发现虽然实现了拖动的效果, 但是松开鼠标box宽度还是会随着鼠标变化. 这是因为还没有重置标记. 随即监听鼠标松开事件(MouseUp). 单边拖动就完成啦~12345// 鼠标松开document.onmouseup = function() &#123; // reset moving = 0;&#125;; 整理归纳我们将switch里的代码整理出来. 装进函数里去调用. 相续的将各个方向也加上, 原理也是同理. 值得注意的是将右面和下面要加上box的宽高才能计算出来. 剩下四个边角, 如左上什么的其实就是同时调用正方位的两个函数实现的实现起来. 然后拖动功能就大功告成啦~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215;(function() &#123; var util = &#123; $: function(dom) &#123; return document.querySelector(dom); &#125; &#125;; var _MainBox, _MainCtrl, _MainType; var moving = 0; clipImage('mainBox'); function clipImage(id) &#123; var boxMain = document.getElementById(id); var up = util.$('#box .main .up'); var down = util.$('#box .main .down'); var right = util.$('#box .main .right'); var rightUp = util.$('#box .main .right-up'); var rightDown = util.$('#box .main .right-down'); var left = util.$('#box .main .left'); var leftUp = util.$('#box .main .left-up'); var leftDown = util.$('#box .main .left-down'); // Add mouse down event right.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, right, 'right'); &#125;); up.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, up, 'up'); &#125;); down.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, down, 'down'); &#125;); left.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, left, 'left'); &#125;); leftUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftUp, 'leftUp'); &#125;); leftDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, leftDown, 'leftDown'); &#125;); rightUp.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightUp, 'rightUp'); &#125;); rightDown.addEventListener('mousedown', function(e) &#123; onMousedown(e, boxMain, rightDown, 'rightDown'); &#125;); &#125; /** * [onMousedown description] Mouse down event * @param &#123;[type]&#125; e [Event] * @param &#123;[type]&#125; box [target vessel] * @param &#123;[type]&#125; ctrl [Square DOM node] * @param &#123;[type]&#125; type [Square direction] */ function onMousedown(e, box, ctrl, type) &#123; _MainBox = box; _MainCtrl = ctrl; _MainType = type; moving = 1; &#125; // 获取元素相对于左边的距离 function getPosition(node) &#123; var left = node.offsetLeft; var top = node.offsetTop; var parent = node.offsetParent; while(parent) &#123; left += parent.offsetLeft; top += parent.offsetTop; parent = parent.offsetParent; &#125; return &#123; "left": left, "top": top&#125;; &#125; // 鼠标移动 document.onmousemove = function(e) &#123; if (moving) &#123; var e = e || window.event; // 父容器的宽高 var height = _MainBox.offsetHeight; // 相对于屏幕左/上的距离 var boxY = getPosition(_MainBox).top; switch(_MainType) &#123; case "right": right(e); break; case "up": up(e); break; case "down": down(e); break; case "left": left(e); break; case "leftUp": leftUp(e); break; case "leftDown": leftDown(e); break; case "rightUp": rightUp(e); break; case "rightDown": rightDown(e); break; &#125; &#125; &#125;; // 鼠标松开 document.onmouseup = function() &#123; moving = 0; &#125;; function right(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = e.clientX - boxX - width; _MainBox.style.width = width + addWidth + 'px'; &#125; function up(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; &#125; function down(e) &#123; var height = _MainBox.offsetHeight; var boxY = getPosition(_MainBox).top; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; &#125; function left(e) &#123; var width = _MainBox.offsetWidth; var boxX = getPosition(_MainBox).left; var addWidth = boxX - e.clientX; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = boxY - e.clientY; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function leftDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = boxX - e.clientX; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + 'px'; _MainBox.style.width = width + addWidth + 'px'; _MainBox.style.left = _MainBox.offsetLeft - addWidth + 'px'; &#125; function rightUp(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = boxY - e.clientY; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.top = _MainBox.offsetTop - addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125; function rightDown(e) &#123; var width = _MainBox.offsetWidth; var height = _MainBox.offsetHeight; var boxX = getPosition(_MainBox).left; var boxY = getPosition(_MainBox).top; var addWidth = e.clientX - boxX - width; var addHeight = e.clientY - boxY - height; _MainBox.style.height = height + addHeight + "px"; _MainBox.style.width = width + addWidth + "px"; &#125;&#125;)(); &lt;– 努力填坑中~ –&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【git】使用 sourcetree 实现远程仓库与本地仓库关联]]></title>
    <url>%2Fblog%2F2017%2F11%2F03%2Fuse-sourcetree-association%2F</url>
    <content type="text"><![CDATA[sourceTree 是当下比较流行的 git 客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率.今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联.步骤首先把本地仓库初始化.再添加到sourcetree上进入 Github -&gt; your profile -&gt; repositories(仓库) -&gt; New填写仓库信息, 复制仓库链接 设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定 然后就可以提交到github了~]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>sourcetree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Normalize与reset]]></title>
    <url>%2Fblog%2F2017%2F10%2F15%2F%E6%B5%85%E8%B0%88Normalize%E4%B8%8Ereset%2F</url>
    <content type="text"><![CDATA[前言: 在一次开发的时候, 发现团队中的小伙伴对normalize与reset都持有不同分歧. 趁着这事来谈谈, normalize与reset都有什么区别, 该如何取舍.resetreset, 顾名思义就是重置的意思. 最早的一份CSS reset来自Tantek的undohtml.css, Tantek根据自己的需要，对浏览器的默认样式进行了一些重置。早期的浏览器支持和理解的CSS规范不同，导致渲染页面时效果不一致，会出现很多兼容性问题, reset 的作用是让各个浏览器的CSS样式有一个统一的基准，而这个基准更多的就是“清零”.此后国内出现* {margin: 0, padding: 0}这种暴力清除全部样式的reset出现.normalizeNormalize, 从字面上也理解也就是使其正常化. 这是css reset的一个代替方案.Normalize相对「平和」, 注重通用的方案，重置掉该重置的样式，保留有用的user agent样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。创造normalize.css的目的主要是:保护有用的浏览器默认样式而不是完全去掉它们一般化的样式：为大部分HTML元素提供修复浏览器自身的bug并保证各浏览器的一致性优化CSS可用性：用一些小技巧解释代码：用注释和详细的文档来相比两者的利弊那么相对来说, 两者之间又有什么区别呢? 这里引用一下知乎用户的回答.CSS Reset 是革命党，CSS Reset 里最激进那一派提倡不管你小子有用没用，通通给我脱了那身衣服，凭什么你 body 出生就穿一圈 margin，凭什么你姓 h 的比别人吃得胖，凭什么你 ul 戴一胳膊珠子。于是 *{margin:0;} 等等运动，把人家全拍扁了。看似是众生平等了，实则是浪费了资源又占不到便宜，有求于人家的时候还得贱贱地给加回去，实在需要人家的默认样式了怎么办？人家锅都扔炉子里烧了，自己看着办吧Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理，简单粗暴地一视同仁是不好的。body 那一圈确实挤压了页面的生存空间，那就改掉。士农工商，谁有谁的作用，给他们制定个规范，确保他们在任何浏览器里都干好自己的活儿。然而在实际项目中, 为了还原设计图我们并不需要这种自带特性, 因此可以根据项目的需求将我们常用的标签进格式化, 但也不是跟传统的reset那样粗暴.因为传统的reset的很多清除默认样式是无意义的, 是浪费性能的. 就比如&lt;li&gt;, 人家生来就没有margin padding, 干嘛非要给人家加个margin: 0上去呀??? h1~h6标签虽然有margin没有padding呀! 也不要一棒子全打死啦! 其实这是不严谨的态度.以下的代码可以作为针对项目需求的进行调整. 这样看下去是不是舒服简洁多了呢? 也减少了很多无意义的性能损耗何乐而不为呢.1234567891011121314151617181920212223242526 body, dl, dd, h1, h2, h3, h4, h5, h6, p, form, ol, ul &#123; margin: 0;&#125;ol, ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none;&#125;body &#123; font: 14px/1.6 Monda,PingFang SC,Microsoft YaHei,sans-serif;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: block;&#125;.clearfix:after &#123; clear: both;&#125; 参考资料: Normalize.css 与传统的 CSS Reset 有哪些区别？normalize、reset与base关于CSS Reset 那些事（一）之 历史演变与Normalize.css]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速查正则表达式]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2Fjs-common-regexp%2F</url>
    <content type="text"><![CDATA[自己收集了一套针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效.tips: 善用Ctrl + F输入关键字能提高查询的效率哟~常见正则校验表单验证123456789101112131415161718192021222324// 用户名正则，4到16位（字母，数字，下划线，减号）var userNameReg = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/;// 必须拥有数字和特殊字符，并且在6 ~ 16位之间// (?=.*[0-9]) - 断言一个字符串至少有一个数字;// (?=.*[!@#$%^&amp;*]) - 断言一个字符串至少有一个特殊字符。var reg = /^(?=.*[0-9])(?=.*[!@#$%^&amp;*])[a-zA-Z0-9!@#$%^&amp;*]&#123;6,16&#125;$/;// 匹配邮箱地址var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// 中国六位数的邮政编码var postalCode = /^\d&#123;6&#125;$/;// 匹配15~18位身份证var IDCard = /(^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\d&#123;5&#125;\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;2&#125;$)/;// 匹配18位的新版身份证var IDCard_18 = /^[1-9]\d&#123;5&#125;(18|19|([23]\d))\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/;// 校验输入框是字符数为是否为 4~16 位(英文长度为1, 汉字长度为2)var numName = /^[a-zA-Z0-9]&#123;4,16&#125;$/;var mate = numName.test(value.replace(/[\u4e00-\u9fa5]/g, 'aa')); 网络相关1234567891011//ipv4地址正则var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;// Reg Hex颜色正则var pattern = /^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/;// URL正则var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/;// 匹配JSON格式var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ 匹配json字符串 12345678var ret = response.data;if (typeof ret === 'string') &#123; var reg = /^\w+\((&#123;[^()]+&#125;)\)$/ var matches = ret.match(reg); if (matches) ret = JSON.parse(matches[1]);&#125;res.json(ret); 联系方式1234567891011// 5-11位的腾讯qq号var qqReg = /^[1-9][0-9]&#123;4,11&#125;$/;// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]&#123;5,19&#125;)+$/;// 国内常见var phone = /^1[3|5|8|9]\d&#123;9&#125;$/;// 固定电话var telephone = /^(0[0-9]&#123;2&#125;)\d&#123;8&#125;$|^(0[0-9]&#123;3&#125;(\d&#123;7,8&#125;))$/; 匹配特定数字1234567891011121314151617181920212223242526272829// 匹配正整数var reg = /^[1-9]\d*$/;// 匹配负整数var reg = /^-[1-9]\d*$/;// 匹配整数var reg = /^-?[1-9]\d*$/;// 匹配非负整数（正整数 + 0）var reg = /^[1-9]\d*|0$/;// 匹配非正整数（负整数 + 0）var reg = /^-[1-9]\d*|0$/;// 匹配正浮点数var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;// 匹配负浮点数var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;// 匹配浮点数var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;// 匹配非负浮点数（正浮点数 + 0）var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;// 匹配非正浮点数（负浮点数 + 0）var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/; 字符串相关123456789101112131415161718192021222324// 匹配由26个英文字母组成的字符串var reg = /^[A-Za-z]+$/;// 匹配由26个英文字母的大写组成的字符串var reg = /^[A-Z]+$/;// 匹配由26个英文字母的小写组成的字符串var reg = /^[a-z]+$/;// 匹配由数字和26个英文字母组成的字符串var reg = /^[A-Za-z0-9]+$/;// 匹配由数字、26个英文字母或者下;划线组成的字符串var reg = /^\w+$/;// 匹配空白行的正则表达式var reg = /\n\s*\r/;// 匹配首尾空白字符的正则表达式var reg = /^\s*|\s*$/;var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)var reg = /[^\x00-\xff]/g; 匹配语系字符范围用法:/^[\u4E00-\u9FA5]+$/(匹配简体中文) 2E80～33FFh：中日韩符号区。收容康熙字典部首、中日韩辅助部首、注音符号、日本假名、韩文音符，中日韩的符号、标点、带圈或带括符文数字、月份，以及日本的假名组合、单位、年号、月份、日期、时间等。 3400～4DFFh：中日韩认同表意文字扩充A区，总计收容6,582个中日韩汉字。 4E00～9FFFh：中日韩认同表意文字区，总计收容20,902个中日韩汉字。 A000～A4FFh：彝族文字区，收容中国南方彝族文字和字根。 AC00～D7FFh：韩文拼音组合字区，收容以韩文音符拼成的文字。 F900～FAFFh：中日韩兼容表意文字区，总计收容302个中日韩汉字。 FB00～FFFDh：文字表现形式区，收容组合拉丁文字、希伯来文、阿拉伯文、中日韩直式标点、小符号、半角符号、全角符号等。 正则函数使用示例replace1234// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.function getLen(str) &#123; return str.replace(/[^\x00-\xff]/g, 'xx').length;&#125; test123456789// 匹配是否符合邮件规则var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;// test返回一个布尔值, 表示是否匹配到制定字符串var mail = reg.test('anran758@gmail.com')if (mail) &#123; // 如果邮件格式正确的话, 就可以做点啥了(雾&#125; 正则技巧反向引用1234// 比如这里我们想让这个日期格式反转// 正则括号是一个分组, 下面的代码就捕获了三个分组// 通过$分组符来转换位置, 来达到我们想要的结果'2018-3-21'.replace(/(\d&#123;4&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/g, '$2/$3/$1') // "3/21/2018" 忽略分組不希望捕获某些分组, 只需要分组内加上?:即可: 12var reg = /(?:Byron).(ok)/;'Byron-ok'.replace(reg, '$1'); // 只匹配了 ok 前瞻 名字 正則 正向前瞻 exp(?=assert) 负向前瞻 exp(?!assert) 正向前瞻就是匹配前者, 效验后者是否存在. 1234567// 这个正则的意思是: 匹配一个单词字符( [a-zA-Z0-9_] ), 然后验证后面是不是数字// 结果为: "X2*3". 因为3后面没有数字, 所以没有匹配到.'a2*3'.replace(/\w(?=\d)/g, 'X')// 结果为: "X2*X4X8"// 总的说就是'a2*34v8'.replace(/\w(?=\d)/g, 'X') 负向前瞻则相反, 匹配前面, 替代后面 123456789// a 是单词字符, 后面是数字, 因此没有匹配到// 2 是单词字符, 后面不是数字, 被替换成X// * 不是单词字符 因此没有匹配到// 3 是单词字符, 后面是数字, 因此没有匹配到// 4 是单词字符, 后面不是数字, 被替换成X// v 是单词字符, 后面是数字, 因此没有匹配到// 8 是单词字符, 后面没有匹配到数字, 被替换成X// 结果: aX*4XvX'a2*34v8'.replace(/\w(?!\d)/g, 'X') 可视化正则表达式, 可以试试regexper, 让你看懂正则匹配的走向. 以后的更新与维护都将在 Front-End-Lab/REGEXP 中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【js】数组方法深入研究与练习]]></title>
    <url>%2Fblog%2F2017%2F07%2F16%2Farray-method-test%2F</url>
    <content type="text"><![CDATA[数组是js中最常见的一种数据类型，善用正确数组的方法可以编写出良好结构的代码。目录目录回文处理首个单词字母大写返回数组最大的数字检查字符串结尾重复输出字符串截断字符串分割数组过滤数组假值摧毁指定数组数组排序并找出元素索引凯撒密码Sum All Numbers in a Range非数组方法回文处理Palindromes(回文)，顾名思义就是指倒着念和顺着念都是相同、前后对称的。处理这种回文我们只需将字符串反转再进行对比，就可以得到结果啦：12345678910function palindrome(str) &#123; var string = str.replace(/[\W_]/g, '').toLowerCase(); var replaceStr = string .split('') .reverse() .join(''); return replaceStr === string;&#125;palindrome('eye'); // true 首个单词字母大写 Title Case a Sentence(首个单词字母大写) 句中单词首字母大写, 确保字符串的每个单词首字母都大写，其余部分小写。 1234567function titleCase(str) &#123; return str.toLowerCase().replace(/( |^)[a-z]/g, function(L) &#123; return L.toUpperCase(); &#125;);&#125;titleCase("I'm a little tea pot"); // I'm A Little Tea Pot 思路 首先把字符串转换为小写,再用正则匹配带空格或者就字母开头的首个字母replace替换成大写字母. 返回数组最大的数字 Return Largest Numbers in Arrays(返回数组最大的数字) 找出多个数组中的最大数,并返回一个新数组 123456789101112131415161718function largestOfFour(arr) &#123; // 请把你的代码写在这里 var count = []; for (var i = 0; i &lt; arr.length; i++) &#123; var a = arr[i].sort(function(a, b) &#123; return b - a; &#125;); count.push(a[0]); &#125; return count;&#125;largestOfFour([ [4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); // [5,27,39,1001] 思路 新定义一个数组,遍历传进来的数组进行从大到小排序,将排序后最大的数push进新的数组count最后再返回. 检查字符串结尾 Confirm the Ending(检查字符串结尾) 检查字符串结尾,判断一个字符串(str)是否以指定的字符串(target)结尾, 返回一个布尔值。 12345678function confirmEnding(str, target) &#123; var lenth = str.length - target.length; return str.substr(lenth) === target&#125;confirmEnding('Connor', 'n'); // falseconfirmEnding('Bastian', 'n'); // trueconfirmEnding('He has to give me a new name', 'me'); // true 思路 substr()接受一个start的形参，是一个字符的索引，把字符串str.length - target.length就可以对比结尾字符串是否一样了. 重复输出字符串 Repeat a string repeat a string(重复输出字符串，复读机(雾) 重复一个指定的字符串num次，如果num是一个负数则返回一个空字符串。 对于这种题目可以使用两种方法解决: 递归 12345678910111213// 第一种使用递归function repeat(str, num) &#123; // 请把你的代码写在这里 if (num &lt; 0) &#123; return ''; &#125; else if (num === 1) &#123; return str; &#125; else &#123; return str + repeat(str, num - 1); &#125;&#125;repeat('abc', 3); // "abcabcabc" while 12345678910function repeat(str, num) &#123; var s = ''; while (num &gt; 0) &#123; s += str; num--; &#125; return s;&#125;repeat('abc', 3); 思路 递归一般放进if()判断语句中,是一种通过重复地调用函数本身,逐次减少 num 的值来实现效果.第二种使用了while语句,每调用一次就递减 1,直至num &gt; 0. 截断字符串 Truncate a string(截断字符串) 截断字符串,如果字符串的长度比指定的参数 num 长，则把多余的部分用…来表示。插入到字符串尾部的三个点号也会计入字符串的长度。如果指定的参数 num 小于或等于 3，则添加的三个点号不会计入字符串的长度。 12345678910111213141516function truncate(str, num) &#123; // 首先判断num的值是不是大于字符串的长度,若是,那就没有必要省略了. if (num &gt;= str.length) &#123; return str; &#125; if (num &lt;= 3) &#123; return str.slice(0, num) + '...'; &#125; return str.slice(0, num - 3) + '...';&#125;var str = 'A-tisket a-tasket A green and yellow basket';truncate(str, str.length); 分割数组 Chunky Monkey(分割数组) 猴子吃香蕉, 分割数组,把一个数组 arr 按照指定的数组大小size分割成若干个数组块。例如: 12hunk([1,2,3,4],2) =&gt; [[1,2],[3,4]];chunk([1,2,3,4,5],2) =&gt; [[1,2],[3,4],[5]]; 思路 这道题重点主要是每size个值分割一个数组,这里我们可以使用以下几种方法来解题. while + splice 1234567891011121314151617181920// while + splicefunction chunk(arr, size) &#123; // 定义一个新数组和用来临时存放分割的空数组. var a = []; var t = []; var i = 0; // 需要保持快照 var len = arr.length; while (i &lt; len) &#123; t = arr.splice(0, size); a.push(t); i += size; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); for + slice 123456789101112131415161718192021// for + splicefunction chunk(arr, size) &#123; var a = [], t = [], len = arr.length; // 数组中的个数小于size或者size是小于等于0的也就没有必要分割了 if (len &lt;= size || size &lt;= 0) &#123; return arr; &#125; else &#123; // 它的重点主要是数组中的值的数量 for (var i = 0; i &lt; len; i += size) &#123; // 查询指定数 t = arr.slice(i, i + size); a.push(t); &#125; &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); while + slice 12345678910111213141516// while + slicefunction chunk(arr, size) &#123; var a = [], t = [], i = 0, len = arr.length; while (i &lt; len) &#123; // 查询的值 t = arr.slice(i, (i += size)); a.push(t); &#125; return a;&#125;chunk([0, 1, 2, 3, 4, 5], 3); 过滤数组假值 Falsy Bouncer(过滤数组假值) 删除数组中的所有假值。在 JavaScript 中，假值有 false、null、0、&quot;&quot;、undefined和NaN。 这道题比较有意思.. 一开始我走进了一个误区，想着单纯return x !== false &amp;&amp; ...这样简单的返回就可以了，后来发现在处理NaN时会很麻烦..isNaN()还会把英文字符串也给过滤掉,再加上多个&amp;&amp;使得代码会变得繁乱,可读性不高. 然后查阅了一番资料后,才注意到平时被忽略Boolean()的一些特性对于处理这种类型的问题简直不能太合适. 12345678910function bouncer(arr) &#123; // 请把你的代码写在这里 var a = arr.filter(function(x) &#123; return Boolean(x); &#125;); return a;&#125;bouncer([7, 'ate', '', false, 9]); 摘至MDN.Boolean 的描述: 如果 Boolean 构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的 Boolean 对象的值为 false. 其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为 true 的 Boolean 对象. 摧毁指定数组Seek and Destroy (摧毁指定数组) 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 实现原理 filter() 为数组中的每个元素调用一次 callback函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组.filter()从头至尾遍历数组,若回调函数返回的是 true(通过测试),就存入新数组中.若返回的是 false,则过滤掉. 12345678910111213141516function destroyer(arr) &#123; // 先将第一个参数隔开,定义一个储存着待移除的空数组 var args = arguments[0], removeArgs = []; // 要被删除的参数装进'removeArgs'里 for (var i = 1; i &lt; arguments.length; i++) &#123; removeArgs.push(arguments[i]); &#125; // 遍历'args',若'removeArgs'中不存在'value',应该返回-1.反之返回false被过滤掉. return args.filter(function(value) &#123; return removeArgs.indexOf(value) === -1; &#125;);&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); 数组排序并找出元素索引 Where do I belong (数组排序并找出元素索引) 先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 举例：where([1,2,3,4], 1.5) 应该返回 1。因为 1.5 插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而 1.5 对应的索引值就是 1。 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19 插入到数组[3,5,20]后变成[3,5,19,20]，而 19 对应的索引值就是 2。 思路 这个没啥好说的了..将第二个参数push进数组中,再进行排序.排序后通过indexOf()来实现功能.不过需要注意的是sort默认是按照’Unicode’编码进行排序的. 凯撒密码 Caesars Cipher (凯撒密码) 风靡全球的凯撒密码 Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。 一个常见的案例就是 ROT13 密码，字母会移位 13 个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。 写一个 ROT13 函数，实现输入加密字符串，输出解密字符串。所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 思路 本次练习用到String.charCodeAt()和String.fromCharCode(),首先来查询字符串的 Unicode 字符. 根据Unicode表我们得知: &lt; 65同时&gt; 90对应的就是数字和小写字符a-z &gt;= 65和&lt;= 77对应的就是大写字符A-M(13 位) &gt;= 78和&lt;= 90 对应的就是大写字符N-Z ROT13 的功能就是移位,如果序号小于 78(A-M 字母)，使用 String.fromCharCode()转换成该序号加 13 的字符,反之减 13. 123456789101112131415161718192021222324function rot13(str) &#123; // LBH QVQ VG! var newStr = []; for (var i = 0; i &lt; str.length; i++) &#123; // 查询每个字符串的Unicode编号 var temp = str.charCodeAt(i); // 非大写字母,空格,数字等都不转换 if (temp &lt; 65 || temp &gt; 91) &#123; newStr.push(str.charAt(i)); continue; // 大于77(N-Z),就转换成该序号 - 13的字符串. &#125; else if (temp &gt; 77) &#123; newStr.push(String.fromCharCode(temp - 13)); // 小于78(A-M),就转换成该序号 + 13的字符串 &#125; else &#123; newStr.push(String.fromCharCode(temp + 13)); &#125; &#125; return newStr.join('');&#125;rot13('SERR PBQR PNZC'); // 你可以修改这一行来测试你的代码 Sum All Numbers in a Range 题目描述 &emsp;&emsp;传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。最小的数字并非总在最前面。比如传递[1, 4]会返回10, 即1 + 2 + 3 + 4. 非数组方法1234567891011121314 function sumAll(arr) &#123; var max = Math.max.apply(null, arr); var min = Math.min.apply(null,arr); var num = max - min; var total = min; while(num) &#123; num--; total += ++min; &#125; return total;&#125;sumAll([1, 1]);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>ffc</tag>
      </tags>
  </entry>
</search>
