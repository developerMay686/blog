<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>usake - 实验台</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-10T14:55:36.029Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Anron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VSCode: 从零开始配置前端环境</title>
    <link href="http://yoursite.com/2018/02/06/VSCode-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/02/06/VSCode-从零开始配置前端环境/</id>
    <published>2018-02-06T13:41:18.000Z</published>
    <updated>2018-02-10T14:55:36.029Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/banner.png"><p>我们在进行开发工作时，选择一个顺手好用的IDE是必不可免的, 其中vscode就是一个很好的选择. 它能让你大部分的工作都在编辑器内完成, 大大的提高开发效率~ 本文将会从零开始搭建一个基础的前端开发环境.</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>vscode有着自己的插件商城, 并且有成熟良好的生态圈, 足够满足我们日常开发的所需的东西. 同时vscode提供了很多便捷的自定义配置，还很贴心的给每行设置都加上了备注.</p><p>除此之外，vscode对中文的支持也挺好，对于啃英语有些吃力的同学会比较友善(虽然作为一个程序员, 英语的学习也很重要呀~).</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/img-1.jpg"><p>另外vscode内置git管理系统, 也就是说我们在写完代码后无需再另开一个bash来提交代码, 直接编辑器上完成审阅代码差异, 提交代码这些工作. 还可以直接在编辑器上进行代码调试, 不过这些不在本文的讨论中.</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=azemoh.one-monokai" target="_blank" rel="noopener">One Monokai Theme</a></p><p>我们每天在跟编辑器打交道, 因此编辑器的颜值也是很重要的~ 在扩展商城里, 我们可以去挑选一些自己喜欢的主题, 让我们在coding时变得更加舒服. 目前笔者使用的<code>One Monokai</code>, 它的一些配色和主题个人还是蛮喜欢的. 同学们也可以去尝试其他的主题~</p><p>但值得注意的是, 下载主题后还需要<code>用户设置</code>上设置使用的主题.</p><h2 id="扩展插件"><a href="#扩展插件" class="headerlink" title="扩展插件"></a>扩展插件</h2><p>善用插件的力量能很大的提升我们的开发效率. 下面是一些自己常用插件跟大家分享一下.</p><p><strong>其他编辑器的快捷键</strong><br>如果你觉得换一个编辑器又要重新设置自己熟悉的快捷键(或者说记住vscode本身的快捷键)很麻烦的话, 没关系~ vscode为你准备了其他编辑器快捷键插件, 节省你宝贵的时间成本. 笔者曾经也是从 sublime 无障碍转向 vscode 从此一去不复返~</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/img.png"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=coderfee.open-html-in-browser" target="_blank" rel="noopener">Open-In-Browser</a></strong><br>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项. 在windows下, 可以使用快捷键<code>Alt + b</code>快速的打开.</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-1.gif"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek" target="_blank" rel="noopener">CSS Peek</a></strong><br>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-2.gif"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier</a></strong><br>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-3.gif"><p><em><a href="https://marketplace.visualstudio.com/items?itemName=cssho.vscode-svgviewer" target="_blank" rel="noopener">SVG Viewer</a></em><br>前端开发中, 无可避免会遇到查看svg的地方, 这时这个插件就能配上了用场.</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-4.gif"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=HookyQR.minify" target="_blank" rel="noopener">Minify</a></strong><br>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min文件的选项。它能够分别通过 uglify-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-5.gif"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="noopener">Auto Close Tag</a></strong><br>这个扩展是为XML，PHP，Vue，JavaScript，TypeScript，JSX，TSX等其他语言启用的。同时它是可配置的。输入标签的右括号后，结束标签将被自动插入。</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-6.gif"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a></strong><br>自动重命名配对的<code>HTML / XML</code>标记, 这在修改标签名上一点挺便捷的.</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-7.gif"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets" target="_blank" rel="noopener">JavaScript (ES6) code snippets</a></strong><br>es6已经是经常运用在我们的项目中了, 该扩展包含用于 Vscode 编辑器的ES6语法的JavaScript代码片段.（同时支持JavaScript和TypeScript）。</p><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint</a></strong><br>嘿, 要养成一个良好的编程习惯, ESLint就是一个不错的选择. 它会根据某种风格来纠正你的不好的习惯. 值得注意的是, 使用的话需要在全局安装有<code>ESlint</code></p><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig" target="_blank" rel="noopener">EditorConfig</a></strong><br>Editor Config 可以让你团队开发时统一约定好一种规范. 这个主流的编辑器都支持.</p><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank" rel="noopener">Vetur</a></strong><br>格式化, 格式化<code>.vue</code>文件, 官方维护.</p><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets" target="_blank" rel="noopener">Vue 2 Snippets</a></strong><br>这个插件基于最新的<code>Vue</code>官方语法高亮文件添加了Syntax Highlight<code>, 并且依据</code>Vue 2<code>的 API 添加了</code>Code Snippets`. 挺不错的一个扩展.</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/img-3.png"><p><strong><a href="https://marketplace.visualstudio.com/items?itemName=sysoev.language-stylus" target="_blank" rel="noopener">language-stylus</a></strong></p><p>stylus语法高亮, 还有其他的预处理器的插件这里不展开讲.</p><img src="/blog/2018/02/06/VSCode-从零开始配置前端环境/anima-8.gif"><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><p>分享一下自己目前的配置, 可以根据项目所需或者自己的习惯进行调整.</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    "workbench.colorTheme": "One Monokai",</div><div class="line">    "sublimeTextKeymap.promptV3Features": true,</div><div class="line">    // 编辑器</div><div class="line">    "editor.multiCursorModifier": "ctrlCmd",</div><div class="line">    "editor.snippetSuggestions": "top",</div><div class="line">    "editor.renderWhitespace": "all",</div><div class="line">    "editor.formatOnPaste": true,</div><div class="line">    "editor.wordWrap": "on",</div><div class="line">    "editor.fontSize": 12,</div><div class="line">    "editor.tabSize": 2,</div><div class="line">    // 文件资源管理</div><div class="line">    "explorer.confirmDragAndDrop": false,</div><div class="line">    "explorer.confirmDelete": false,</div><div class="line">    // 终端</div><div class="line">    "terminal.integrated.cursorBlinking": true,</div><div class="line">    "terminal.integrated.cursorStyle": "line",</div><div class="line">    "emmet.includeLanguages": &#123;</div><div class="line">        "vue-html": "html"</div><div class="line">    &#125;,</div><div class="line">    // 文件</div><div class="line">    "files.eol": "\n",</div><div class="line">    "files.associations": &#123;</div><div class="line">        "*.vue": "vue"</div><div class="line">    &#125;,</div><div class="line">    // 窗口</div><div class="line">    "window.zoomLevel": 1,</div><div class="line">    // 使用 vscode-typescript 来整理代码</div><div class="line">    "vetur.format.defaultFormatter.js": "vscode-typescript",</div><div class="line">    "vetur.format.defaultFormatter.ts": "vscode-typescript",</div><div class="line">    "javascript.format.insertSpaceBeforeFunctionParenthesis": true,</div><div class="line">    // 可能是让 CPU 炸了的罪魁祸首</div><div class="line">    "search.followSymlinks": false,</div><div class="line">    "html.format.extraLiners": ""</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上促使自己写这篇文章的源头, 仅仅是因为某个不可抗拒的因素, 导致系统重装.. 重装环境简直让人绝望呀~ 因此借着这个机会基础一下, 如果有遗漏哪个部分, 后来还会继续加进来吧~</p><p><strong>参考链接</strong><br><a href="https://zhuanlan.zhihu.com/p/27905838" target="_blank" rel="noopener">精选！15 个必备的 VSCode 插件（前端类）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/02/06/VSCode-从零开始配置前端环境/banner.png&quot;&gt;&lt;p&gt;我们在进行开发工作时，选择一个顺手好用的IDE是必不可免的, 其中vscode就是一个很好的选择. 它能让你大部分的工作都在编辑器内完成, 大大的提高开发效率~ 本文将会从零开始搭建一个基础的前端开发环境.&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="vscode" scheme="http://yoursite.com/tags/vscode/"/>
    
      <category term="环境配置" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>数组方法深入研究之三 (基础算法)</title>
    <link href="http://yoursite.com/2018/02/06/Basic%20Algorithm%20Scripting%20-%203/"/>
    <id>http://yoursite.com/2018/02/06/Basic Algorithm Scripting - 3/</id>
    <published>2018-02-06T07:40:58.530Z</published>
    <updated>2018-01-08T08:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/02/06/Basic%20Algorithm%20Scripting%20-%203/code.jpg"><p>今天让继续来学习数组方法的用法~</p><a id="more"></a><h2 id="Sum-All-Numbers-in-a-Range"><a href="#Sum-All-Numbers-in-a-Range" class="headerlink" title="Sum All Numbers in a Range"></a>Sum All Numbers in a Range</h2><blockquote><p>题目描述</p></blockquote><p>&emsp;&emsp;传递给一个包含两个数字的数组。返回这两个数字和<strong>它们之间所有数字的和</strong>。最小的数字并非总在最前面。<br>比如传递<code>[1, 4]</code>会返回<code>10</code>, 即<code>1 + 2 + 3 + 4</code>.</p><h3 id="非数组方法"><a href="#非数组方法" class="headerlink" title="非数组方法"></a>非数组方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</div><div class="line">  <span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,arr);</div><div class="line">  <span class="keyword">var</span> num = max - min;</div><div class="line">  <span class="keyword">var</span> total = min;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(num) &#123;</div><div class="line">    num--;</div><div class="line">    total += ++min;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> total;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sumAll([<span class="number">1</span>, <span class="number">1</span>]);</div></pre></td></tr></table></figure><p><strong>&lt;– 未待续~ 有空再深挖 –&gt;</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/02/06/Basic%20Algorithm%20Scripting%20-%203/code.jpg&quot;&gt;&lt;p&gt;今天让继续来学习数组方法的用法~&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ffc" scheme="http://yoursite.com/tags/ffc/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组方法深入研究之一 (基础算法)</title>
    <link href="http://yoursite.com/2018/02/06/Basic%20Algorithm%20Scripting%20-%201/"/>
    <id>http://yoursite.com/2018/02/06/Basic Algorithm Scripting - 1/</id>
    <published>2018-02-06T07:40:58.341Z</published>
    <updated>2017-11-14T01:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e48206bbgy1flhd6wd575j21040o3tb8.jpg" alt="coding"></p><blockquote><p>一些基础的算法练习</p></blockquote><a id="more"></a><h2 id="Palindromes-回文处理"><a href="#Palindromes-回文处理" class="headerlink" title="Palindromes(回文处理)"></a>Palindromes(回文处理)</h2><p>Palindromes称之为回文。在中文文当中是指倒着念和顺着念都是相同的，前后对称.</p><ul><li>正则表达式</li><li>replace()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> string = str.replace(<span class="regexp">/[\W_]/g</span>,<span class="string">''</span>).toLowerCase();</div><div class="line">  <span class="keyword">var</span> replaceStr = string.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</div><div class="line">  <span class="keyword">return</span> replaceStr === string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">palindrome(<span class="string">"eye"</span>);    <span class="comment">// true</span></div></pre></td></tr></table></figure><blockquote><p>思路</p></blockquote><p>&#8195;首先对字符串进行处理..去掉字符串多余的标点符号和空格，然后把字符串转化成小写.<br>&#8195;<code>split</code>把字符串拆分为一个字符串组成的数组.<code>reverse</code>反转数组顺序,<code>join</code>拼接字符串.</p><h2 id="Title-Case-a-Sentence-首个单词字母大写"><a href="#Title-Case-a-Sentence-首个单词字母大写" class="headerlink" title="Title Case a Sentence(首个单词字母大写)"></a>Title Case a Sentence(首个单词字母大写)</h2><p>句中单词首字母大写,确保字符串的每个单词首字母都大写，其余部分小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/( |^)[a-z]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">L</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> L.toUpperCase();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">titleCase(<span class="string">"I'm a little tea pot"</span>);    <span class="comment">// I'm A Little Tea Pot</span></div></pre></td></tr></table></figure><blockquote><p>思路</p></blockquote><p>&#8195;首先把字符串转换为小写,再用正则匹配带空格或者就字母开头的首个字母<code>replace</code>替换成大写字母.</p><h2 id="Return-Largest-Numbers-in-Arrays-返回数组最大的数字"><a href="#Return-Largest-Numbers-in-Arrays-返回数组最大的数字" class="headerlink" title="Return Largest Numbers in Arrays(返回数组最大的数字)"></a>Return Largest Numbers in Arrays(返回数组最大的数字)</h2><p>找出多个数组中的最大数,并返回一个新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestOfFour</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="comment">// 请把你的代码写在这里</span></div><div class="line">  <span class="keyword">var</span> count = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</div><div class="line">      <span class="keyword">var</span> a = arr[i].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> b-a;</div><div class="line">      &#125;);</div><div class="line">      count.push(a[<span class="number">0</span>]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">largestOfFour([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">13</span>, <span class="number">27</span>, <span class="number">18</span>, <span class="number">26</span>], [<span class="number">32</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">39</span>], [<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">857</span>, <span class="number">1</span>]]);    <span class="comment">// [5,27,39,1001]</span></div></pre></td></tr></table></figure><blockquote><p>思路</p></blockquote><p>&#8195;新定义一个数组,遍历传进来的数组进行从大到小排序,将排序后最大的数<code>push</code>进新的数组<code>count</code>最后再返回.</p><h2 id="Confirm-the-Ending-检查字符串结尾"><a href="#Confirm-the-Ending-检查字符串结尾" class="headerlink" title="Confirm the Ending(检查字符串结尾)"></a>Confirm the Ending(检查字符串结尾)</h2><p>检查字符串结尾,判断一个字符串(str)是否以指定的字符串(target)结尾。<br>如果是，返回true;如果不是，返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmEnding</span>(<span class="params">str, target</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> l = str.length - target.length;</div><div class="line">  <span class="keyword">if</span> (str.substr(l) === target) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">confirmEnding(<span class="string">"Connor"</span>, <span class="string">"n"</span>);                         <span class="comment">// false</span></div><div class="line">confirmEnding(<span class="string">"Bastian"</span>, <span class="string">"n"</span>);                        <span class="comment">// true</span></div><div class="line">confirmEnding(<span class="string">"He has to give me a new name"</span>, <span class="string">"me"</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure><blockquote><p>思路</p></blockquote><p>&#8195;乍一看好像挺麻烦的样子,容我们深入一看却发现好像并没有想象中的麻烦..<br>&#8195;这里用上了<code>String.prototype.substr()</code>而参数start是一个字符的索引,把字符串<code>str.length - target.length</code>就可以对比结尾字符串是否一样了.</p><h2 id="Repeat-a-string-repeat-a-string-重复输出字符串"><a href="#Repeat-a-string-repeat-a-string-重复输出字符串" class="headerlink" title="Repeat a string repeat a string(重复输出字符串)"></a>Repeat a string repeat a string(重复输出字符串)</h2><p>重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。</p><p>&#8195;对于这种题目可以使用两种方法解决:</p><ul><li>递归</li><li>while循环</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种使用递归</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">str, num</span>) </span>&#123;</div><div class="line">  <span class="comment">// 请把你的代码写在这里</span></div><div class="line">  <span class="keyword">if</span> (num &lt; <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> str;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> str + repeat(str, num - <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">repeat(<span class="string">"abc"</span>, <span class="number">3</span>);   <span class="comment">// "abcabcabc"</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第二种使用while</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">str, num</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="string">''</span>;</div><div class="line">  <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</div><div class="line">    s += str;</div><div class="line">    num --;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">repeat(<span class="string">"abc"</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure><blockquote><p>思路</p></blockquote><p>&#8195;递归一般放进<code>if()</code>判断语句中,是一种通过重复地调用函数本身,逐次减少num的值来实现效果.<br>第二种使用了<code>while</code>语句,每调用一次就递减1,直至<code>num &gt; 0</code>.</p><p>Truncate a string(截断字符串)<br>截断字符串,如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。<br>插入到字符串尾部的三个点号也会计入字符串的长度。如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">str, num</span>) </span>&#123;</div><div class="line">  <span class="comment">// 首先判断num的值是不是大于字符串的长度,若是,那就没有必要省略了.</span></div><div class="line">  <span class="keyword">if</span>(num &gt;= str.length) &#123;</div><div class="line">    <span class="keyword">return</span> str;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= <span class="number">3</span>) &#123;</div><div class="line">    <span class="keyword">return</span> str.slice(<span class="number">0</span>,num) + <span class="string">"..."</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> str.slice(<span class="number">0</span>,num<span class="number">-3</span>) + <span class="string">"..."</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">truncate(<span class="string">"A-tisket a-tasket A green and yellow basket"</span>, <span class="string">"A-tisket a-tasket A green and yellow basket"</span>.length);</div></pre></td></tr></table></figure><blockquote><p>思路</p></blockquote><p>&#8195;slice截取字符串.substr(),indexOf()和lastIndexOf()办法同理.<br><a href="https://www.w3cplus.com/javascript/confirm-the-ending.html" target="_blank" rel="noopener">https://www.w3cplus.com/javascript/confirm-the-ending.html</a> 大漠老师有一篇文章对此使用有着更详细的说明.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e48206bbgy1flhd6wd575j21040o3tb8.jpg&quot; alt=&quot;coding&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一些基础的算法练习&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ffc" scheme="http://yoursite.com/tags/ffc/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>数组方法深入研究之二 (基础算法)</title>
    <link href="http://yoursite.com/2018/02/06/Basic%20Algorithm%20Scripting%20-%202/"/>
    <id>http://yoursite.com/2018/02/06/Basic Algorithm Scripting - 2/</id>
    <published>2018-02-06T07:40:57.638Z</published>
    <updated>2017-11-14T01:48:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/e48206bbgy1flhd8j2b8xj21uo18g49f.jpg" alt="coding"></p><blockquote><p>数组方法的深入学习</p></blockquote><a id="more"></a><h2 id="Chunky-Monkey-分割数组"><a href="#Chunky-Monkey-分割数组" class="headerlink" title="Chunky Monkey(分割数组)"></a>Chunky Monkey(分割数组)</h2><p>猴子吃香蕉, 分割数组,把一个数组arr按照指定的数组大小<code>size</code>分割成若干个数组块。<br>例如:<br>&#8195;&#8195;hunk([1,2,3,4],2) =&gt; [[1,2],[3,4]];<br>&#8195;&#8195;chunk([1,2,3,4,5],2) =&gt; [[1,2],[3,4],[5]];</p><blockquote><p>思路</p></blockquote><p>&#8195;这道题重点主要是每<code>size</code>个值分割一个数组,这里我们可以使用以下几种方法来解题.</p><ol><li>while + splice</li><li>for + slice</li><li>while + slice</li></ol><p>第一种<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// while + splice</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">arr, size</span>) </span>&#123;</div><div class="line">  <span class="comment">// 定义一个新数组和用来临时存放分割的空数组.</span></div><div class="line">  <span class="keyword">var</span> a = [], t = [], i = <span class="number">0</span>,</div><div class="line">      len = arr.length;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (i &lt; len)&#123;</div><div class="line">    t = arr.splice(<span class="number">0</span>, size);</div><div class="line">    a.push(t);</div><div class="line">    i += size;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>);</div></pre></td></tr></table></figure><p></p><p>&#8195;在这里值得注意的是,<code>len</code>保存<code>arr.length</code>的快照是必须的..因为splice会修改原来原来的数组.</p><p>第二种<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for + splice</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">arr, size</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = [], t = [], len = arr.length;</div><div class="line"></div><div class="line">  <span class="comment">// 数组中的个数小于size或者size是小于等于0的也就没有必要分割了</span></div><div class="line">  <span class="keyword">if</span> (len &lt;= size || size &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 它的重点主要是数组中的值的数量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; len; i += size) &#123;</div><div class="line">      <span class="comment">// 查询指定数</span></div><div class="line">      t = arr.slice(i, i + size);</div><div class="line">      a.push(t);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>);</div></pre></td></tr></table></figure><p></p><p>第三种<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// while + slice</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">arr, size</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = [], t = [], i = <span class="number">0</span>,</div><div class="line">      len = arr.length;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">    <span class="comment">// 查询的值</span></div><div class="line">    t = arr.slice(i, i += size);</div><div class="line">    a.push(t);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">chunk([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>);</div></pre></td></tr></table></figure><p></p><h2 id="Falsy-Bouncer-过滤数组假值"><a href="#Falsy-Bouncer-过滤数组假值" class="headerlink" title="Falsy Bouncer(过滤数组假值)"></a>Falsy Bouncer(过滤数组假值)</h2><p>删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。</p><blockquote><p>思路</p></blockquote><p>&#8195;这道题比较有意思..一开始我走进了一个误区,想着单纯<code>return x !== false &amp;&amp; ...</code>这样简单的返回就可以了,后来发现在处理<code>NaN</code>时会很麻烦..<code>isNaN()</code>还会把英文字符串也给过滤掉,再加上多个<code>&amp;&amp;</code>使得代码会变得繁乱,可读性不高.<br>&#8195;然后查阅了一番资料后,才注意到平时被忽略<code>Boolean()</code>的一些特性对于处理这种类型的问题简直不能太合适.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bouncer</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="comment">// 请把你的代码写在这里</span></div><div class="line">  <span class="keyword">var</span> a = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Boolean</span>(x);</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bouncer([<span class="number">7</span>, <span class="string">"ate"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="number">9</span>]);</div></pre></td></tr></table></figure><p>&#8195;<strong>摘至<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean" target="_blank" rel="noopener">MDN.Boolean</a> 的描述:</strong></p><blockquote><p>如果Boolean构造函数的参数不是一个布尔值,则该参数会被转换成一个布尔值.<strong>如果参数是 0, -0, null, false, NaN, undefined, 或者空字符串 (“”),生成的Boolean对象的值为false. </strong>其他任何值,包括任何对象或者字符串”false”, 都会创建一个值为true的Boolean对象.</p></blockquote><h2 id="Seek-and-Destroy-摧毁指定数组"><a href="#Seek-and-Destroy-摧毁指定数组" class="headerlink" title="Seek and Destroy (摧毁指定数组)"></a>Seek and Destroy (摧毁指定数组)</h2><p>实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。</p><blockquote><p>实现原理</p></blockquote><p>&#8195;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">filter()</a> 为数组中的每个元素调用一次 <code>callback</code>函数，并利用所有使得 <code>callback</code> 返回 true 或 等价于 true 的值 的元素创建一个<strong>新数组.</strong><br>&#8195;<code>filter()</code>从头至尾遍历数组,<strong>若回调函数返回的是true(通过测试),就存入新数组中.若返回的是false,则过滤掉.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="comment">// 先将第一个参数隔开,定义一个储存着待移除的空数组</span></div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>[<span class="number">0</span>], removeArgs = [];</div><div class="line"></div><div class="line">  <span class="comment">// 要被删除的参数装进'removeArgs'里</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    removeArgs.push(<span class="built_in">arguments</span>[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 遍历'args',若'removeArgs'中不存在'value',应该返回-1.反之返回false被过滤掉.</span></div><div class="line">  <span class="keyword">return</span> args.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeArgs.indexOf(value) === <span class="number">-1</span>;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">destroyer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure><h2 id="Where-do-I-belong-数组排序并找出元素索引"><a href="#Where-do-I-belong-数组排序并找出元素索引" class="headerlink" title="Where do I belong (数组排序并找出元素索引)"></a>Where do I belong (数组排序并找出元素索引)</h2><p>先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。</p><p>&#8195;举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。</p><p>&#8195; 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。</p><blockquote><p>思路</p></blockquote><p>&#8195;这个没啥好说的了..将第二个参数<code>push</code>进数组中,再进行排序.排序后通过<code>indexOf()</code>来实现功能.<strong>不过需要注意的是<code>sort</code>默认是按照’Unicode’编码进行排序的.</strong></p><h2 id="Caesars-Cipher-凯撒密码"><a href="#Caesars-Cipher-凯撒密码" class="headerlink" title="Caesars Cipher (凯撒密码)"></a>Caesars Cipher (凯撒密码)</h2><p>风靡全球的凯撒密码Caesar cipher，又叫移位密码。<br>移位密码也就是密码中的字母会按照指定的数量来做移位。<br>一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。<br>写一个ROT13函数，实现输入加密字符串，输出解密字符串。<br>所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。</p><blockquote><p>思路</p></blockquote><p>&#8195;本次练习用到<code>String.charCodeAt()</code>和<code>String.fromCharCode()</code>,首先来查询字符串的Unicode字符.<br>&#8195;根据Unicode表我们得知:</p><ul><li>小于65和大于90对应的就是数字和小写字符a-z</li><li>大于等于65和小于等于77对应的就是大写字符A-M (13位)</li><li>大于等于78和小于等于90对应的就是大写字符N-Z<br>&#8195;ROT13的功能就是移位,如果序号小于78(A-M字母)，使用String.fromCharCode()转换成该序号加13的字符,反之减13.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rot13</span>(<span class="params">str</span>) </span>&#123; <span class="comment">// LBH QVQ VG!</span></div><div class="line">  <span class="keyword">var</span> newStr = [];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; str.length;i ++) &#123;</div><div class="line">    <span class="comment">// 查询每个字符串的Unicode编号</span></div><div class="line">    <span class="keyword">var</span> temp = str.charCodeAt(i);</div><div class="line">    <span class="comment">// 非大写字母,空格,数字等都不转换</span></div><div class="line">    <span class="keyword">if</span> (temp &lt; <span class="number">65</span> || temp &gt; <span class="number">91</span>) &#123;</div><div class="line">      newStr.push(str.charAt(i));</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 大于77(N-Z),就转换成该序号 - 13的字符串.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; <span class="number">77</span>) &#123;</div><div class="line">      newStr.push(<span class="built_in">String</span>.fromCharCode(temp - <span class="number">13</span>));</div><div class="line">    <span class="comment">// 小于78(A-M),就转换成该序号 + 13的字符串</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      newStr.push(<span class="built_in">String</span>.fromCharCode(temp + <span class="number">13</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newStr.join(<span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">rot13(<span class="string">"SERR PBQR PNZC"</span>);  <span class="comment">// 你可以修改这一行来测试你的代码</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/e48206bbgy1flhd8j2b8xj21uo18g49f.jpg&quot; alt=&quot;coding&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;数组方法的深入学习&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ffc" scheme="http://yoursite.com/tags/ffc/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>通过sourcetree实现远程仓库与本地仓库关联</title>
    <link href="http://yoursite.com/2018/02/06/%E9%80%9A%E8%BF%87sourcetree%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/"/>
    <id>http://yoursite.com/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/</id>
    <published>2018-02-06T07:33:21.180Z</published>
    <updated>2017-11-04T15:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率.</p><p><img src="http://tc.ffsky.net/images/2017/11/03/a8ad904c186d87984da6a60b9f95f023.png" alt="sourcetree"></p><p>&emsp;&emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联.</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;首先把本地仓库初始化.</p><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/init.png"><p>&emsp;再添加到sourcetree上<br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add.png"></p><p>&emsp;进入github.com -&gt; your profile -&gt; repositories(仓库) -&gt; New<br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add-02.png"></p><p>&emsp;填写仓库信息, 复制仓库链接<br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add-03.png"><br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add-04.png"></p><p>&emsp;设置 -&gt; 添加 -&gt; 填写信息 -&gt; 确定<br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add-01.png"><br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add-05.png"></p><p>&emsp;然后就可以提交到github了~<br><img src="/blog/2018/02/06/通过sourcetree实现远程仓库与本地仓库关联/add-06.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;sourceTree 是当下比较流行的git客户端,简化了如何与Git存储库进行交互，从而可以专注于编码, 可以通过简单的Git GUI可视化来管理仓库, 提高效率.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://tc.ffsky.net/images/2017/11/03/a8ad904c186d87984da6a60b9f95f023.png&quot; alt=&quot;sourcetree&quot;&gt;&lt;/p&gt;&lt;p&gt;&amp;emsp;&amp;emsp;题归正转, 今天我们来说说如何通过sourcetree来将本地仓库与远程仓库关联.&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="sourcetree" scheme="http://yoursite.com/tags/sourcetree/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的console</title>
    <link href="http://yoursite.com/2018/01/30/Debug-%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6console/"/>
    <id>http://yoursite.com/2018/01/30/Debug-深入研究console/</id>
    <published>2018-01-30T05:09:07.000Z</published>
    <updated>2018-02-01T07:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/30/Debug-深入研究console/banner.jpg"><p>打断点和<code>console.log</code>是我们前端调试中, 使用最为频繁的一种. 但实际上console API 可不仅仅用来查看某个值或者某个变量是否存在, 它还有更多的用法是不为人知的.<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的. 其次它是一个全局对象, 我们先在控制台将<code>console</code>打印出来, 看看它里面都有些什么东西, 再来一一讲解吧.</p><img src="/blog/2018/01/30/Debug-深入研究console/console.png"><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p><code>console.log</code>就是向web控制台输出一条信息. 参数可以是变量, 数字, 字符串等.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常规下</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>)            <span class="comment">// Hello</span></div><div class="line"><span class="built_in">console</span>.log(name)               <span class="comment">// Jack</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>)   <span class="comment">// Hello, Jack</span></div></pre></td></tr></table></figure><p></p><p>除此之外, 还支持格式化输出.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hi, %s. what are you doing'</span>, name)              <span class="comment">// Hi, Jack. what are you doing</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'%c I am some great text'</span>, <span class="string">'font-size: 50px;'</span>)   <span class="comment">// 假装 50px: Hi, Jack. what are you doing</span></div></pre></td></tr></table></figure><p></p><img src="/blog/2018/01/30/Debug-深入研究console/console-2.png"><p>下面是它所支持的参数, 学习C语言的同学有没有感觉扑面而来的熟悉感呀~</p><table><thead><tr><th style="text-align:left">占位符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">%s</td><td style="text-align:left">字符串</td></tr><tr><td style="text-align:left">%d or %i</td><td style="text-align:left">整数</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">打印字符串</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">浮点数</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">样式代码</td></tr></tbody></table><p>这里连知乎, 百度等大厂也用<code>console</code>来做招聘广告或做些有意思的事~</p><img src="/blog/2018/01/30/Debug-深入研究console/console-3.png" title="Bilibili 主页"> <img src="/blog/2018/01/30/Debug-深入研究console/zhihu.png" title="知乎"><h3 id="info-warn-error"><a href="#info-warn-error" class="headerlink" title="info, warn, error"></a>info, warn, error</h3><p>这三者实际上在我们开发时也时常出现. 现在主流的一些框架, 比如说Eslint, 就封装了相关方法. 当你语法出现不规范的地方, 就会根据错误来弹出指定的提示框来提示你.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Info</span></div><div class="line"><span class="built_in">console</span>.info(<span class="string">'Hi, This is message'</span>)</div><div class="line"></div><div class="line"><span class="comment">// warning 警告</span></div><div class="line"><span class="built_in">console</span>.warn(<span class="string">'On, Your operation may cause a security breach!'</span>)</div><div class="line"></div><div class="line"><span class="comment">// Error 报错</span></div><div class="line"><span class="built_in">console</span>.error(<span class="string">'Shit! Variable does not exist!'</span>)</div></pre></td></tr></table></figure><p>实际效果:<br><img src="/blog/2018/01/30/Debug-深入研究console/console-info.png"></p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p><code>console.table</code>只接受一个数组或者对象, 可以接受一个额外的参数来描述表格的列数.<br>它会把数据通过表格的形式打印出来, 这样我们看数据的时候就能直观了很多:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">'Jack'</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;,</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">'Tome'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">'baka'</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="built_in">console</span>.table(array)</div></pre></td></tr></table></figure><img src="/blog/2018/01/30/Debug-深入研究console/console-table.png"><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p><code>console.group</code>和<code>console.groupWEnd</code>就像一对标签一样. <code>group</code>在控制台创建一个新的分组, 输出到控制台上的内容都会被添加一个缩进, 表示该内容属于当前分组, 直到调用console.groupEnd()之后, 当前分组才结束.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> boys = [</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">'Jack'</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;,</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">'Tome'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">'baka'</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;</div><div class="line">]</div><div class="line"></div><div class="line">boys.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.group(<span class="string">`<span class="subst">$&#123;item.name&#125;</span>`</span>)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;item.name&#125;</span>`</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item.name&#125;</span> is <span class="subst">$&#123;item.age&#125;</span> years old`</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item.name&#125;</span> is <span class="subst">$&#123;item.age * <span class="number">7</span>&#125;</span> years old`</span>);</div><div class="line">  <span class="built_in">console</span>.groupEnd(<span class="string">`<span class="subst">$&#123;item.name&#125;</span>`</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><img src="/blog/2018/01/30/Debug-深入研究console/console-group.png"><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><blockquote><p>console.dir —— 在控制台中显示指定JavaScript对象的属性，并通过类似文件树样式的交互列表</p></blockquote><p>我们知道<code>console.log</code>实际上是可以输出DOM节点的, 但有时候我们只想知道 DOM 属性的话, 这里就可以使用<code>dir</code>来输出DOM对象.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementById(<span class="string">'head'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(head)</div><div class="line"><span class="built_in">console</span>.dir(head)</div></pre></td></tr></table></figure><p></p><p>值得注意的是. MDN提醒我们, 这个特性是非标准, 尽量不要在生产模式下使用.</p><img src="/blog/2018/01/30/Debug-深入研究console/console-dir.png"><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>count, 如同字面意思一样. <code>count()</code>会输出每一次被调用的次数. 该方法的兼容性也需要注意, 不适用于生产模式.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.count(<span class="string">'Steve'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'Steve'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'zeo'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'Steve'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'zeo'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'Steve'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'zeo'</span>)</div><div class="line"><span class="built_in">console</span>.count(<span class="string">'Steve'</span>)</div></pre></td></tr></table></figure><p></p><img src="/blog/2018/01/30/Debug-深入研究console/console-count.png"><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear, 顾名思义就是清除. 看到别人那乱七八糟的用于调试的log或者info时, 这时只想要保留自己的调试信息. 那么<code>console.clear()</code>就可以为你解决这个烦恼, “一键清空”前面控制台所有的信息, 从头再来(雾)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// something info</span></div><div class="line"><span class="built_in">console</span>.clear()</div></pre></td></tr></table></figure><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>启动一个计时器（timer）来跟踪某一个操作的占用时长。每一个计时器必须拥有唯一的名字。 页面中最多能同时运行10,000个计时器。跟<code>group</code>一样, time也是配套的。 当以此计时器名字为参数调用 console.timeEnd() 时，浏览器将以毫秒为单位，输出对应计时器所经过的时间.</p><p>比如我们起一个<code>fetch</code>:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">'fetching data'</span>)</div><div class="line">fetch(<span class="string">'https://api.github.com/users/anran758'</span>)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> data.json())</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'fetching data'</span>)</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p></p><p>oh, 这样我们就轻易的知道了这次我们请求花费了多少时间啦~<br><img src="/blog/2018/01/30/Debug-深入研究console/console-time.png"></p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p><code>console.assert()</code>还是蛮有意思的. 它第一个参数接受一个断言(声明), 第二个参数是一个<strong>message</strong>. 如果断言为false，则将一个错误消息写入控制台。如果断言是true，就当做没发生。语法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.assert(assertion, message [, subst1, ..., substN]);</div></pre></td></tr></table></figure><p>这里的断言不一定是<code>false</code>才会触发错误. 我特意去测试了一下, 触发的规则也跟<code>if</code>的判断里的逻辑相反. 只要是断言是<code>0</code>, <code>NaN</code>, <code>undefined</code>, <code>false</code>, <code>null</code>, 空字符串<code>&#39;&#39;</code>就会激活报错.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Assertion failed: Here is the "name" can not be empty</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line"><span class="built_in">console</span>.assert(str, <span class="string">'Here is the "str" can not be empty'</span>)</div><div class="line"></div><div class="line"><span class="comment">// Assertion failed: 0 is not allowed!</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">0</span></div><div class="line"><span class="built_in">console</span>.assert(<span class="number">0</span>, <span class="string">'0 is not allowed!'</span>)</div><div class="line"></div><div class="line"><span class="comment">// Assertion failed: That is wrong!</span></div><div class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> === <span class="number">2</span>, <span class="string">'That is wrong!'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 什么都不会发生</span></div><div class="line"><span class="built_in">console</span>.assert(<span class="number">1</span> === <span class="number">1</span>, <span class="string">'That is wrong!'</span>)</div></pre></td></tr></table></figure><img src="/blog/2018/01/30/Debug-深入研究console/console-assert.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在适当的地方使用恰当的方法能使调试变得更清晰. 发现身边很多小伙伴都只了解<code>log</code>的方法, 正好最近看到了这方面的知识, 总结了一下, 活用于开发中能使效率变得更好~</p><p><strong>参考资料:</strong><br>MDN - Console: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Console" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Console</a><br>从console.log说起（上）: <a href="http://www.alloyteam.com/2013/11/console-log/" target="_blank" rel="noopener">http://www.alloyteam.com/2013/11/console-log/</a><br>javascript30: <a href="https://courses.wesbos.com/account/access/5a658ec8a6b56c55273b4078/view/194129876" target="_blank" rel="noopener">https://courses.wesbos.com/account/access/5a658ec8a6b56c55273b4078/view/194129876</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/30/Debug-深入研究console/banner.jpg&quot;&gt;&lt;p&gt;打断点和&lt;code&gt;console.log&lt;/code&gt;是我们前端调试中, 使用最为频繁的一种. 但实际上console API 可不仅仅用来查看某个值或者某个变量是否存在, 它还有更多的用法是不为人知的.&lt;br&gt;
    
    </summary>
    
      <category term="debug" scheme="http://yoursite.com/categories/debug/"/>
    
    
      <category term="debug" scheme="http://yoursite.com/tags/debug/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
      <category term="console" scheme="http://yoursite.com/tags/console/"/>
    
  </entry>
  
  <entry>
    <title>走进 web 移动端开发</title>
    <link href="http://yoursite.com/2018/01/25/web-%E8%B5%B0%E8%BF%9Bweb%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/01/25/web-走进web移动开发/</id>
    <published>2018-01-25T08:28:57.000Z</published>
    <updated>2018-02-01T14:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/25/web-走进web移动开发/banner.jpg"><p>近年来, 人们逐渐倾向移动端的使用. 越来越多的人使用手机/平板来上网. 既然有需求, 那就自然会有市场~ 作为一个身在一线的前端工程师在工作中也难免会遇到这种场景/需求. 下面就分享一下对于移动端的一些学习笔记~<br><a id="more"></a></p><h2 id="移动端基础的知识"><a href="#移动端基础的知识" class="headerlink" title="移动端基础的知识"></a>移动端基础的知识</h2><p>移动端的屏幕相比PC来说多的太多了, 因此我们不能只是使用传统的px, 首先来认识一下我们常用的单位吧.</p><ul><li><strong>px</strong>: css pixels 逻辑像素, 浏览器使用的抽象单位</li><li><strong>dp</strong>, pt: device independent pixels 设备无关像素</li><li><strong>dpr</strong> devicePixelRatio 设备像素缩放比</li></ul><p>它们之间的计算公式是: <code>1px = (dpr)² * dp</code></p><p>这里我们用IPhone 5为例, 我们知道, iPhone 5 的<code>dpr</code>为2, 根据上面的公式, 我们能得出:</p><p>平面上: <code>1px = (2)² * dp</code> =&gt; <code>1px = 4dp(四个物理像素)</code></p><p>但我们在实际的开发中, 更多的是按照长度(维度)来换算:</p><p>维度上: <code>1px = dpr * dp</code> =&gt; <code>1px = 2 * dp</code></p><p>因此在移动端开发的时候. 我们拿到UI的设计图, 设计图(IPhone5)的尺寸是<code>640 * 1136</code>. 这是因为<code>dpr</code>的缘故. 因此我们需要在开发时, 将原先的宽度除于2才行.</p><p>还有我们常说的<code>Retina</code>屏又是什么? <code>Retina屏(高清屏幕)</code>就是<code>dpr &lt;= 2</code>.</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>viewport, 就是视图窗口. 其中它在手机上又分为一下两个窗口.</p><ul><li>Visual viewport (可视窗口)</li><li>Layout viewport (布局窗口)</li></ul><p>最下面一层就是<code>layout viewport</code>, 上面一层就是<code>visual viewport</code>, <code>visual viewport</code>可以控制窗口的缩放(salce), 能看得到更多底层的<code>layout viewport</code>的东西.</p><img src="/blog/2018/01/25/web-走进web移动开发/viewport.png" title="两者的关系"><p>这里值得注意的是, <code>layout viewport</code>的宽度是大于浏览器可视区域的宽度的.</p><h3 id="Meta标签"><a href="#Meta标签" class="headerlink" title="Meta标签"></a>Meta标签</h3><p>如果我们没有限制<code>viewport</code>的缩放比的话. 我们通过获取<code>window.innerWidth(布局窗口) / document.body.clientWidth</code>的缩放比得知, 设备会根据页面的大小, 自动的去调整缩放比. 这就会不符合我们的预期.</p><p>这时我们可以通过<code>Meta</code>标签来控制<code>viewport</code>. 它的语法如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"name=value,name=value"</span>&gt;</span></div></pre></td></tr></table></figure><p>参数如下:</p><ul><li><code>width</code>: 设置布局 viewport 的特定值(“device-width”)</li><li><code>initial-scale</code>: 设置页面的初始缩放</li><li><code>minimum-sacle</code>: 最少缩放</li><li><code>maximum-scale</code>: 最大缩放</li><li><code>user-scalable</code>: 用户能否缩放</li></ul><p>目前主流的编辑器在使用<code>emmet</code>生成基本<code>HTML</code>模板时都会自带插入一句<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>而有时候我们不希望用户能控制页面的搜索，那我们就可以设置<code>user-scalable</code>为<code>no</code>, 百度就是如下的做法:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, user-scalable=no"</span>&gt;</span></div></pre></td></tr></table></figure><p></p><h2 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h2><p>移动端的布局就能不像PC端一样用固定宽度了, 因为移动端有太多不同的屏幕分辨率了.. 因此现在主流的布局方式还是响应式布局和flex布局. 未来还有Grid布局, 不过现在普及度不够高暂时放放, 以后有机会单独开一篇.</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p><em>响应式布局</em>实际上是一个设计理念, 它是多项技术的综合体. 其核心就是<em>媒体查询(@media)</em>.</p><p>响应式网站的优点主要有:</p><ul><li>减少工作量: 代码, 设计, 内容只需要一份. 多出的工作也仅仅是js和css样式的调整.</li><li>相对来说会节省时间</li><li>每个设备都能得到正确的设计</li></ul><p>相反, 它也带有一些副作用(缺点):</p><ul><li>由于我们是响应式布局, 需要加载更多的样式和脚本资源</li><li>设计比较难精准定位和控制</li><li><em>media</em>实际上是css3的玩意, 对老版本浏览器兼容不好(特指IE)</li></ul><p>接着我们继续看看响应式设计着重的几个点吧:</p><ol><li><p>关于响应式设计中<em>针对不同分辨率</em>的媒体查询设计, 可以看我Repo中的<a href="https://github.com/anran758/Front-End-Lab/tree/master/Page%20design" target="_blank" rel="noopener">这一块</a>.</p></li><li><p><em>百分比布局</em><br>仅仅使用媒体查询来适应不同的固定宽度设计, 只会从一组css 到另一组css的切换. 两组之间没有任何平滑渐变. 当没有命中媒体查询时, 表现就会不可控.</p><p>就比如说iPhone又出了个iPad mini, 这个设备的宽度介于iphone和ipad之间. 这样就有可能会导致布局的错乱, 我们应该要尽量避免这种情况发生.</p></li><li><p><em>弹性图片</em><br>很简单也很常见的思路. 图片设置宽度100%, 外层一个div包裹着, div设置宽度, 可以随着媒体查询改变宽度 从而实现自适应</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>当页面达到手机屏幕宽度的时候, 我们可以考虑放弃一些传统页面的设计思想. 力求页面简单, 简洁(手机屏幕小). 因此需要作出以下处理:</p><ul><li>同比例缩减元素尺寸</li><li>调整页面结构布局</li><li>隐藏冗余的元素<br>除此之外, 应该将经常需要切换位置元素使用「绝对定位」, 减少重绘提高渲染性能.</li></ul></li></ol><h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p><code>Flexbox</code>的出现是为了解决复杂的web布局，因为这种布局方式很灵活。容器的子元素可以任意方向进行排列. 有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。</p><p><code>Flex</code>在移动布局上已经运用的很广泛了. 比如我们常见的垂直居中, 原先需要好几行代码的效果, 现在就一行<code>align-items: center</code>就能解决了, 十分便利.</p><p><code>Flex</code>网上已经有太多的详细教程了. 考虑到篇幅限制, 这边也就不再过多的赘述了. 不过值得一提的是, <code>Flexbox</code>是有新旧两个版本的, 新的是<code>display: flex</code>, 旧的(2009年的语法)是<code>display: box</code>; 两者作用都差不多, 只是使用的属性名有些差异, 如果要兼容低版本的浏览器的话可以考虑后者.</p><p><strong>扩展阅读:</strong><br>[张鑫旭]CSS box-flex属性，然后弹性盒子模型简介: <a href="http://www.zhangxinxu.com/wordpress/?p=1338" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=1338</a><br>Flex入门: <a href="http://ife.baidu.com/note/detail/id/952" target="_blank" rel="noopener">http://ife.baidu.com/note/detail/id/952</a><br>Flexbox详解: <a href="https://segmentfault.com/a/1190000002910324" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002910324</a></p><h2 id="移动端一些常见的坑"><a href="#移动端一些常见的坑" class="headerlink" title="移动端一些常见的坑"></a>移动端一些常见的坑</h2><h3 id="1px-border"><a href="#1px-border" class="headerlink" title="1px border"></a>1px border</h3><p>这个问题常出现在ios下, 其根本原因还是<code>retina屏</code>的问题. <code>1px</code>使用了<code>2dp</code>渲染, 因此看上去就会粗一点.</p><p>常见的解决方案有以下几个:</p><p><strong>背景渐变</strong><br>CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的。<br></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> commonStyle() &#123;</div><div class="line">  <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>,<span class="number">1px</span> <span class="number">100%</span> ,<span class="number">100%</span> <span class="number">1px</span>, <span class="number">1px</span> <span class="number">100%</span>;</div><div class="line">  <span class="attribute">background-repeat</span>: no-repeat;</div><div class="line">  <span class="attribute">background-position</span>: top, right top,  bottom, left top;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">mixin</span> border(<span class="variable">$border-color</span>) &#123;</div><div class="line">  @<span class="keyword">include</span> commonStyle();</div><div class="line">  <span class="attribute">background-image</span>:linear-gradient(<span class="number">180deg</span>, <span class="variable">$border-color</span>, <span class="variable">$border-color</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</div><div class="line">  linear-gradient(<span class="number">270deg</span>, <span class="variable">$border-color</span>, <span class="variable">$border-color</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</div><div class="line">  linear-gradient(<span class="number">0deg</span>, <span class="variable">$border-color</span>, <span class="variable">$border-color</span> <span class="number">50%</span>, transparent <span class="number">50%</span>),</div><div class="line">  linear-gradient(<span class="number">90deg</span>, <span class="variable">$border-color</span>, <span class="variable">$border-color</span> <span class="number">50%</span>, transparent <span class="number">50%</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>缺点就是没办法实现圆角.</p><p><strong>使用 scale 缩放0.5倍</strong><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sidebar</span> <span class="selector-class">.folder</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">15px</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#7c7c7c</span>;</div><div class="line">  <span class="attribute">Cursor</span>: pointer;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.folder</span> + <span class="selector-tag">li</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: -<span class="number">1px</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</div><div class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(0.5);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="多行文本溢出"><a href="#多行文本溢出" class="headerlink" title="多行文本溢出"></a>多行文本溢出</h3><p>webkit内核的浏览器可以尝试使用<code>-webkit-line-clamp</code>, 可惜兼容性不高.<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.intwoline</span> &#123;</div><div class="line">  <span class="attribute">display</span>: -webkit-box <span class="meta">!important</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">  <span class="attribute">word-break</span>: break-all;</div><div class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</div><div class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="终端交互优化"><a href="#终端交互优化" class="headerlink" title="终端交互优化"></a>终端交互优化</h2><p>最近几年，爆炸式的移动Web浏览器的使用打破了这个途径。低带宽，高延迟，小内存，低处理器性能的移动设备环境，迫使开发者不得不想办法通过优化前端页面的性能来满足用户的性能预期。</p><h3 id="300毫秒的故事"><a href="#300毫秒的故事" class="headerlink" title="300毫秒的故事"></a>300毫秒的故事</h3><blockquote><p>移动web页面上的click事件响应都要慢上300ms</p></blockquote><p>移动设备访问的web页面都是pc上的页面. 在默认的v<code>iewport(980px)</code>的页面往往都是需要”双击”或”捏开”放大页面, 来看清页面. 正是为了确定用户是”双击”还是”单击”. sofari需要个300ms的延迟来判断. 而后来的Iphone也一直沿用这样的设计, 没借鉴成功iPhone的android也沿用了这样的设计. 于是”300ms的延迟”就成为了一道规范.</p><p>因此针对这个延迟, 出现了使用tap基础事件去代替click事件. 已经有成熟的类库去帮我们实现了, 这也不展开讲.</p><h3 id="移动端的事件"><a href="#移动端的事件" class="headerlink" title="移动端的事件"></a>移动端的事件</h3><p>现在智能手机的普及, 触摸成为了移动设备的交互的核心事件, 主要有这几种常用的事件<br>• Touchstart: 手指触摸屏幕触发(只有第一下才会触发)<br>• Touchmove: 手指在屏幕滑动, 连续触发<br>• Touchend: 手指离开屏幕时触发<br>• Touchcanel: 系统取消touch时候触发(不常用)</p><p>除了常见的事件属性外, 触摸事件也有自己专有的触摸属性:</p><ul><li>touches: 跟踪触摸操作的touch对象数组</li><li>targetTouches: 特定时间目标的touch对象数组</li><li>changeTouches: 上次触摸改变的touch对象数组</li></ul><p>其中<code>touches</code>是最为常用的. 它是一个数组, 包含着几个touch对象, 每个touch对象包含如下属性:<br>• clientX: 触摸目标在视口中的x坐标<br>• clientY: 触摸目标在视口中的y坐标<br>• Identifier: 标识触摸的唯一ID<br>• pageX: 触摸目标在页面中的x坐标.<br>• pageY: 触摸目标在页面中的y坐标.<br>• screenX: 触摸目标在屏幕中的x坐标<br>• screenY: 触摸目标在屏幕中的y坐标<br>• target: 触摸的DOM节点目标</p><p>不过值得注意的是 Android 下可能会有touchend不触发的bug, 已知 Android 4.0, 4.1, 4.4 ~ 5.0都有这个bug.</p><h3 id="弹性滚动"><a href="#弹性滚动" class="headerlink" title="弹性滚动"></a>弹性滚动</h3><p>当客户端的页面滚动到底部或顶部的时候, 滚动条会允许我们再向上(下)拖, 松开就会有缓冲反弹的效果, 能有一个良好的用户体验.</p><p>移动web页面也有这样的能力. 但是滚动有几种情况需要考虑(副作用):</p><ul><li>body层滚动: (系统特殊化处理)<br>自带弹性滚动, overflow:hidden失效, GIF和定时器暂停</li><li>局部滚动: 没有弹性滚动, 没有滚动惯性, 不流畅</li></ul><p>而局部滚动开启弹性滚动的方式也很简单, 只需要在body上添加如下的代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="comment">/* android 不支持, 但是有类库支持*/</span></div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="上拉刷新-下拉加载"><a href="#上拉刷新-下拉加载" class="headerlink" title="上拉刷新, 下拉加载"></a>上拉刷新, 下拉加载</h3><p>在移动端, 我们常常能看到这种 —— 顶部会允许下拉一小点距离, 松开时页会有弹性的滚动向下, 并且加载数据. 这是一种良好的交互. 多数类库或者插件都能实现这种效果. 可惜本人移动端的经验不足, 没有自己去实现过一次. (再占一个坑吧~</p><img src="/blog/2018/01/25/web-走进web移动开发/img-1.jpg" title="上拉刷新, 下拉加载"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>移动端与PC端的开发主要还是着重点不同吧. 比如在移动开发时, 我们必须要考虑用户的流量, 并不是所有人都在用着好的WIFi来上网.<br>其中如何在这个小屏幕下给用户带来良好的体验也是另外一门学问. 本文只是总结一些常见的东西, 比如移动端适配也还没有讲. 如果以后自己的工作重心倾向移动端的话, 就会继续再更新相关的内容吧~</p><p><strong>参考资料:</strong><br>饿了么 - 移动端Web开发踩坑之旅: <a href="https://zhuanlan.zhihu.com/p/26141351" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26141351</a><br>Hello, 移动WEB: <a href="https://www.imooc.com/learn/494" target="_blank" rel="noopener">https://www.imooc.com/learn/494</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/25/web-走进web移动开发/banner.jpg&quot;&gt;&lt;p&gt;近年来, 人们逐渐倾向移动端的使用. 越来越多的人使用手机/平板来上网. 既然有需求, 那就自然会有市场~ 作为一个身在一线的前端工程师在工作中也难免会遇到这种场景/需求. 下面就分享一下对于移动端的一些学习笔记~&lt;br&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="解决方案" scheme="http://yoursite.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们要选用 Vue/React/Angular 进行开发</title>
    <link href="http://yoursite.com/2018/01/23/JavaScript-%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%94%BE%E5%BC%83JQuery%E8%80%8C%E9%80%89%E7%94%A8Vue-React-Angular%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/01/23/JavaScript-你为什么会放弃JQuery而选用Vue-React-Angular进行开发/</id>
    <published>2018-01-23T12:43:24.000Z</published>
    <updated>2018-01-25T14:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/23/JavaScript-你为什么会放弃JQuery而选用Vue-React-Angular进行开发/banner.png"><p>JQuery, 曾经从事网页工作者的标配, 以前还没有前端的概念, 但不懂JQuery几乎是会被嘲讽的. 而当下的使用量却逐年降低, 更多的用户转向新兴的 React/Angular/Vue . 今天我们来聊聊, 相比JQuery成熟庞大生态圈, 为什么我们现在开始逐步的放弃 JQuery.</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>截止至笔者写这篇文章为止(2018.1), 前端开发的大趋势主要是以下几点:</p><ul><li>旧浏览器逐渐被淘汰(比如IE8及以下, 主流框架已经放弃了支持)</li><li>移动端需求的增加</li><li>用户体验要求变得更高</li><li>前端架构从传统的后台 MVC 向 RESTFul API + 前端 MV* 迁移</li></ul><p>众所周知. JQuery只是一个DOM和ajax的封装库. 现在前端项目的日益发展导致JQuery已经不足以承载太多的复杂项目了. JQuery能兼容各种低版本的浏览器这一大优势也在旧浏览器淘汰的路上逐步减弱. 越来越多的开发者开始拥抱新型框架, 它们使前端不太需要关心DOM了, 只需要关心状态.</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>因为我目前主要使用的是Vue的技术栈, 就来说说为什么要选择 Vue 吧.<br>首先, Vue.js是一个库, 并不是一个真正框架(或者说是一个UI层面的框架). 它相比其他两个主流框架 (React/Angular) 来说 Vue 的学习成本相对来说会比较低. 其次 vue 的作者是国人<a href="https://weibo.com/arttechdesign?topnav=1&wvr=6&topsug=1" rel="noopener" target="_blank">尤雨溪</a>, 因此它对中文的支持会更友好一点(说句题外话, 偶尔能看到有老外吐槽. Vue.js的源码偶尔能看到中文的注释2333).</p><p>Vue是渐进式框架, 它主要关注的是视图管理. 其核心思想主要是数据驱动和组件化. vue的优势主要有以下几点:</p><ol><li><p>侵入性低<br>不对整体构架做过多约束, 方便与其他库或是已有的前端技术栈整合. 比如说当前的项目就是在使用JQuery, 我们也可以将项目移入vue里, 然后逐步的进行改良.</p></li><li><p>vue鼓励模块化<br>因为组件系统是 Vue 的另一个重要概念, 因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用. 这将有利于将界面代码自然分割成更容易维护的模块. 简而言之就是模块化开发, 减少代码的重复性和提高复用性.<br>vue.js比较推荐的是基于commonJs的一个模块方案. 通过webpack这样的模块构建工具, 将一个组件的模块, css和js都写在同一个文件里. Vue本身也有自己脚手架叫做<code>vue-cli</code>, 通过脚手架来帮助我们自动构建项目, 再使用npm进行包管理也是使项目模块化的一种.</p></li><li><p>Vue的语法糖和各种修饰符使得编写JS变得更加的容易. 同时使用一些依赖库, 比如<code>babel</code>使我们能大胆的使用ES6的语法糖. 原先需要封装一个函数的命令, 现在只用一句代码就能解决了. 大大的提高效率.</p></li><li><p>Vue也有自己的生态系统和一个活跃的社区.</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>JQuery作为曾经的霸主, 现在市场使用的份额仍然不小. 原因主要是一些老旧的项目仍然在使用着. 其次, 有些时候我们也会遇到需要频繁操作DOM的场景, 再加上JQuery庞大的生态圈. 有很多完善的插件仍然可以使用. 因此, JQuery虽然过时了, 但在未来几年中, 也必然还会有它的份额存在.</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/23/JavaScript-你为什么会放弃JQuery而选用Vue-React-Angular进行开发/banner.png&quot;&gt;&lt;p&gt;JQuery, 曾经从事网页工作者的标配, 以前还没有前端的概念, 但不懂JQuery几乎是会被嘲讽的. 而当下的使用量却逐年降低, 更多的用户转向新兴的 React/Angular/Vue . 今天我们来聊聊, 相比JQuery成熟庞大生态圈, 为什么我们现在开始逐步的放弃 JQuery.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>性能优化 - 回流与重绘</title>
    <link href="http://yoursite.com/2018/01/15/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%B1%87/"/>
    <id>http://yoursite.com/2018/01/15/性能优化-回流与重汇/</id>
    <published>2018-01-15T04:19:57.000Z</published>
    <updated>2018-01-17T04:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/15/性能优化-回流与重汇/banner.png"><p>回流与重绘已经是个老生常谈的问题啦, 但提到性能优化上却又必不可免的提到它. 今天来谈一谈什么是回流与重绘, 我们该如何去测试, 如何针对性的去优化.</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在<code>HTML</code>中, 每一个标签都有自己的盒子模型. 浏览器在解析<code>HTML</code>的过程中会通过一个叫<code>frame</code>的对象对盒子进行操作. 它主要有三个动作:</p><ul><li>构建<code>frame</code>, 以建立<code>DOM树</code>.</li><li><strong>reflow</strong>, 布局引擎为<code>frame</code>计算图形, 以确定对象位置, 浏览器根据各种样式来计算结果放在它该出现的位置.</li><li><strong>repaint</strong>, 当计算好盒子模型的位置, 大小以及其他属性后, 浏览器就根据各自的特性进行绘制一遍, 显现出来给用户看.</li></ul><img src="/blog/2018/01/15/性能优化-回流与重汇/Mozilla.gif" title="Mozilla 页面绘制"><h2 id="回流的代价"><a href="#回流的代价" class="headerlink" title="回流的代价"></a>回流的代价</h2><p><strong>回流(reflow)</strong>就是布局引擎为 frame 计算图形的过程. 但是这里需要我们注意的是, 回流并不仅仅只是在渲染页面的时候会触发, 实际上当你修改某个 css 属性或者操作 DOM 时, 就有可能会触发回流和重绘.</p><p>也就是说, 我们操作 DOM 实际上是<em>有代价</em>的. 因为 DOM 的改变会导致浏览器重新计算的它的位置和渲染的样式. 我们来做一个假设, 当用户作出某个操作时(比如下拉滚动条), 你的页面中有几十个 DOM 节点同时发生回流绘制, 那这中间消耗的可是浏览器的资源, 可想而知这样页面的性能自然弱了下来.</p><h2 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h2><p>YaHoo!性能小组总结了一些导致<code>reflow</code>发生的一些因素:</p><ol><li>调整窗口大小</li><li>改变字体</li><li>增加或者移除样式表</li><li>内容变化，比如用户在 input 框中输入文字, CSS3 动画等</li><li>激活<code>CSS</code>伪类，比如<code>:hover</code></li><li>操作<code>class</code>属性</li><li>脚本操作<code>DOM</code></li><li>计算<code>offsetWidth</code>和<code>offsetHeight</code>属性</li><li>设置 style 属性的值</li></ol><p>而<code>repaint</code>只要视觉效果改变了, 就一定会触发<code>repaint</code>. 比如<code>color</code>或者<code>background</code>. 这个很好理解, 如同字面意思一样. 重绘嘛, 就是字体颜色发生了变化浏览器需要重新绘制一遍. 这里值得一提的是, <strong>触发<code>reflow</code>一定会触发<code>repaint</code>, 而触发<code>repaint</code>却不一定会触发<code>reflow</code></strong>.</p><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><p>接下来我们找个页面测试一下, 看看该如何去调试回流与重绘的.<br>先来介绍一下我使用的工具. 我们打开天猫官网, 打开Chrome开发者工具, 找到 <code>More tools =&gt; Rendering</code> 面板， 可以看到以下几个选项:</p><ol><li><strong>Paint flashing</strong> - 高亮(绿色)显示重绘的页面区域</li><li><strong>Layer boders</strong> - 我们知道页面是由多个”图层”组合的, 最终显示给用户看的就是多图层叠加在一起的效果, 区别无非是层级的问题(css的<code>absolute</code>和<code>z-index</code>就可以很好的说明这一点). 勾选这个选项可以显示图层边款, 我们再根据分析哪些不是我们想要的.</li><li><strong>FPS meter</strong> - 玩游戏的同学大概会比较了解这个, 也就是显示绘制每秒帧数，帧速率分布和GPU内存. 这个更多的是用来分析页面交互和动画性能.</li><li><strong>Scrolling performance issues</strong> - 滚动性能问题. 它会高亮显示可能减慢滚动速度的元素(蓝绿色), 其中包括触摸和滚轮事件处理程序以及其他主线程滚动情况.(有兴趣的同学可以在淘宝的官网勾上这个选项, 看下都有啥).</li></ol><img src="/blog/2018/01/15/性能优化-回流与重汇/img-1.png" title="Paint flashing"><p>这里主要讲<code>Paint flashing</code>. 我们勾上按钮后, 首先能看到天猫的Logo是一个GIF的动态图, 不断闪烁的绿色高亮提醒着我们, 浏览器正在努力的绘制的图形. 这点很好理解, 因为它是动态的, 浏览器需要绘制 gif 的每一帧展示给用户看. 首屏的轮播图也同理, 内容的不断变化触发着回流与重绘.</p><p>紧接着我们往下滚, 发现左下角的工具栏会随着滚动而发生重绘. 很显然, 这种是使用了<code>fixed</code>定位. 我们知道<code>fixed</code>是相对浏览器窗口进行定位的. 我们滚动一点, 它会重新计算位置, 导致触发回流. 所幸的是<code>fixed</code>定位只会对自己渲染, 而不会影响身边的DOM.</p><p>接着我们继续测试. 咦? 这几个商品模块好像不太对劲呀? 怎么停止滚动了, 还是会发生不断的重绘? 打开审查元素一看, 模块中有一个 gif 的背景图片. 我们将属性关闭, 发现几个模块的重绘都消失了, 果然是这东西作祟呀. 紧接着我们来检查一下这 gif 是有什么特殊的作用. 将表面的DOM删掉, 还原<code>background</code>属性 —— 噢~原来是一个加载的loading…. 父元素加一个loading动图, 在子元素还没加载出来时显示loading. 加载后由于层级的关系自然就覆盖了上去, 用户自然就看不到了.</p><p>这种看似巧妙简便的方法实则是在用户看不到的地方在浪费无意义的性能消耗而已. 因此我还特意的去测试了淘宝和京东的情况, 发现这种写法只有天猫才有. 不知道写页面的同学是偷懒还是什么其他的原因, 这里我们可不要养成这种习惯~很多时候坑就是自己挖的最后又自己踩了上去.</p><img src="/blog/2018/01/15/性能优化-回流与重汇/repaint.gif" title="天猫"><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><p>到这里我们已经了解了渲染规则后, 那么就可以针对性的进行控制优化 —— 在我们 coding 的时候合理的去避开回流的影响来减少页面的开销.</p><p><code>display:none</code>这个属性已经被玩烂了, 该属性的作用就如同它名字一样直观. <code>display</code>就是用来控制显示的状态嘛… 因此很多人喜欢拿它来做隐藏某一个元素的方法. 而背后却忽略了(或者说不知道)它本身所带的回流性能开销(因为会影响节点的位置从而触发回流和重绘).</p><p>值得庆幸的是, 已经有前行者帮我们踩过很多坑, 我们只需站在巨人的肩上, 借鉴一下前人的经验:</p><ol><li>如果想设定元素的样式，通过改变元素的<code>class</code>类名 (尽可能在 DOM 树的最里层)</li><li>避免设置多项内联样式</li><li>应用元素的动画，使用<code>position</code>属性的<code>fixed</code>值或<code>absolute</code>值(前文说过, 它只会影响自己)</li><li>权衡平滑和速度</li><li>避免使用<code>table</code>布局</li><li>避免使用 CSS 的<code>JavaScript</code>表达式 (仅 IE 浏览器)</li></ol><p>除此之外, 使用<code>JavaScript</code>想要动态插入多个节点时, 可以使用<code>DocumentFragment</code>. 创建后一次插入. 就能避免多次的渲染性能.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结一下所学的概念, 回流(reflow), 就是布局引擎为<code>frame</code>计算图形, 确定节点位置的一个步骤. 其中触发回流的原因主要是节点(DOM)大小或者位置的改变才会触发回流. 而重绘, 就是表面的视觉效果改变了, 就会触发重绘. 其中触发了回流紧接着也会触发重绘, 而触发重绘不一定会触发回流(ahh..有点像绕口令).</p><div class="note primary"><p><strong>参考资料</strong><br>形象化的reflow: <a href="http://www.aoao.org.cn/blog/2008/05/reflow/" target="_blank" rel="noopener">http://www.aoao.org.cn/blog/2008/05/reflow/</a><br>影响 reflow 的因素及其优化: <a href="http://www.planabc.net/2009/04/13/reflow/" target="_blank" rel="noopener">http://www.planabc.net/2009/04/13/reflow/</a><br>Gecko Reflow Visualization - mozilla.org: <a href="https://www.youtube.com/watch?v=ZTnIxIA5KGw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ZTnIxIA5KGw</a><br><a href="http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="noopener">回流与重绘: CSS性能让JavaScript变慢?</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/15/性能优化-回流与重汇/banner.png&quot;&gt;&lt;p&gt;回流与重绘已经是个老生常谈的问题啦, 但提到性能优化上却又必不可免的提到它. 今天来谈一谈什么是回流与重绘, 我们该如何去测试, 如何针对性的去优化.&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>性能优化 - 基础的性能优化</title>
    <link href="http://yoursite.com/2018/01/13/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/13/性能优化-前端性能优化/</id>
    <published>2018-01-13T14:43:15.000Z</published>
    <updated>2018-01-17T04:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/13/性能优化-前端性能优化/banner.png"><p>其实很多性能方面的问题, 很多都是从基础就开始影响. 既然如此我们也从最底层逐步分析, 切入每一点小细节~<br><a id="more"></a></p><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><p>web早期, 人们有很多想要实现的设计效果出于css或兼容性的限制, 不得不由图片来去实现这种效果. 以现在时代的眼光来说, 无疑是很不优雅的. 撇开图片本身所占用的空间大小外, 本身代码结构就不够语义化. 那么现在这个CSS3都已经普及的年代, 来试着让<code>HTML</code>, <code>CSS</code>属性或<code>SVG</code>用寥寥数行的代码来代替图片来实现效果吧~ 比如一个圆角, 一个渐变的海浪线等.</p><h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><p>每一种图片格式都有着自己的特点和优势, 下面来了解一下现在常见的图片格式来”对症下药”.</p><p>主流的图片格式</p><ul><li><code>jpg</code> 全名是JPEG. JPEG图片以24位颜色存储单个位图.</li><li><code>png</code> 可移植网络图形格式. 使用<code>png</code>格式的图片更多的是看中它有透明图层, 因为它是256色, 每一色都可以作为透明像素. 但相对的代价就是体积较大(这个可想而知嘛, 图片里面的信息装的多了, 体积自然就大了).</li><li><code>GIF</code> 这个稍微有点网络常识的对会知道, 常用于做动画.</li><li><code>SVG</code> 可缩放矢量图形. 它能很好的处理图形大小的改变, 放大缩小都不会失真, 适合静态图片展示，高保真文档查看和打印的应用场景. 如今主流浏览器都对它有着很好兼容性支持.</li></ul><p>没有被Web标准采纳的格式, 但还是值得关注图片格式<br><strong>APNG</strong> APNG 是出自 Mozilla 公司下的两位程序员之手, APNG 的出现是为了代替 GIF. 它相较GIF来说有着更好的图片质量, 还支持着透明图层, 同时图片的大小都比 GIF 格式要小.</p><p>可惜由于出现的较晚, 没有被Web标准给采纳. 截止到笔者写这篇文章的时间(2018.1), Edge这个不合群的家伙在最新版本 Edge 17 仍然还没有支持这个格式, 而chrome 59才开始支持. 因此兼容性不高, 平时也很少能看到这种格式的出现.</p><p><strong>Webp</strong>是出自Google之手, WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p><p>同上面的 APNG 一样, 同样没有被Web标准所采纳. 不过在 caniuse 上能发现, 如今国内大半的用户已经支持了 WebP , 这个未来还是可以小小的期待一下.</p><h3 id="正确的使用图片格式"><a href="#正确的使用图片格式" class="headerlink" title="正确的使用图片格式"></a>正确的使用图片格式</h3><p>话归正题, 下面针对不同的使用场景, 来选择正确的图片格式.</p><ul><li>首先是jpg, 一般不需要透明图层的图片一律使用jpg, 它相对png来说两者的体积之差能有几倍之差.</li><li>如果需要比较通用的动画的话, GIF是唯一的选择. 如果是相对简单的GIF动画的话, 也可以考虑使用CSS3来实现.</li><li>如果需要清晰显示颜色丰富的图片或者需要用到透明图层的话, png是一个比较好的选择</li></ul><h3 id="页面中图片加载方式"><a href="#页面中图片加载方式" class="headerlink" title="页面中图片加载方式"></a>页面中图片加载方式</h3><p>细心的你或许会发现, 有时在网络慢的情况下, 能看到图片一点一点从上到下的加载. 或者是先模糊, 再清晰的加载方式.<br>实际上这是图片的压缩算法呈现的效果, 逐行显示是<em>离散余弦变化</em>. 而模糊到清晰的是<em>小波算法</em>. 浏览器先读取图片的压缩算法, 再根据算法来选择不同的渲染算法. 下面是某图站的一张大的壁纸加载过程(没有找到小波算法的图, 以后留意到了再回来补)</p><img src="/blog/2018/01/13/性能优化-前端性能优化/anima-1.gif" title="离散余弦变化"><p><strong>参考资料</strong><br><a href="https://aotu.io/notes/2016/11/07/apng/index.html" rel="noopener" target="_blank">APNG 那些事</a></p><h3 id="常见的图片优化方案"><a href="#常见的图片优化方案" class="headerlink" title="常见的图片优化方案"></a>常见的图片优化方案</h3><p><strong>CSS-Sprite</strong></p><p>在页面中, 我们经常能看到一些icon图标. 这些icon实际上占用并不大, 但奈不住多呀. 100个icon的话就要发送一百个HTTP请求. CSS Sprite(精灵). 利用CSS的<code>background-position</code>和<code>background-image</code>属性, 只需要引用一张图片即可. 这极大的节省了HTTP请求量.</p><p><strong>iconfont</strong><br><code>iconfont</code> 和上面所提的<code>css-sprite</code>方法类似, 不同的是这个方法是通过引入字体图标的形式. 好处是设置字体图标的颜色或者可以通过设置<code>font-size</code>来改变尺寸, 并且不容易失真.</p><p>当然, 现在都是使用自动化工具, 都不需要自己手动去调整</p><p><strong><code>&lt;picture&gt;</code>标签</strong><br>HTML5新出了一个<code>&lt;picture&gt;</code>标签, 它是一个容器, 用来为其内部特定的<code>&lt;img&gt;</code>提供多样的<code>&lt;source&gt;</code>元素. 浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源. 也就是所谓的响应式图片. 由于兼容性所限, 因此当下并没有广泛使用.</p><p><code>media</code>属性允许你提供一个用于给用户代理作为选择<code>&lt;source&gt;</code>元素的依据的媒体查询。如果这个媒体查询匹配结果为<code>false</code>，那么这个<code>&lt;source&gt;</code>元素会被跳过, 使用如下.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"mdn-logo-smaller.png"</span> <span class="attr">media</span>=<span class="string">"(max-width: 768px)"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"mdn-logo-big.png"</span> <span class="attr">media</span>=<span class="string">"(min-width: 1000px)"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"mdn-logo-narrow.png"</span> <span class="attr">alt</span>=<span class="string">"MDN"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>构建自动化工具实现优化</strong><br>这个一句话说不完, 以后单独拎出来说这东西吧.</p><h2 id="视频优化"><a href="#视频优化" class="headerlink" title="视频优化"></a>视频优化</h2><p>当下视频播放器分为两大流派, 一个是HTML5新进入的<code>video</code>标签, 使用方式简洁. 也是现在主流播放方案. 另一个是<code>Flash</code>播放器, 也是过去常用的播放方案. 虽然技术成熟, 插件多, 但也是逐步的将被淘汰. chrome浏览器默认禁止Flash播放器的使用, 就连Edge都要手动开启才能使用.</p><blockquote><p>来对比一下两者的优缺点</p></blockquote><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">video</td><td style="text-align:left">不需要下载额外的资源(如插件什么的)</td><td style="text-align:left">不同浏览器<code>video</code>标签的外观都不一样. 如果要统一的话需要自己写UI来实现</td></tr><tr><td style="text-align:left">Flash</td><td style="text-align:left">兼容性好, 只需要有 Flash player 播放器插件都可以进行播放</td><td style="text-align:left">1. 需要下载额外的 swf 播放文件才可以播放, 浏览器必须要有Flash player插件(回想以前网页老是让你下载Flash的场景)<br>2. Flash player 版本的碎片化<br>3. UI定制需要 as(带有学习成本)</td></tr></tbody></table><p><strong>当下主流的方案</strong><br>Flash 和 HTML5 两个方案相结合, 组成一个完整的方案. 当下就有几个成熟稳定的库, 如<code>Flowplayer</code>和<code>VideoJs</code>等.</p><p><strong>视频优化需要的解决问题</strong></p><ol><li>由于各浏览器UI不同, 设计师会要求我们按照设计图做播放器.</li><li>在一些视频网站中, 可能产品经理就会让我们实现, 让用户一进来就最先看到视频.<br>浏览器会将所有的多媒体文件放在最后面加载, 无论标签位置放置在什么位置. 解决的方案就是将<code>&lt;link&gt;</code>代替<code>&lt;script&gt;</code>标签引用.</li></ol><h2 id="常用的前端缓存技术"><a href="#常用的前端缓存技术" class="headerlink" title="常用的前端缓存技术"></a>常用的前端缓存技术</h2><p><code>SessionStorage</code> 临时性存储, 数据仅仅在当前的页面生效, 关闭页面后数据就自动清除了. 同时刷新页面不属于”离开页面”的范围, 数据仍然会存在. 现在微信公众号开发常用这种方法来记录用户信息.</p><p><code>Cookie</code>, 兼容性最好的本地存储. 缺点是有大小的限制, 而且每次发送请求时, 请求头会带着Cookie一起发送过去.(这里有个问题, 如果在cookie中存储了1M的数据, 那么在请求的时候, 1M的数据也会跟着请求发送到服务端. 这就很大的影响带宽了) 现在基本大多数登录的合法性验证都是用cookie验证的.</p><p>LocalStorage 特点是持久储存, 操作方法和 SessionStorage 乐视, 也都是操作key-value的形式. 几乎所有现代浏览器都已经支持了. 值得注意的是, LocalStorage 虽然可以永久储存, 但是无法跨浏览器的获取数据的, 还需要注意储存上限.</p><h2 id="高性能DOM"><a href="#高性能DOM" class="headerlink" title="高性能DOM"></a>高性能DOM</h2><p>说到高性能的<code>DOM</code>, 就不得不提回流与重绘这个概念. 为此我又专门的写了一篇<a href="https://anran758.github.io/blog/2018/01/15/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%B1%87/" target="_blank" rel="noopener">回流与重绘</a>. 有兴趣的同学可以去看一下.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文都只是在基础上的优化. 还有更多项目内工程化的优化就再等咱有时间再更新相关的内容吧~</p><div class="note primary"><p><strong>参考资料</strong><br>前端性能优化-通用的缓存SDK: <a href="https://www.imooc.com/learn/866" target="_blank" rel="noopener">https://www.imooc.com/learn/866</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/13/性能优化-前端性能优化/banner.png&quot;&gt;&lt;p&gt;其实很多性能方面的问题, 很多都是从基础就开始影响. 既然如此我们也从最底层逐步分析, 切入每一点小细节~&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解之排序二叉树</title>
    <link href="http://yoursite.com/2018/01/10/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/01/10/深入学习之排序二叉树/</id>
    <published>2018-01-10T03:13:32.000Z</published>
    <updated>2018-01-12T15:18:24.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/10/深入学习之排序二叉树/banner.png"><p>二叉树是一种具有层级特性的的数据结构. 这些知识虽说在日常工作中不常使用, 但还是有必要让我们去学习一下, 研究其原理是如何运作. 下面将分享自己的一些理解和学习笔记, 来谈一谈什么是排序二叉树.</p><a id="more"></a><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>树(Tree), 是(n&gt;=0)个节点的有限集. 其中 n=0 时, 我们称之为空树. 在一棵非空树中, 只有一个根节点. 在二叉树中, 每个节点最多有两个子节点. 一般称为左节点和右节点(左、右子树).</p><h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><p>排序二叉树, 又称为二叉查找树. 它有着自己显著的特点:</p><ol><li>首先一个节点左孩子的值, 一定小于它本身节点的值.</li><li>一个节点右孩子的值, 一定大于它本身节点的值.</li><li>左、右孩子(子树)也分别是排序二叉树.</li></ol><h3 id="构建排序二叉树"><a href="#构建排序二叉树" class="headerlink" title="构建排序二叉树"></a>构建排序二叉树</h3><p>二叉树大多也是递归定义的. 下面根据排序二叉树的特性来创建一个二叉树.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryTree</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> root = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>) </span>&#123;</div><div class="line">    <span class="comment">// 对比新旧节点</span></div><div class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</div><div class="line">      <span class="comment">// 左节点是否存在</span></div><div class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</div><div class="line">        node.left = newNode;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        insertNode(node.left, newNode);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 右节点是否存在</span></div><div class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</div><div class="line">        node.right = newNode;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        insertNode(node.right, newNode);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 暴露方法, 插入节点</span></div><div class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key);</div><div class="line">    <span class="comment">// 根节点是不是空的</span></div><div class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</div><div class="line">      root = newNode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      insertNode(root, newNode);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> nodes = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>];</div><div class="line"><span class="keyword">var</span> binaryTree = <span class="keyword">new</span> BinaryTree();</div><div class="line"></div><div class="line">nodes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  binaryTree.insert(key);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>我们已经构建好了一个排序二叉树, 现在想要获取二叉树每一个节点的信息, 因此我们需要<em>遍历</em>节点, 对它做一些操作.</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>二叉树有<em>三种遍历</em>的方法, 分别是<em>中序遍历</em>, <em>前序遍历</em>, <em>后序遍历</em>. 其中中序遍历的顺序是: <strong>左子树 -&gt; 根元素 -&gt; 右子树.</strong></p><p>对于二叉排序树来说，中序遍历得到的序列是<em>一个从小到大排序好的序列</em>. 百闻不如一见, 我们先看看图中的路线图, 整理一下思路先.</p><img src="/blog/2018/01/10/深入学习之排序二叉树/img-2.png"><p>这里我们需要加入中序遍历的接口, 因此我们在原先代码上继续扩展并运行.<br>控制台会依次输出”1 3 4 6 7 8 10 13 14”</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">  function BinaryTree(key) &#123;</div><div class="line">    var root = null;</div><div class="line">    var Node = function (key) &#123;</div><div class="line">      this.key = key;</div><div class="line">      this.left = null;</div><div class="line">      this.right = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var insertNode = function (node, newNode) &#123;</div><div class="line">      // 对比新旧节点</div><div class="line">      if (newNode.key &lt; node.key) &#123;</div><div class="line">        // 左节点是否存在</div><div class="line">        if (node.left <span class="comment">=== null) &#123;</span></div><div class="line">          node.left = newNode;</div><div class="line">        &#125; else &#123;</div><div class="line">          insertNode(node.left, newNode);</div><div class="line">        &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">        if (node.right <span class="comment">=== null) &#123;</span></div><div class="line">          node.right = newNode;</div><div class="line">        &#125; else &#123;</div><div class="line">          insertNode(node.right, newNode);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="addition">+    // 中序遍历</span></div><div class="line"><span class="addition">+    var inOrderTraverseNode = function (node, callback) &#123;</span></div><div class="line"><span class="addition">+      // 递归遍历, 当到最后叶子节点时, 下面没有节点就会直接返回</span></div><div class="line"><span class="addition">+      if (node !== null) &#123;</span></div><div class="line"><span class="addition">+        inOrderTraverseNode(node.left, callback);</span></div><div class="line"><span class="addition">+        callback(node.key);</span></div><div class="line"><span class="addition">+        inOrderTraverseNode(node.right, callback);</span></div><div class="line"><span class="addition">+      &#125;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"></div><div class="line">    // 插入节点</div><div class="line">    this.insert = function (key) &#123;</div><div class="line">      var newNode = new Node(key)</div><div class="line">      if (root <span class="comment">=== null) &#123;</span></div><div class="line">        root = newNode;</div><div class="line">      &#125; else &#123;</div><div class="line">        insertNode(root, newNode);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="addition">+    /**</span></div><div class="line"><span class="addition">+     * 中序遍历</span></div><div class="line"><span class="addition">+     * @param &#123;Function&#125; callback - 决定如何处理节点</span></div><div class="line"><span class="addition">+     */</span></div><div class="line"><span class="addition">+    this.inOrderTraverse = function (callback) &#123;</span></div><div class="line"><span class="addition">+      inOrderTraverseNode(root, callback);</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+  &#125;</span></div><div class="line"></div><div class="line">  // 初始化调用</div><div class="line">  var nodes = [8, 3, 10, 1, 6, 14, 4, 7, 13]</div><div class="line">  var binaryTree = new BinaryTree();</div><div class="line">  nodes.forEach(function (key) &#123;</div><div class="line">    binaryTree.insert(key)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"><span class="addition">+  // 调用成功后输出当前节点</span></div><div class="line"><span class="addition">+  var callback = function (key) &#123;</span></div><div class="line"><span class="addition">+    console.log(key)</span></div><div class="line"><span class="addition">+  &#125;</span></div><div class="line"></div><div class="line">  // 中序调用</div><div class="line"><span class="addition">+  binaryTree.inOrderTraverse(callback);</span></div></pre></td></tr></table></figure><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>虽然前面已经有了中序遍历可以遍历节点, 为啥还要浪费精力学前序呢? 诶~这是因为每一种遍历都有自己应用优势.</p><p>前序遍历最大的作用, 就是如果我们想把已经有了的二叉树重新复制一遍, 使用前序遍历得到的效率相比重新构造一次来说, 两者的差距能差好几倍.</p><p>前序遍历的顺序与中序遍历有些不同, 前序是以: <strong>根元素 - 左节点 - 右节点</strong>的顺序来遍历.</p><img src="/blog/2018/01/10/深入学习之排序二叉树/img-3.png" title="前序遍历路线图"><p>这里将遍历的路线图简化了下, 红色输出, 黄色返回上一级, 而绿色则是右子树遍历. 可以看到这是很典型的递归思想. 紧接着我们继续在代码上进行扩展.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryTree</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="comment">// other code...</span></div><div class="line"></div><div class="line">  <span class="comment">// 前序排序</span></div><div class="line">  <span class="keyword">var</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">      callback(node.key)</div><div class="line">      preOrderTraverseNode(node.left, callback)</div><div class="line">      preOrderTraverseNode(node.right, callback)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 中序遍历</div><div class="line">   * 暴露中序遍历的方法</div><div class="line">   * </div><div class="line">   * @param &#123;Function&#125; callback - 决定如何处理节点</div><div class="line">   */</div><div class="line">  <span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    inOrderTraverseNode(root, callback);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  binaryTree.preOrderTraverse(callback);</div><div class="line">  <span class="comment">// callback会依次打印 8 3 1 6 4 7 10 14 13</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>看到这里, 大家可能已经意识到了. 不同的遍历方法实际上是对当前的节点访问的顺序不一样. 后序遍历的访问的次序就是: <strong>左节点 - 右节点 - 根元素</strong>. 它的特点是, 当下面的左右孩子都遍历完了后才会触发回调函数(callback). 因此适用于破坏性操作的情况, 比如删除所有的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryTree</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="comment">// other code...</span></div><div class="line"></div><div class="line">  <span class="comment">// 后序排序</span></div><div class="line">  <span class="keyword">var</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">      preOrderTraverseNode(node.left, callback)</div><div class="line">      preOrderTraverseNode(node.right, callback)</div><div class="line">      callback(node.key)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 后序遍历</div><div class="line">   * 暴露后序遍历的方法</div><div class="line">   * </div><div class="line">   * @param &#123;Function&#125; callback - 决定如何处理节点</div><div class="line">   */</div><div class="line">  <span class="keyword">this</span>.postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">    inOrderTraverseNode(root, callback);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  binaryTree.postOrderTraverse(callback);</div><div class="line">  <span class="comment">// callback会依次打印 1 4 7 6 3 13 14 10 8</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="二叉树节点查找"><a href="#二叉树节点查找" class="headerlink" title="二叉树节点查找"></a>二叉树节点查找</h3><p>找出排序二叉树的最大节点和最小节点实际上也很简单. 前文提过, 根据排序二叉树的特性, 节点左孩子的值, 一定比节点本身小. 节点右孩子的值一定比节点本身大. 因此我们可以根据这个规则来进行查找:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryTree</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="comment">// other code ...</span></div><div class="line">  <span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">      <span class="comment">// 循环逐级向下查找, 直到没有左孩子(最小节点)</span></div><div class="line">      <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</div><div class="line">        node = node.left;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 循环结束后直接反馈 node值</span></div><div class="line">      <span class="keyword">return</span> node.key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">      <span class="keyword">while</span> (node &amp;&amp; node.right) &#123;</div><div class="line">        node = node.right;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> node.key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 最小节点</span></div><div class="line">  <span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> minNode(root)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 最大节点</span></div><div class="line">  <span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> maxNode(root)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"min node is:"</span> + binaryTree.min())    <span class="comment">// 输出1</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"min node is:"</span> + binaryTree.max())    <span class="comment">// 输出 14</span></div></pre></td></tr></table></figure><p>查找节点是否存在:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryTree</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="comment">// other code</span></div><div class="line">  <span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, key</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">false</span></div><div class="line"></div><div class="line">    <span class="comment">// 依旧是递归思想， key值比node.key值小, 就去查询左子树</span></div><div class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</div><div class="line">      <span class="keyword">return</span> searchNode(node.left, key)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</div><div class="line">      <span class="keyword">return</span> searchNode(node.right, key)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> searchNode(root, key)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(binaryTree.search(<span class="number">7</span>) ? <span class="string">"key 7 is found"</span> : <span class="string">"key 7 is not found"</span>)</div><div class="line"><span class="comment">// key 7 is found</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(binaryTree.search(<span class="number">9</span>) ? <span class="string">"key 9 is found"</span> : <span class="string">"key 9 is not found"</span>)</div><div class="line"><span class="comment">// key 9 is not found</span></div></pre></td></tr></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后将上面的知识总结一下. 首先知道了树的实际上是一种具有层级特性的数据结构, 其中排序二叉树又是一种特殊的树. 它的具有以下几种性质:</p><ol><li>如果左(孩子)子树不为空, 那么左子树一定比父节点(根节点)的值小.</li><li>如果右(孩子)子树不为空, 那么右子树一定比父节点(根节点)的值大.</li><li>其中左、右子树也分别是排序二叉树.</li></ol><p>紧接着创建了二叉树节点后, 我们需要去遍历这些节点. 遍历的方法又分前序遍历, 中序遍历, 后序遍历. 三者的区别仅在遍历的顺序不同, 但却有着不同优势.</p><ul><li>前序遍历是唯一一个从根元素开始遍历的, 其顺序为 <em>根 - 左 - 右</em>, 由于它是从根左右开始, 非常适合像复制节点这样的工作.</li><li>中序遍历的顺序是 <em>左 - 根 - 右</em>, 返回的是一个从小到大(从大到小)排序的好序列.</li><li>后序遍历的顺序是 <em>左 - 右 - 根</em>, 其特点是执行操作时，肯定已经遍历过该节点的左右子节点，故适用于要进行破坏性操作的情况，比如删除所有节点.</li></ul><p>后面还讲到了二叉树节点查找, 利用递归找到二叉树中最小(大)的节点值等.<br>数据结构的学习之路还很长, 以后再一点一点慢慢的深入吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/10/深入学习之排序二叉树/banner.png&quot;&gt;&lt;p&gt;二叉树是一种具有层级特性的的数据结构. 这些知识虽说在日常工作中不常使用, 但还是有必要让我们去学习一下, 研究其原理是如何运作. 下面将分享自己的一些理解和学习笔记, 来谈一谈什么是排序二叉树.&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="排序二叉树" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>优化Vue项目的构建速度</title>
    <link href="http://yoursite.com/2018/01/06/%E4%BC%98%E5%8C%96Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/01/06/优化Vue项目的构建速度/</id>
    <published>2018-01-06T12:19:15.000Z</published>
    <updated>2018-01-08T04:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/06/优化Vue项目的构建速度/banner.png"><p>随着项目依赖的增加, 在配合开发的时候听到后端同学的抱怨 build 时间长, 及其影响开发效率和心情. 然后翻阅了相关的资料开启Vue优化之路~</p><a id="more"></a><h2 id="项目依赖管理"><a href="#项目依赖管理" class="headerlink" title="项目依赖管理"></a>项目依赖管理</h2><p>首先检查一下依赖, 去掉对项目没用的依赖, 然后注意开发依赖跟生产依赖不能弄混. 如<code>scss</code>, <code>scss-loader</code>要放在开发依赖中, 因为编译后就不需要了的.. 这一点我以前也有文章提过<a href="https://anran758.github.io/blog/2017/11/27/%E8%B0%88%E8%B0%88npm%E5%8C%85%E9%87%8C%E7%9A%84%20install%20--save%20%E5%92%8C%20install%20--save-dev%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">两者的区别</a>, 有兴趣的同学可以去看看.</p><h2 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h2><p>修改<code>config/index.js</code>下的文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开发环境dev下, 设置为`eval`能提高最快速度, 但是缺点是不能正确显示行号, Debug会有点影响</span></div><div class="line">devtool: <span class="string">'eval'</span></div><div class="line"></div><div class="line"><span class="comment">// 关闭生产环境的sourceMap, 不懂是啥的话可以看下面的文章</span></div><div class="line"><span class="comment">// 阮一峰 - JavaScript Source Map 详解</span></div><div class="line"><span class="comment">// http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html</span></div><div class="line">productionSourceMap: <span class="literal">false</span></div></pre></td></tr></table></figure><p>在<code>src/mian.js</code>关闭生产环境下的调试信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 关闭生产环境下的调试信息</span></div><div class="line"><span class="keyword">const</span> isDebugMode = process.env.NODE_ENV !== <span class="string">"production"</span>;</div><div class="line">Vue.config.debug = isDebugMode;</div><div class="line">Vue.config.devtools = isDebugMode;</div><div class="line">Vue.config.productionTip = isDebugMode;</div></pre></td></tr></table></figure><h2 id="启动-DllPlugin"><a href="#启动-DllPlugin" class="headerlink" title="启动 DllPlugin"></a>启动 DllPlugin</h2><p>在<code>build</code>文件夹中新增<code>webpac.dll.config.js</code>的js文件. 我们将第三方库抽取出来, 打包<code>dll</code>代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 抽取第三方库</span></div><div class="line"><span class="keyword">const</span> vendors = [</div><div class="line">      <span class="string">"vue/dist/vue.common.js"</span>,</div><div class="line">      <span class="string">"vue-router"</span>,</div><div class="line">      <span class="string">"babel-polyfill"</span>,</div><div class="line">      <span class="string">"axios"</span>,</div><div class="line">      <span class="string">"element-ui"</span>,</div><div class="line">      <span class="string">"mint-ui"</span></div><div class="line">    ]</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="attr">vendor</span>: vendors</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">"../static/js"</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">"[name].dll.js"</span>,</div><div class="line">    <span class="attr">library</span>: <span class="string">"[name]_[hash]"</span> <span class="comment">// vendor.dll.js中暴露出的全局变量名</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</div><div class="line">      <span class="attr">path</span>: path.join(__dirname, <span class="string">"."</span>, <span class="string">"[name]-manifest.json"</span>),</div><div class="line"></div><div class="line">      <span class="comment">// 此处需要和 output.library 的值一致</span></div><div class="line">      name: <span class="string">"[name]_[hash]"</span>,</div><div class="line">      <span class="attr">context</span>: __dirname</div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">      <span class="attr">compress</span>: &#123;</div><div class="line">        <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然后我们写一个快捷的调用方式, 在<code>package.json</code>的<code>script</code>上添加一行代码:<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "scripts": &#123;</div><div class="line">    // other code...</div><div class="line">    "dll": "webpack --config ./build/webpack.dll.config.js"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这样就可以直接在命令行使用<code>npm run dll</code>, 生成<code>vendor-manifest.json</code>和<code>vendor.dll.js</code>, 前者是库文件的<code>node_modle</code>路径和<code>webpack</code>打包id的映射. 后者是我们打包后的代码库.<br></p><p>随后这里我们再安装<code>html-webpack-include-assets-plugin</code>和<code>copy-webpack-plugin</code>这两个插件.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm insatll --save-dev html-webpack-include-assets-plugin copy-webpack-plugin</div></pre></td></tr></table></figure><p></p><p><code>copy-webpack-plugin</code>是因为项目的需要，我们需要copy到指定的目录下.<code>html-webpack-include-assets-plugin</code>是将<code>vendor.dll.js</code>插入到<code>index.html</code>里.</p><p>这里值得一提的是, 虽然我们可以直接在根目录的<code>index.html</code>里插入<code>script</code>, 但实际上并不妥当的. 当你<code>npm run dev</code>后, 你会发现在控制台那一行红色的报错, 告诉着你东西找不到, 虽然不影响开发, 但你会看得很难受.</p><p>紧接着我们在<code>webpack.prod.conf.js</code>上引用我们添加的依赖, 再添加以下代码<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// config 是 config/index.js 里的配置</span></div><div class="line"><span class="comment">// utils.assetsPath 也是 build/utils.js的配置</span></div><div class="line"><span class="comment">// 这里这样写是为了跟项目统一</span></div><div class="line">plugins: [</div><div class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</div><div class="line">    <span class="attr">context</span>: __dirname,</div><div class="line">    <span class="attr">manifest</span>: <span class="built_in">require</span>(<span class="string">'./vendor-manifest.json'</span>)</div><div class="line">  &#125;),</div><div class="line">  <span class="comment">// copy custom static assets</span></div><div class="line">  <span class="keyword">new</span> CopyWebpackPlugin([</div><div class="line">    &#123;</div><div class="line">      <span class="attr">from</span>: path.resolve(__dirname, <span class="string">'../static'</span>),</div><div class="line">      <span class="attr">to</span>: config.build.assetsSubDirectory,</div><div class="line">      <span class="attr">ignore</span>: [<span class="string">'.*'</span>]</div><div class="line">    &#125;</div><div class="line">  ]),</div><div class="line">  <span class="comment">// 将 vendor.dll.js 插入HTML里</span></div><div class="line">  <span class="keyword">new</span> HtmlWebpackIncludeAssetsPlugin(&#123;</div><div class="line">    <span class="attr">assets</span>: [utils.assetsPath(<span class="string">'js/vendor.dll.js'</span>)],</div><div class="line">    <span class="attr">files</span>: [<span class="string">'index.html'</span>],</div><div class="line">    <span class="attr">append</span>: <span class="literal">false</span></div><div class="line">  &#125;),</div><div class="line">]</div></pre></td></tr></table></figure><p></p><p>在命令行进行打包<code>npm run build</code>, 可以看到构建的速度大大的提高啦, 我们的优化也告一段落了~<br><img src="/blog/2018/01/06/优化Vue项目的构建速度/run-build.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后再优化时说说踩的坑, 给后来人一些提示.</p><p><code>Uncaught ReferenceError: vendor_library is not defined</code> - 检查HTML里是否插入<code>vendor.dll.js</code>, 文件是否加载成功, 或者检查是否有路径问题.</p><p>一些打包后hash不变仍然会被清除重新打包 … 这是因为<code>vue-cli</code>默认配置会直接清空<code>dist</code>文件夹里的所有文件, 你提前放一些js文件进去也是没有用的.</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/06/优化Vue项目的构建速度/banner.png&quot;&gt;&lt;p&gt;随着项目依赖的增加, 在配合开发的时候听到后端同学的抱怨 build 时间长, 及其影响开发效率和心情. 然后翻阅了相关的资料开启Vue优化之路~&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅谈对MVC与MVVM的理解</title>
    <link href="http://yoursite.com/2018/01/05/%E6%B5%85%E8%B0%88%E5%AF%B9MVC%E4%B8%8EMVVM%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/05/浅谈对MVC与MVVM的理解/</id>
    <published>2018-01-05T02:32:14.000Z</published>
    <updated>2018-01-07T15:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/01/05/浅谈对MVC与MVVM的理解/banner.jpg"><p>开发中我们常听说MVC, MVP, MVVM这些好像很高端的名词, 那么你了解他实际上是什么东西吗? 下面谈谈对它们的理解.<br><a id="more"></a></p><h3 id="1-MVC"><a href="#1-MVC" class="headerlink" title="1. MVC"></a>1. MVC</h3><p>其实上面所提的三者都是一种软件架构模式(或者说是一种概念), 其中<strong>MVC</strong>的历史最为长远.</p><p>MVC模式可以分成以下三种, 就是模型(module), 界面(View), 控制器(controller). 三者之间的关系.</p><img src="/blog/2018/01/05/浅谈对MVC与MVVM的理解/mvc.jpg" title="各部件通信方式"><p>MVC的好处在于</p><ol><li>视图控制模型分离降低耦合性</li><li>提高代码重用性和可维护性</li><li>因为是单向模块化, 不同层各施其职，互不干涉</li></ol><p>有优点再说说缺点:</p><ol><li>清晰的构架以代码的复杂性为代价, 对小项目优可能反而降低开发效率.</li><li><code>Controller</code>层代码难以复用的, 到后面会变得臃肿.</li><li>运行效率相对较低, 太过于复杂反而不太适合中小型项目</li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM(Module-View-ViewModule)的出现主要是为了解决在开发过程中<code>Controller</code>越来越庞大的问题, 它将<code>Controller</code>替换成了<code>ViewModule</code>, 同时改变了通讯模式, 这是MVVM相对于MVC改进的核心思想.</p><img src="/blog/2018/01/05/浅谈对MVC与MVVM的理解/mvvm.jpg"><p>其中MVVM的显著特点就是双向绑定. <code>view</code>的变动会自动更新到<code>Model</code>中. 其中当下很流行的Vue框架就是采用了这个模式. 下图的就能很清晰的看的懂ViewModel是如何做的.<br><img src="/blog/2018/01/05/浅谈对MVC与MVVM的理解/vue-1.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/01/05/浅谈对MVC与MVVM的理解/banner.jpg&quot;&gt;&lt;p&gt;开发中我们常听说MVC, MVP, MVVM这些好像很高端的名词, 那么你了解他实际上是什么东西吗? 下面谈谈对它们的理解.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git emoji使用指南</title>
    <link href="http://yoursite.com/2017/12/31/Git-emoji%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/12/31/Git-emoji使用指南/</id>
    <published>2017-12-31T15:17:37.000Z</published>
    <updated>2018-01-08T09:08:51.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/31/Git-emoji使用指南/banner.jpg"><p>emoji源于日语词汇“絵文字”, 想必大家对它都挺熟悉的吧, 其拟人化的生动形象，已经成为当下流行的表情之一. 接下来讲一下如何规范的在<code>git</code>中使用emoji提高我们项目的可读性吧~<a id="more"></a></p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>在<code>git commit</code>上加入emoji的二进制符号, 格式为<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:emoji1: :emoji2: 本次提交的主要内容</div></pre></td></tr></table></figure><p></p><p>如初次提交:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m <span class="string">"<img class="github-emoji" title="tada" alt="tada" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f389.png?v7" height="20" width="20"> Initialize Repo"</span></div></pre></td></tr></table></figure><p></p><h4 id="相关规范"><a href="#相关规范" class="headerlink" title="相关规范"></a>相关规范</h4><p>emoji 表情在提交代码的时候也不能乱用，否则容易造成误解. 因此开源项目<a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">gitmoji</a>专门规定了在 github 提交代码时应当遵循的 emoji 规范：</p><table><thead><tr><th style="text-align:left">emoji</th><th style="text-align:left">emoji代码</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><img class="github-emoji" title="tada" alt="tada" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f389.png?v7" height="20" width="20">(喝彩)</td><td style="text-align:left"><code>: tada:</code></td><td style="text-align:left">初始提交</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="art" alt="art" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f3a8.png?v7" height="20" width="20">(调色板)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;art&quot; alt=&quot;art&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3a8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">改进代码的结构/格式</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="zap" alt="zap" src="https://assets-cdn.github.com/images/icons/emoji/unicode/26a1.png?v7" height="20" width="20">(闪电)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;zap&quot; alt=&quot;zap&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/26a1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">提高性能</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="fire" alt="fire" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v7" height="20" width="20">(火焰)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;fire&quot; alt=&quot;fire&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f525.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">删除代码或文件</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="bug" alt="bug" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f41b.png?v7" height="20" width="20">(bug)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;bug&quot; alt=&quot;bug&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f41b.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">修复一个错误</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="ambulance" alt="ambulance" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f691.png?v7" height="20" width="20">(紧急救护车)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;ambulance&quot; alt=&quot;ambulance&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f691.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">关键修补程序</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="sparkles" alt="sparkles" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2728.png?v7" height="20" width="20">(闪亮)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;sparkles&quot; alt=&quot;sparkles&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2728.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">引用新功能</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="memo" alt="memo" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4dd.png?v7" height="20" width="20">(备忘录)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;memo&quot; alt=&quot;memo&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4dd.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">编写文档</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="rocket" alt="rocket" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f680.png?v7" height="20" width="20">(火箭)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;rocket&quot; alt=&quot;rocket&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f680.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">部署新功能</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="recycle" alt="recycle" src="https://assets-cdn.github.com/images/icons/emoji/unicode/267b.png?v7" height="20" width="20">(重构)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;recycle&quot; alt=&quot;recycle&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/267b.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">代码重构</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="lipstick" alt="lipstick" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f484.png?v7" height="20" width="20">(口红)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;lipstick&quot; alt=&quot;lipstick&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f484.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">更新UI和样式文件</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="white_check_mark" alt="white_check_mark" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v7" height="20" width="20">(复选框)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;white_check_mark&quot; alt=&quot;white_check_mark&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2705.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加测试</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="apple" alt="apple" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f34e.png?v7" height="20" width="20">(苹果)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;apple&quot; alt=&quot;apple&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f34e.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">修复MacOS上的问题</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="penguin" alt="penguin" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f427.png?v7" height="20" width="20">(企鹅)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;penguin&quot; alt=&quot;penguin&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f427.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">修复Linux上的问题</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="checkered_flag" alt="checkered_flag" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f3c1.png?v7" height="20" width="20">(旗子)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;checkered_flag&quot; alt=&quot;checkered_flag&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3c1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">修复Windows上的问题</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="robot" alt="robot" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f916.png?v7" height="20" width="20">(机器人)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;robot&quot; alt=&quot;robot&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f916.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">解决Android上的问题</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="green_apple" alt="green_apple" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f34f.png?v7" height="20" width="20">(绿苹果)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;green_apple&quot; alt=&quot;green_apple&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f34f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">解决iOS上的问题</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="bookmark" alt="bookmark" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f516.png?v7" height="20" width="20">(书签)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;bookmark&quot; alt=&quot;bookmark&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f516.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">发布/版本标签</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="rotating_light" alt="rotating_light" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a8.png?v7" height="20" width="20">(警告灯)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;rotating_light&quot; alt=&quot;rotating_light&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">移除 linter 警告</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="construction" alt="construction" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a7.png?v7" height="20" width="20">(施工)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;construction&quot; alt=&quot;construction&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a7.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">工作正在进行中</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="green_heart" alt="green_heart" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png?v7" height="20" width="20">(绿心)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;green_heart&quot; alt=&quot;green_heart&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">修复CI构建</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="arrow_down" alt="arrow_down" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b07.png?v7" height="20" width="20">(下降)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;arrow_down&quot; alt=&quot;arrow_down&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2b07.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">降级依赖关系</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="arrow_up" alt="arrow_up" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b06.png?v7" height="20" width="20">(上升)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;arrow_up&quot; alt=&quot;arrow_up&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2b06.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">升级依赖关系</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="pushpin" alt="pushpin" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4cc.png?v7" height="20" width="20">(图钉)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;pushpin&quot; alt=&quot;pushpin&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4cc.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">将依赖关系固定到特定的版本</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="construction_worker" alt="construction_worker" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f477.png?v7" height="20" width="20">(工人)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;construction_worker&quot; alt=&quot;construction_worker&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f477.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加CI构建系统</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="chart_with_upwards_trend" alt="chart_with_upwards_trend" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c8.png?v7" height="20" width="20">(上升趋势)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;chart_with_upwards_trend&quot; alt=&quot;chart_with_upwards_trend&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加分析或跟踪代码</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="heavy_minus_sign" alt="heavy_minus_sign" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2796.png?v7" height="20" width="20">(减号)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;heavy_minus_sign&quot; alt=&quot;heavy_minus_sign&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2796.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">删除依赖项</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="whale" alt="whale" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f433.png?v7" height="20" width="20">(鲸鱼)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;whale&quot; alt=&quot;whale&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f433.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">关于Docker的工作</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="heavy_plus_sign" alt="heavy_plus_sign" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2795.png?v7" height="20" width="20">(加号)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;heavy_plus_sign&quot; alt=&quot;heavy_plus_sign&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2795.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加一个依赖项</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="wrench" alt="wrench" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f527.png?v7" height="20" width="20">(扳手)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;wrench&quot; alt=&quot;wrench&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f527.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">更改配置文件</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="pencil2" alt="pencil2" src="https://assets-cdn.github.com/images/icons/emoji/unicode/270f.png?v7" height="20" width="20">(铅笔)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;pencil2&quot; alt=&quot;pencil2&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/270f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">修正错别字</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="hankey" alt="hankey" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v7" height="20" width="20">(hankey)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;hankey&quot; alt=&quot;hankey&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">编写需要改进的不好的代码</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="rewind" alt="rewind" src="https://assets-cdn.github.com/images/icons/emoji/unicode/23ea.png?v7" height="20" width="20">(回退)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;rewind&quot; alt=&quot;rewind&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/23ea.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">恢复更改</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="globe_with_meridians" alt="globe_with_meridians" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f310.png?v7" height="20" width="20">(国际化)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;globe_with_meridians&quot; alt=&quot;globe_with_meridians&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f310.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">国际化和本地化</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="twisted_rightwards_arrows" alt="twisted_rightwards_arrows" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f500.png?v7" height="20" width="20">(合并)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;twisted_rightwards_arrows&quot; alt=&quot;twisted_rightwards_arrows&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f500.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">合并分支</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="package" alt="package" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4e6.png?v7" height="20" width="20">(打包)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;package&quot; alt=&quot;package&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4e6.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">更新编译的文件或包</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="alien" alt="alien" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f47d.png?v7" height="20" width="20">(外星人)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;alien&quot; alt=&quot;alien&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f47d.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">由于外部API更改而更新代码</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="truck" alt="truck" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f69a.png?v7" height="20" width="20">(移动搬家)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;truck&quot; alt=&quot;truck&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f69a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">移动或重命名文件</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="page_facing_up" alt="page_facing_up" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c4.png?v7" height="20" width="20">(页面)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;page_facing_up&quot; alt=&quot;page_facing_up&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c4.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加或更新许可证</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="boom" alt="boom" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a5.png?v7" height="20" width="20">(爆炸性)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;boom&quot; alt=&quot;boom&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a5.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">介绍突破性变化</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="bento" alt="bento" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f371.png?v7" height="20" width="20">(便当)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;bento&quot; alt=&quot;bento&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f371.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加或更新资产</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="ok_hand" alt="ok_hand" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f44c.png?v7" height="20" width="20">(好的手势)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;ok_hand&quot; alt=&quot;ok_hand&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f44c.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">由于代码审阅更改而更新代码</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="wheelchair" alt="wheelchair" src="https://assets-cdn.github.com/images/icons/emoji/unicode/267f.png?v7" height="20" width="20">(无障碍)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;wheelchair&quot; alt=&quot;wheelchair&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/267f.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">改善无障碍</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="bulb" alt="bulb" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a1.png?v7" height="20" width="20">(灯泡)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;bulb&quot; alt=&quot;bulb&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a1.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">记录源代码</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="speech_balloon" alt="speech_balloon" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4ac.png?v7" height="20" width="20">(文字框)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;speech_balloon&quot; alt=&quot;speech_balloon&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f4ac.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">更新文字和文字</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="card_file_box" alt="card_file_box" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f5c3.png?v7" height="20" width="20">(存档箱)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;card_file_box&quot; alt=&quot;card_file_box&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f5c3.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">执行与数据库相关的更改</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="loud_sound" alt="loud_sound" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f50a.png?v7" height="20" width="20">(声响)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;loud_sound&quot; alt=&quot;loud_sound&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f50a.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">添加日志</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="mute" alt="mute" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f507.png?v7" height="20" width="20">(静音)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;mute&quot; alt=&quot;mute&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f507.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">删除日志</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="children_crossing" alt="children_crossing" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f6b8.png?v7" height="20" width="20">(用户)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;children_crossing&quot; alt=&quot;children_crossing&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f6b8.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">改善用户体验/可用性</td></tr><tr><td style="text-align:left"><img class="github-emoji" title="building_construction" alt="building_construction" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f3d7.png?v7" height="20" width="20">(建筑)</td><td style="text-align:left"><code>&lt;img class=&quot;github-emoji&quot;  title=&quot;building_construction&quot; alt=&quot;building_construction&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f3d7.png?v7&quot; height=&quot;20&quot; width=&quot;20&quot; /&gt;</code></td><td style="text-align:left">进行架构更改</td></tr></tbody></table><p><strong>参考资料</strong></p><p>Git emoji: <a href="https://gitmoji.carloscuesta.me" target="_blank" rel="noopener">https://gitmoji.carloscuesta.me</a><br>Github emoji列表: <a href="https://segmentfault.com/a/1190000009649780" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009649780</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/31/Git-emoji使用指南/banner.jpg&quot;&gt;&lt;p&gt;emoji源于日语词汇“絵文字”, 想必大家对它都挺熟悉的吧, 其拟人化的生动形象，已经成为当下流行的表情之一. 接下来讲一下如何规范的在&lt;code&gt;git&lt;/code&gt;中使用emoji提高我们项目的可读性吧~
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>新手不知道的JavaScript技巧 - 条件语句的简写技巧</title>
    <link href="http://yoursite.com/2017/12/26/%E6%96%B0%E6%89%8B%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7-if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%A4%E5%AE%9A/"/>
    <id>http://yoursite.com/2017/12/26/新手不知道的技巧-if语句的判定/</id>
    <published>2017-12-26T04:22:15.000Z</published>
    <updated>2018-01-08T08:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/26/新手不知道的技巧-if语句的判定/banner.jpg"><p>可能入坑不久的同学还会用着<code>if (value !== null || Value !== undefined)</code>这样的判断语句, 而实际上只要理解判定的规则, 善用规则, 就能大大的提高代码的可读性. 接下来让我们深入学习一下.</p><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>大多编程语言中最为常用的一个语句就是<code>if</code>语句, 这种条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句. 它的语法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Expression) &#123;</div><div class="line">  statement</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<strong>Expression(表达式/条件)</strong>可以是任意表达式或者值.</p><ol><li>首先它会解析表达式的值</li><li>如果表达式是无法解析的, 会报<code>ReferenceError</code>的错误并停止. 如果不是则继续.</li><li>判断值的引用类型, 如果是布尔值, 字符串和符号则继续. <code>null</code>和<code>undefined</code>永远都返回 false.</li><li>将值传入<code>toBoolean(exprValue)</code>根据下面的规则转换为布尔值.</li></ol><table><thead><tr><th style="text-align:left">value</th><th style="text-align:left">Boolean</th></tr></thead><tbody><tr><td style="text-align:left">未定义(Undefined)</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">空值(null)</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">布尔值(Boolean)</td><td style="text-align:left">返回参数本身</td></tr><tr><td style="text-align:left">数字(Number)</td><td style="text-align:left">如果参数是<code>+0</code>, <code>-0</code>或<code>NaN</code>，则返回<code>false</code>; 否则返回<code>true</code></td></tr><tr><td style="text-align:left">字符串(String)</td><td style="text-align:left">如果参数是空字符串(长度为零)，则返回<code>false</code>; 否则返回<code>true</code></td></tr><tr><td style="text-align:left">Symbol</td><td style="text-align:left">返回 true</td></tr><tr><td style="text-align:left">Object</td><td style="text-align:left">返回 true</td></tr></tbody></table><p>这里我们得出<code>undefined</code>, <code>null</code>, <code>NaN</code>, 空字符串, 和数字 0 都是过不了条件语块的规则, 因此我们可以利用这一点来对代码进行简写.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> userName = <span class="string">'hello'</span>;</div><div class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// bad code</span></div><div class="line"><span class="keyword">if</span> (value != <span class="literal">undefined</span>) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// bad code</span></div><div class="line"><span class="keyword">if</span> (value !== <span class="literal">undefined</span> || value !== <span class="literal">null</span> || value !== <span class="literal">false</span>) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good code</span></div><div class="line"><span class="keyword">if</span> (userName) &#123;</div><div class="line">  something...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// flag锁, 利用取反转换布尔值</span></div><div class="line"><span class="keyword">if</span> (!flag) &#123;</div><div class="line">  flag = <span class="literal">true</span>;</div><div class="line">  something...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相同的, 也没有必要去使用<code>==</code>规范不推荐的方式去隐式转换类型, 这种规则同样适用于<code>三目运算符</code>, <code>switch</code>等条件运算中去… 这样看起来是不是自己的代码整洁多了呢~</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>才疏学浅, 如果有什么说的不对或者需要改进的地方, 可以给我留言大家一起交流. 原创不易, 如果文章对你有帮助的话就随手点个赞鼓励一下呗~</p><p><strong>参考资料</strong><br>ECMA-262 官方文档<br><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-if-statement" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-if-statement</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/26/新手不知道的技巧-if语句的判定/banner.jpg&quot;&gt;&lt;p&gt;可能入坑不久的同学还会用着&lt;code&gt;if (value !== null || Value !== undefined)&lt;/code&gt;这样的判断语句, 而实际上只要理解判定的规则, 善用规则, 就能大大的提高代码的可读性. 接下来让我们深入学习一下.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="JavaScript原理分析" scheme="http://yoursite.com/tags/JavaScript%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>初窥WebSockets</title>
    <link href="http://yoursite.com/2017/12/25/%E5%88%9D%E7%AA%A5Web-Sockets/"/>
    <id>http://yoursite.com/2017/12/25/初窥Web-Sockets/</id>
    <published>2017-12-25T09:39:27.000Z</published>
    <updated>2017-12-26T03:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/25/初窥Web-Sockets/banner.png"><p>要说最令人津津乐道的新浏览器的API, 就数Web Sockets了. 接下来了解一下这个备受争议的API吧~<br><a id="more"></a></p><h2 id="什么是Web-Socket"><a href="#什么是Web-Socket" class="headerlink" title="什么是Web Socket?"></a>什么是Web Socket?</h2><p><strong>Web Socket</strong>是HTML5出来的一个持久化新协议. 它的目标是在一个单独的持久链接上提供全双工, 让客户端和服务器之间的数据交换变得更加简单.</p><p>Web Socket是基于HTTP协议来建立连接. 由于使用了自定义的协议, 因此它的URL模式策略也与标准的HTTP不同, 未加密的<code>http://</code>对应着<code>ws://</code>, 而加密的连接的<code>https://</code>也变成<code>https://</code>.</p><p><strong>那使用Web Socket的好处是什么?</strong></p><ol><li><p>能够在客户端和服务器之间发送非常少的数据, 而不用担心HTTP那样字节级的开销. 由于传递的数据很小, 表面看起来会很适用于移动端.</p></li><li><p>主动性<br>大家都知道, 标准HTTP请求是具有被动性的, 如<code>ajax轮询</code>:<br>客户端: “lalala, 帮我看一下我快递有变动吗?”<br>服务端: “没呢, 没变化”<br>客户端: “那现在呢?”<br>服务端: “也还没..”<br>客户端: “那现在呢?”<br>服务端: “还没…”<br>客户端: “那现在呢?”<br>服务端: “好啦好啦, 物流发生变化了, 你看到这里这里了”<br>客户端: “那开始派送了吗?”<br>服务端: “还没…”<br>这样的缺点是什么… <code>ajax轮询</code>需要服务器有很快的处理速度和资源, 而频繁过多的请求可能会报<code>503 Server Unavailable</code>的错误了.</p><p>而升级为Websocket后, 这时候服务器会主动把东西反馈给你, 如:<br>客户端: “哥们, 咱建立Websocket协议, 需要chat，Websocket协议版本：17（HTTP Request）”<br>服务端：”ok，确认，已升级为Websocket协议(HTTP Protocols Switched)”<br>客户端: “那有啥事的话跟我讲噢”<br>服务端: “balbalbal”<br>服务端: “balbalbal”<br>服务端: “hhhhhhhhhh”<br>服务端: “笑死啦2333333”<br>就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你, 这里场景就适用于聊天室之类的）</p></li><li><p>没有同源限制，客户端可以与任意服务器通信(不用担心跨域)</p></li></ol><h2 id="现状与短处"><a href="#现状与短处" class="headerlink" title="现状与短处"></a>现状与短处</h2><p>既然它存在这种优势为什么如今还是使用的不多呢?<br><code>HTML5</code>新API嘛… 说到<code>HTML5</code>就不得不考虑到<em>兼容性</em>的问题, WebSocket在各浏览器的兼容性不一致这是问题其一.<br><img src="/blog/2017/12/25/初窥Web-Sockets/img-1.png" title="Web Sockets兼容性"></p><p>前文有提过. 相对于PC端, <code>websocket</code>的客户端和服务器之间发送非常少的数据, 表面看起来的确移动端会更有优势. 但是目前以国内的环境来说, 反而不好用. 当网络不稳定的时候开销尤其大.</p><p>看到这里或许会有人问, 啊? 你之前不是说只需要1次HTTP请求就可以做信息传送了蛮?? 是的, 没错. 大家可能会玩过像<em>阴阳师</em>这样的游戏? 网络一闪, 就会让你重新登录.而长轮询断一次只会卡一秒, 而websocket断了则要重新从认证开始, 那当网络不稳定时, 那开销可想而知.</p><p>其次就是性能上并没有绝对的优势, 所以当前主流还是标准的HTTP比较多, 而<code>websocket</code>, 据我所知当下适用的场景也只有手游上的使用了.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><code>websocket</code>的路还很长, 虽然现在使用的不多, 但以后还是可以保留小小的期待. 上文提及资料有部分是来源于网上. 有部分是去咨询了相关的dalao. 才疏学浅若有违权, 或者说的不对的地方望各位指出.</p><p><strong>参考资料:</strong><br>WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎<br><a href="https://www.zhihu.com/question/20215561/answer/40316953" target="_blank" rel="noopener">https://www.zhihu.com/question/20215561/answer/40316953</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/25/初窥Web-Sockets/banner.png&quot;&gt;&lt;p&gt;要说最令人津津乐道的新浏览器的API, 就数Web Sockets了. 接下来了解一下这个备受争议的API吧~&lt;br&gt;
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="WebSocket" scheme="http://yoursite.com/tags/WebSocket/"/>
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>关于点击下拉菜单字体模糊及可能造成boder上下一像素宽度不一的坑</title>
    <link href="http://yoursite.com/2017/12/23/%E5%85%B3%E4%BA%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E6%A8%A1%E7%B3%8A%E5%8F%8A%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90boder%E4%B8%8A%E4%B8%8B%E4%B8%80%E5%83%8F%E7%B4%A0%E5%AE%BD%E5%BA%A6%E4%B8%8D%E4%B8%80%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2017/12/23/关于点击下拉菜单模糊及可能造成boder上下一像素宽度不一的坑/</id>
    <published>2017-12-23T15:22:32.000Z</published>
    <updated>2017-12-23T15:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/23/关于点击下拉菜单模糊及可能造成boder上下一像素宽度不一的坑/transition.gif"><p>关于点击下拉菜单会造成文字模糊及<code>boder 1px</code>上下和左右宽度不一致的问题.<br><a id="more"></a></p><h2 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h2><p>朋友叫帮忙看代码~ 问题是这样的, 当点击下拉菜单时, 整个页面的组件都变模糊一下. 然后border上下的边框能隐约看到会大概溢出那么一点(但是没到一个像素).</p><p>因为使用了<code>element</code>组件, 大概能想到中间加有<code>transition</code>, 对问题进行排查后发现<code>transform</code>这个属性会对后代元素能产生影响, 将属性删除, 问题解决. 具体影响的原理, 现在占个坑, 以后再深入挖掘…</p><h2 id="Bug相关的图"><a href="#Bug相关的图" class="headerlink" title="Bug相关的图"></a>Bug相关的图</h2><img src="/blog/2017/12/23/关于点击下拉菜单模糊及可能造成boder上下一像素宽度不一的坑/bug.gif" title="点击后能明显看到整个组件模糊了"> <img src="/blog/2017/12/23/关于点击下拉菜单模糊及可能造成boder上下一像素宽度不一的坑/img-1.jpg" title="正常下的1像素"> <img src="/blog/2017/12/23/关于点击下拉菜单模糊及可能造成boder上下一像素宽度不一的坑/img-2.jpg" title="1像素下还有一点点的溢出">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/23/关于点击下拉菜单模糊及可能造成boder上下一像素宽度不一的坑/transition.gif&quot;&gt;&lt;p&gt;关于点击下拉菜单会造成文字模糊及&lt;code&gt;boder 1px&lt;/code&gt;上下和左右宽度不一致的问题.&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="transition" scheme="http://yoursite.com/tags/transition/"/>
    
      <category term="transform" scheme="http://yoursite.com/tags/transform/"/>
    
      <category term="布局bug" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80bug/"/>
    
  </entry>
  
  <entry>
    <title>git pull远程仓库代码冲突</title>
    <link href="http://yoursite.com/2017/12/18/git-pull%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81/"/>
    <id>http://yoursite.com/2017/12/18/git-pull远程仓库代码冲突/</id>
    <published>2017-12-18T09:11:24.000Z</published>
    <updated>2017-12-18T14:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/18/git-pull远程仓库代码冲突/banner.jpg"><p>常用git与远程仓库进行交互, 难免会遇到冲突的问题. 现在来了解一下, 当出现这种情况时, 该要如何处理.<br><a id="more"></a></p><h2 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h2><p>代码冲突, 无非就是同时有两个人在改动同一个文件所造成的冲突. 当你使用<code>git pull</code>后, <code>git</code>会提示你:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git pull</div><div class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by merge:</div><div class="line">        src/components/page/file.vue</div><div class="line">Please commit your changes or stash them before you merge.</div><div class="line">Aborting</div><div class="line">Updating 8e191be..c301cdc</div></pre></td></tr></table></figure><p></p><p>这时候你可以使用<code>git stash</code>将本地修改存储起来. 使用<code>git status</code>查看, 是不是干净啦~<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git stash</div><div class="line">Saved working directory and index state WIP on master: 8e191be Merge branch <span class="string">'master'</span> of https://github.com/anran758/<span class="built_in">test</span></div><div class="line">HEAD is now at 8e191be Merge branch <span class="string">'master'</span> of https://github.com/anran758/<span class="built_in">test</span></div><div class="line">$ git status</div><div class="line"><span class="comment"># On branch master</span></div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure><p></p><p>这时再使用将远程仓库的代码pull下来<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  $ git pull</div><div class="line">Updating 8e191be..c301cdc</div><div class="line">Fast-forward</div><div class="line"> src/base/fonts/iconfont.eot                        | B<span class="keyword">in</span> 7320 -&gt; 7548 bytes</div><div class="line"> src/components/page/file.vue      |  10 +-</div><div class="line"> create mode 100644 static/font_503074_8sfhbdjlucjtt9/iconfont.eot</div></pre></td></tr></table></figure><p></p><p>现在要查看现有的储藏, 可以使用<code>git stash list</code><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div><div class="line">stash@&#123;0&#125;: WIP on master: 8e191be Merge branch <span class="string">'master'</span> of https://github.com/anran758/<span class="built_in">test</span></div></pre></td></tr></table></figure><p></p><p>这时我们还原储藏的内容, 使用命令<code>git stash pop &#39;stash@{0}&#39;</code>. <strong>注意这里的要使用引号<code>&#39;stash@{0}&#39;</code>, 因为shell正在使用扩展里的内容, 否则会报一个</strong><code>unknown option: -encodedCommand</code><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git stash pop <span class="string">'stash@&#123;0&#125;'</span></div><div class="line">Auto-merging src/components/page/file.vue</div><div class="line">On branch master</div><div class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   src/components/page/film.vue</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure><p></p><p>之后就可以使用<code>git diff</code>或者利用图形工具, 如sourceTree(可视化git), vscode编辑器上对比代码, 手动解决冲突即可.</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/18/git-pull远程仓库代码冲突/banner.jpg&quot;&gt;&lt;p&gt;常用git与远程仓库进行交互, 难免会遇到冲突的问题. 现在来了解一下, 当出现这种情况时, 该要如何处理.&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="代码冲突" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>什么是.gitkeep? 如何在windows下使用命令行创建.gitkeep文件</title>
    <link href="http://yoursite.com/2017/12/16/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%9B%E5%BB%BA-gitkeep%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/12/16/使用命令行创建-gitkeep文件/</id>
    <published>2017-12-16T14:30:04.000Z</published>
    <updated>2017-12-19T04:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/16/使用命令行创建-gitkeep文件/banner.png"><p>在一些脚手架上构建项目中, 你或许会留意到某个目录中会有个名为<code>.gitkeep</code>的空文件. 那么这个文件是用来做什么的呢?<br><a id="more"></a></p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>什么是<code>.gitkeep</code>? 其实是这样的, 当提交的代码时目录中有空文件夹时<code>git</code>会自动忽略掉. 而有时候你就是想留着这个, 以后有用处不想被忽略怎么办呢? 因此, <code>.gitkeep</code>就应运而生了…</p><p><code>.gitkeep</code>是一个约定俗成的文件名并没有什么特殊规则, 它就相当于一个占位, 让<code>git</code>开始跟踪这个目录.<br>其实任何文件都可以, 只不过大家都遵循这个命名, 会跟具有语义化. 如同字面意思一样…<code>git</code> + <code>keep</code>, 让<code>git</code>保持这个文件夹, 是不是很简单易懂呀?</p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><blockquote><p>“哥, 能发个’.gitkeep’给我蛮? 项目中的弄丢了..”<br>“啊? 直接创建一个不就完啦?”<br>“创建不了呀!!系统不准, 会报错提示必须输入文件名”<br>“噢~是有这个限制的, 你用命令行吧”<br>“搜了圈, 好像没有找到在windows创建的方法诶, “<br>“? ? ?”</p></blockquote><p>没错, 上面这场景就是让我写这篇博客的主要起因…其实windows下环境创建<code>.</code>开头的文件只能通过命令行的方法, 而且方式也很简单. 只需要输入一行命令即可..<br></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">type</span> <span class="built_in">NUL</span> &gt; .gitkeep</div></pre></td></tr></table></figure><p></p><p>这段代码的意思就是创建一个空文件重定向到名为<code>.gitkeep</code>的文件中.</p><h2 id="gitignore与gitkeep"><a href="#gitignore与gitkeep" class="headerlink" title="gitignore与gitkeep"></a>gitignore与gitkeep</h2><p>在脚手架构建的项目中, 你也总能在根目录看到名为<code>.giitignore</code>的文件, 那么它和<code>gitkeep</code>又有什么关联呢? 前文有提过, <code>.gitkeep</code>只是约定俗成的一个名称, 而<code>.gitignore</code>是一个特殊文件, 如果你有什么不想提交上去的东西, 如配置了表单密码的配置文件呀什么的, 你可以写进这个文件中, <code>git</code>会自动的忽略掉它.</p><blockquote><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实像<code>.gitignore</code>带有其他特殊文件还有其他, 如<code>.nojekyll</code>来告诉Github关闭 GitHub Pages 的 Jekyll 相关功能等, 由于实际工作中用的烧, 这里不详谈, 放着让大家去挖掘吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/16/使用命令行创建-gitkeep文件/banner.png&quot;&gt;&lt;p&gt;在一些脚手架上构建项目中, 你或许会留意到某个目录中会有个名为&lt;code&gt;.gitkeep&lt;/code&gt;的空文件. 那么这个文件是用来做什么的呢?&lt;br&gt;
    
    </summary>
    
    
      <category term="cmd" scheme="http://yoursite.com/tags/cmd/"/>
    
      <category term="Githubg" scheme="http://yoursite.com/tags/Githubg/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目中Axios报错Promise未定义及IE10报语法错误的解决方案</title>
    <link href="http://yoursite.com/2017/12/15/Vue%E9%A1%B9%E7%9B%AE%E4%B8%ADAxios%E6%8A%A5%E9%94%99Pomise%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%8F%8AIE10%E6%8A%A5%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/12/15/Vue项目中Axios报错Pomise未定义及IE10报语法错误的解决方案/</id>
    <published>2017-12-15T09:06:21.000Z</published>
    <updated>2017-12-16T12:06:46.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/12/15/Vue项目中Axios报错Pomise未定义及IE10报语法错误的解决方案/banner.jpg"><p>关于IE11及以下版本无法使用Promise还有IE10下报错的问题<br><a id="more"></a></p><h2 id="Promise未定义"><a href="#Promise未定义" class="headerlink" title="Promise未定义 ?"></a>Promise未定义 ?</h2><p>在使用Axios开发时, IE11及以下版本报错会报<code>Promise未定义</code>的错误. 这是因为<code>axios</code>本质上是封装了ES6语法的<code>promise</code>,而<code>promise</code>在IE上并不兼容.<br><img src="/blog/2017/12/15/Vue项目中Axios报错Pomise未定义及IE10报语法错误的解决方案/promise-1.png" title="IE11下的错误"></p><p>然而说到js兼容, 这时候我们又能联想到<code>babel</code>.. 没错, <code>babel</code>中有一个工具叫做<a href="https://babeljs.cn/docs/usage/polyfill/" target="_blank" rel="noopener">babel-Polyfill</a>, 它会仿效一个完整的<code>ES2015+</code>环境，并意图运行于一个应用中而不是一个库/工具. 其实食用的方式也很简单.</p><p>我们将<code>babel-polyfill</code>装进我们项目依赖中. <em>这里值得注意的是, 安装的时候需要安装到<code>dependency</code>(生产依赖)中, 而不是<code>devDependency</code>(开发依赖)</em><br>(tips.关于两者的区别, 我以前的文章有专门讲过, 感兴趣的可以看一下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save babel-polyfill</div></pre></td></tr></table></figure><p>首先在<code>mian.js</code>的<strong>顶部</strong>引入<code>import &quot;babel-polyfill&quot;;</code>确保能够最先加载, 随后我们在<code>build</code>目录下<code>webpack.config.js</code>修改配置, 将app使用<code>babel-polyfill</code>进行编译. 这时候我们再重新编译, 就会发现<code>promise未定义</code>的错误就以及消失了<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">      <span class="attr">app</span>: [<span class="string">"babel-polyfill"</span>, <span class="string">'./src/main.js'</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>你以为文章到这里就结束了吗…. 随即我们切换到IE10下进行测试. 你会发现, 又冒出了一个报错.. Emmm, 解决一个又来一个, 惊不惊喜意不意外?<br><img src="/blog/2017/12/15/Vue项目中Axios报错Pomise未定义及IE10报语法错误的解决方案/IE10-1.png" title="IE10下语法错误"></p><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>当你在IE10下看到提示语法错误的时, 这时候你就得去检查检查<code>package.json</code>下 <code>webpack-dev-server</code>版本是否高于<code>2.6.1</code>. 出现这个报错主要是因为项目中使用了<code>const</code>等语法, 然而IE11以下并不认得ES6语法语法.这个问题只有在开发模式才会出现, 只要es6转码后，打包放到服务器上，就没有问题了.</p><p>如果你想在开发阶段在IE10下测试你的代码, 你可以选择降低版本到<code>2.6.1</code>上, 问题就解决了.<br><img src="/blog/2017/12/15/Vue项目中Axios报错Pomise未定义及IE10报语法错误的解决方案/IE10-2.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/12/15/Vue项目中Axios报错Pomise未定义及IE10报语法错误的解决方案/banner.jpg&quot;&gt;&lt;p&gt;关于IE11及以下版本无法使用Promise还有IE10下报错的问题&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="IE兼容性错误" scheme="http://yoursite.com/tags/IE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%94%99%E8%AF%AF/"/>
    
      <category term="解决方案" scheme="http://yoursite.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
</feed>
